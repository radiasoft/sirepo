{
    "constants": {
        "ELEGANT_ME_EV": 0.51099906,
        "helpUserManualURL": "https://ops.aps.anl.gov/manuals/elegant_latest/elegant.html",
        "helpUserForumURL": "https://www3.aps.anl.gov/forums/elegant/",
        "latticeKeywords": [
            "sto"
        ]
    },
    "dynamicFiles": {
        "externalLibs": {
            "js": [
                "split-1.3.5.min.js"
            ]
        },
        "sirepoLibs": {
            "js": [
                "elegant.js",
                "sirepo-command.js",
                "sirepo-lattice.js"
            ],
            "css": [
                "elegant.css",
                "command.css",
                "lattice.css"
            ]
        }
    },
    "enum": {
        "BunchInputSource": [
            ["sdds_beam", "SDDS Input File"],
            ["bunched_beam", "Twiss Parameters"]
        ],
        "FramesPerSecond": [
            ["1", "1"],
            ["2", "2"],
            ["5", "5"],
            ["10", "10"],
            ["15", "15"],
            ["20", "20"]
        ],
        "LongitudinalBunchMethod": [
            ["1", "sigma s, sigma dp, dp s coupling"],
            ["2", "sigma s, sigma dp, alpha z"],
            ["3", "emit z, beta z, alpha z"]
        ],
        "PhaseSpaceCoordinate": [
            ["x", "x"],
            ["xp", "xp"],
            ["y", "y"],
            ["yp", "yp"],
            ["t", "t"],
            ["p", "p"]
        ],
        "PlotRangeType": [
            ["none", "None"],
            ["fit", "Fit Data"],
            ["fixed", "Fixed"]
        ],
        "AmplificationFactorsPlane": [
            ["h", "Horizontal"],
            ["v", "Vertical"]
        ],
        "ChangeParticleName": [
            ["electron", "electron"],
            ["positron", "positron"],
            ["proton", "proton"],
            ["muon", "muon"],
            ["custom", "custom"]
        ],
        "CorrectMethod": [
            ["one-to-one", "One To One"],
            ["one-to-best", "One To Best"],
            ["one-to-next", "One To Next"],
            ["thread", "Thread"],
            ["global", "Global"]
        ],
        "CorrectMode": [
            ["trajectory", "Trajectory"],
            ["orbit", "Orbit"]
        ],
        "ErrorElementType": [
            ["uniform", "Uniform"],
            ["gaussian", "Gaussian"],
            ["plus_or_minus", "Plus Or Minus"]
        ],
        "FindApertureMode": [
            ["many-particle", "Many Particle"],
            ["single-particle", "Single Particle"],
            ["three-line", "Three Lines"],
            ["five-line", "Five Line"],
            ["seven-line", "Seven Line"],
            ["nine-line", "Nine Line"],
            ["eleven-line", "Nine Line"],
            ["n-lines", "N Lines"]
        ],
        "LinkElementsMode": [
            ["dynamic", "Dynamic"],
            ["static", "Static"]
        ],
        "LinkElementsSourcePosition": [
            ["first", "First"],
            ["before", "Before"],
            ["after", "After"],
            ["adjacent", "Adjacent"],
            ["nearest", "Nearest"],
            ["same-occurence", "Same Occurrence"]
        ],
        "OptimizationSetupMethod": [
            ["simplex", "Simplex"],
            ["grid", "Grid"],
            ["powell", "Powell"],
            ["randomwalk", "Randomwalk"],
            ["randomsample", "Randomsample"],
            ["sample", "Sample"]
        ],
        "OptimizationSetupMode": [
            ["minimize", "Minimize"],
            ["maximize", "Maximize"]
        ],
        "ParallelOptimizationSetupMethod": [
            ["simplex", "Simplex"],
            ["genetic", "Genetic"],
            ["hybridsimplex", "Hybridsimplex"],
            ["swarm", "Swarm"]
        ],
        "Randomize": [
            ["0", "None"],
            ["1", "Independently"],
            ["2", "Pairwise"]
        ],
        "SddsBeamInputType": [
            ["elegant", "Elegant"],
            ["spiffe", "Spiffe"]
        ],
        "SimulationMode": [
            ["serial", "Serial"],
            ["parallel", "Parallel"]
        ],
        "SteeringElementPlane": [
            ["h", "Horizontal"],
            ["v", "Vertical"]
        ],
        "AlphPart": [
            ["0", "Full"],
            ["1", "First half"],
            ["2", "Second half"]
        ],
        "BmapxyMethod": [
            ["", ""],
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["modified-midpoint", "Modified Midpoint"],
            ["two-pass modified-midpoint", "Two Pass Modified Midpoint"],
            ["leap-frog", "Leap Frog"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"]
        ],
        "BmxyzMethod": [
            ["", ""],
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["modified-midpoint", "Modified Midpoint"],
            ["two-pass modified-midpoint", "Two Pass Modified Midpoint"],
            ["leap-frog", "Leap Frog"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"]
        ],
        "BodyFocusModel": [
            ["", "None"],
            ["srs", "SRS"]
        ],
        "CeplMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"],
            ["modified-midpoint", "Modified Midpoint"]
        ],
        "CleanMode": [
            ["stdeviation", "Stdeviation"],
            ["absdeviation", "Absdeviation"],
            ["absvalue", "Absvalue"]
        ],
        "CsrcsbendDerbenevCriterionMode": [
            ["disable", "Disable"],
            ["evaluate", "Evaluate"],
            ["enforce", "Enforce"]
        ],
        "CsrdriftBunchlengthMode": [
            ["rms", "RMS"],
            ["68-percentile", "68 Percentile"],
            ["90-percentile", "90 Percentile"]
        ],
        "CsrdriftSaldin54normMode": [
            ["peak", "Peak"],
            ["first", "First"]
        ],
        "CsrdriftSpreadMode": [
            ["full", "Full"],
            ["simple", "Simple"],
            ["radiation-only", "Radiation Only"]
        ],
        "CsrdriftWavelengthMode": [
            ["sigmaz", "Sigmaz"],
            ["peak-to-peak", "Peak To Peak"]
        ],
        "DistributionType": [
            ["gaussian", "Gaussian"],
            ["hard-edge", "Hard Edge"],
            ["uniform-ellipse", "Uniform Ellipse"],
            ["shell", "Shell"],
            ["dynamic-aperture", "Dynamic Aperture"],
            ["line", "Line"],
            ["halo(gaussian)", "Halo (Gaussian)"]
        ],
        "DscatterPlane": [
            ["", ""],
            ["xp", "xp"],
            ["yp", "yp"],
            ["dp", "dp"]
        ],
        "ErrorElementSampleMode": [
            ["", ""],
            ["random", "random"],
            ["shuffle", "shuffle"],
            ["sequential", "sequential"]
        ],
        "Fiducial": [
            ["", ""],
            ["light", "light"],
            ["tmean", "tmean"],
            ["first", "first"],
            ["pmaximum", "pmaximum"]
        ],
        "IonEffectsFieldCalculationMethod": [
            ["", ""],
            ["gaussianfit", "gaussianfit"],
            ["bigaussian", "bigaussian"],
            ["trigaussian", "trigaussian"],
            ["bilorentzian", "bilorentzian"],
            ["trilorentzian", "trilorentzian"]
        ],
        "IonEffectsFitResidualType": [
            ["max-ad-plus-ad-charge", "max-ad-plus-ad-charge"],
            ["sum-ad", "sum-ad"],
            ["rms-dev", "rms-dev"],
            ["max-ad", "max-ad"],
            ["max-ad-plus-rms-dev", "max-ad-plus-rms-dev"],
            ["sum-ad-plus-rms-dev", "sum-ad-plus-rms-dev"],
            ["rms-dev-plus-ad-sum", "rms-dev-plus-ad-sum"],
            ["sum-ad-plus-ad-sum", "sum-ad-plus-ad-sum"],
            ["rms-dev-plus-centroid", "rms-dev-plus-centroid"],
            ["rms-dev-plus-ad-charge", "rms-dev-plus-ad-charge"]
        ],
        "KsbendMethod": [
            ["modified-midpoint", "Modified Midpoint"],
            ["leap-frog", "Leap Frog"]
        ],
        "NibendFringePosition": [
            ["0", "Fringe centered on reference plane"],
            ["-1", "Fringe inside"],
            ["1", "Fringe outside."]
        ],
        "LsmdltrMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["modified-midpoint", "Modified Midpoint"],
            ["two-pass modified-midpoint", "Two Pass Modified Midpoint"],
            ["leap-frog", "Leap Frog"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"]
        ],
        "LsrmdltrFieldExpansion": [
            ["ideal", "ideal"],
            ["exact", "exact"],
            ["leading terms", "leading terms"]
        ],
        "MapsolenoidMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"],
            ["modified-midpoint", "Modified Midpoint"]
        ],
        "NibendMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["modified-midpoint", "Modified Midpoint"],
            ["two-pass modified-midpoint", "Two Pass Modified Midpoint"],
            ["leap-frog", "Leap Frog"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"]
        ],
        "NibendModel": [
            ["hard-edge", "hard-edge"],
            ["linear", "linear"],
            ["cubic-spline", "cubic-spline"],
            ["tanh", "tanh"],
            ["quintic", "quintic"],
            ["enge1", "enge1"],
            ["enge3", "enge3"],
            ["enge5", "enge5"]
        ],
        "NiseptMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["modified-midpoint", "Modified Midpoint"],
            ["two-pass modified-midpoint", "Two Pass Modified Midpoint"],
            ["leap-frog", "Leap Frog"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"]
        ],
        "NiseptModel": [
            ["hard-edge", "hard-edge"],
            ["linear", "linear"],
            ["cubic-spline", "cubic-spline"],
            ["tanh", "tanh"],
            ["quintic", "quintic"]
        ],
        "OpenSide": [
            ["", ""],
            ["+x", "+x"],
            ["-x", "-x"],
            ["+y", "+y"],
            ["-y", "-y"]
        ],
        "QuadFringeType": [
            ["inset", "inset"],
            ["fixed-strength", "fixed-strength"],
            ["integrals", "integrals"]
        ],
        "QufringeDirection": [
            ["0", "None"],
            ["1", "Entrance"],
            ["-1", "Exit"]
        ],
        "Rftmez0Method": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"],
            ["modified-midpoint", "Modified Midpoint"]
        ],
        "SetReferenceParticleOutputComparisonMode": [
            ["", ""],
            ["max-ad", "max-ad"],
            ["sum-ad", "sum-ad"],
            ["sum-sqr", "sum-sqr"]
        ],
        "SpeedbumpInsertFrom": [
            ["", ""],
            ["x", "x"],
            ["+x", "+x"],
            ["-x", "-x"],
            ["y", "y"],
            ["+y", "+y"],
            ["-y", "-y"]
        ],
        "TfbpickupPlane": [
            ["x", "x"],
            ["y", "y"],
            ["delta", "delta"],
            ["phase", "phase"]
        ],
        "TPFiducial": [
            ["t,median", "t,median"],
            ["t,min", "t,min"],
            ["t,max", "t,max"],
            ["t,ave", "t,ave"],
            ["t,first", "t,first"],
            ["t,light", "t,light"],
            ["p,median", "p,median"],
            ["p,min", "p,min"],
            ["p,max", "p,max"],
            ["p,ave", "p,ave"],
            ["p,first", "p,first"],
            ["p,light", "p,light"]
        ],
        "TmcfMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"],
            ["modified-midpoint", "Modified Midpoint"]
        ],
        "TwissParameter": [
            ["none", "None"],
            ["betax", "betax"],
            ["alphax", "alphax"],
            ["psix", "psix"],
            ["etax", "etax"],
            ["etaxp", "etaxp"],
            ["xAperture", "xAperture"],
            ["betay", "betay"],
            ["alphay", "alphay"],
            ["psiy", "psiy"],
            ["etay", "etay"],
            ["etayp", "etayp"],
            ["yAperture", "yAperture"]
        ],
        "TwlaMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"],
            ["modified-midpoint", "Modified Midpoint"]
        ],
        "TwmtaMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"],
            ["modified-midpoint", "Modified Midpoint"]
        ],
        "TwplMethod": [
            ["runge-kutta", "Runge-Kutta"],
            ["bulirsch-stoer", "Bulirsch-Stoer"],
            ["non-adaptive runge-kutta", "Non-adaptive Runge-Kutta"],
            ["modified-midpoint", "Modified Midpoint"]
        ],
        "TrfmodePlane": [
            ["x", "X"],
            ["y", "Y"],
            ["both", "Both"]
        ],
        "UkickmapYawEnd": [
            ["-1", "Entrance"],
            ["0", "Center"],
            ["1", "Exit"]
        ],
        "WatchMode": [
            ["coordinate", "coordinate"],
            ["parameter", "parameter"],
            ["centroid", "centroid"],
            ["fft", "fft"],
            ["fft hanning", "fft hanning"],
            ["fft parzen", "fft parzen"],
            ["fft welch", "fft welch"],
            ["fft uniform", "fft uniform"]
        ]
    },
    "frameIdFields": {
        "animation": [
            "x",
            "y1",
            "y2",
            "y3",
            "histogramBins",
            "xFileId",
            "plotRangeType",
            "horizontalSize",
            "horizontalOffset",
            "verticalSize",
            "verticalOffset"
        ]
    },
    "localRoutes": {
        "source": {
            "config": {
                "controller": "ElegantSourceController as source",
                "templateUrl": "/static/html/elegant-source.html"
            }
        },
        "lattice": {
            "route": "/lattice/:simulationId",
            "config": {
                "controller": "LatticeController as lattice",
                "template": "<div data-lattice-tab=\"\" data-controller=\"lattice\"></div>"
            }
        },
        "control": {
            "route": "/control/:simulationId",
            "config": {
                "controller": "CommandController as control",
                "template": "<div data-command-tab=\"\" data-controller=\"control\"></div>"
            }
        },
        "visualization": {
            "route": "/visualization/:simulationId",
            "config": {
                "controller": "VisualizationController as visualization",
                "templateUrl": "/static/html/elegant-visualization.html"
            }
        }
    },
    "model": {
        "beamline": {
            "name": ["Name", "ValidatedString"]
        },
        "beamlineReport": {
            "notes": ["Notes", "Text", ""]
        },
        "bunchSource": {
            "inputSource": ["Bunch Source", "BunchInputSource", "bunched_beam"]
        },
        "bunch": {
            "p_central_mev": ["Central momentum of the beamline [MeV/c]", "RPNValue", 1001, "Central momentum of the beamline in MeV/c, about which expansions are done. This corresponds to p_central_mev field of the run_setup command.", 0],
            "n_particles_per_bunch": ["Particles Per Bunch", "Integer", 1, "Number of particles in each bunch (max 10,000,000)", 1, 10000000],
            "symmetrize": ["Symmetrize", "RPNBoolean", "0", "If non-zero, the distribution is symmetric under changes of sign in the coordinates. Automatically results in a zero centroid for all coordinates."],
            "centroid": ["Centroid", "Float6StringArray", "0, 0, 0, 0, 0, 0", "Centroid offsets for each of the six coordinates.", "X, X', Y, Y', T, P"],
            "time_start": ["Time Start", "RPNValue", 0, "The central value of the time coordinate for the bunch."],
            "momentum_chirp": ["Momentum Chirp", "RPNValue", 0, "Permits imparting an additional momentum chirp to the beam, in units of 1/m. E.g., a value of 1 indicates that a 1mm long bunch has a linear variation in momentum of 0.1% from end-to-end. A positive chirp is needed to provide compression of a bunch with an ordinary R₅₆<0 four-dipole chicane."],

            "distribution_type": ["Distribution Type", "DistributionTypeStringArray", "gaussian, gaussian, gaussian", "Distribution type for each plane. May be \"gaussian\", \"hard-edge\", \"uniform-ellipse\", \"shell\", \"dynamic-aperture\", \"line\", or \"halo(gaussian)\". For the transverse plane, the interpretation of the emittance is different for the different beam types. For gaussian beams, the emittances are rms values. For all other types, √ε*β times the distribution cutoff defines the edge of the beam in position space, while √ε*(1+α^2)/β times the distribution cutoff defines the edge of the beam in slope space. A hard-edge beam is a uniformly-filled parallelogram in phase space. A uniform-ellipse beam is a uniformly-filled ellipse in phase space. A shell beam is a hollow ellipse in phase space. A dynamic aperture beam has zero slope and uniform spacing in position coordinates. A line beam is a line in phase space. A \"halo(gaussian)\" beam is the part of the gaussian distribution beyond the distribution cutoff.", "X, Y, Z"],
            "distribution_cutoff": ["Distribution Cutoff", "Integer3StringArray", "2, 2, 2", "Distribution cutoff parameters for each plane. For gaussian distributions, this is the number of sigmas to use. For other distributions (except dynamic aperture), this number simply multiplies the sizes. This is potentially confusing and hence it is suggested that the distribution cutoff be set to 1 for nongaussian beams. The exception is \"dynamic-aperture\" distribution type. In this case, the cutoff value is the number of grid points in the dimension in question.", "X, Y, Z"],
            "enforce_rms_values": ["Enforce RMS Values", "BooleanStringArray", "0, 0, 0", "Flags, one for each plane, indicating whether to force the distribution to have the specified RMS properties.", "X, Y, Z"],
            "limit_invariants": ["Limit Invariants", "Integer", 0, "If non-zero, the distribution cutoffs are applied to the invariants, rather than to the coordinates. This is useful for gaussian beams when the distribution cutoff is small."],
            "limit_in_4d": ["Limit In 4D", "RPNBoolean", "0", "If non-zero, then the transverse distribution is taken to be a 4-d gaussian or uniform distribution. One of these must be chosen using the distribution_type control. It must be the same for x and y. This is useful, for example, if you want to make a cylindrically symmetric beam."],
            "emit_x": ["Horizontal Geometric Emittance [m]", "RPNValue", 0, "", 0],
            "emit_nx": ["Horizontal Normalized Emittance", "RPNValue", 0, "", 0],
            "beta_x": ["Horizontal Beta [m]", "RPNValue", 1, "", 1e-99],
            "alpha_x": ["Horizontal Alpha", "RPNValue", 0, ""],
            "eta_x": ["Horizontal Eta", "RPNValue", 0, ""],
            "etap_x": ["Horizontal Etap", "RPNValue", 0, ""],
            "emit_y": ["Vertical Geometric Emittance [m]", "RPNValue", 0, "", 0],
            "emit_ny": ["Vertical Normalized Emittance", "RPNValue", 0, "", 0],
            "beta_y": ["Vertical Beta [m]", "RPNValue", 1, "", 1e-99],
            "alpha_y": ["Vertical Alpha", "RPNValue", 0, ""],
            "eta_y": ["Vertical Eta", "RPNValue", 0, ""],
            "etap_y": ["Vertical Etap", "RPNValue", 0, ""],
            "longitudinalMethod": ["Longitudinal Method", "LongitudinalBunchMethod", "1"],
            "emit_z": ["Longitudinal Geometric Emittance [m]", "RPNValue", 0, "Provide another way to specify the longitudinal phase space, either separately from or in combination with sigma_dp, sigma_s, and dp_s_coupling. Basically, which values elegant uses depends on what one sets to nonzero values. If one sets emit_z, then sigma_dp, sigma_s, and dp_s_coupling are ignored. If one doesn't set emit_z, then elegant uses sigma_dp and sigma_s; it additionally uses alpha_z if it is nonzero, otherwise it uses dp_s_coupling. For reference, the relationship between them is C = Σ₅₆ / √Σ₅₅Σ₆₆}} = -α / √1+α^2}. Note that to impart a chirp that results in compression for R₅₆<0 (e.g., a normal four-dipole chicane), one must have αz<0 or C>0.", 0],
            "beta_z": ["Longitudinal Beta [m]", "RPNValue", 0, "", 0],
            "alpha_z": ["Longitudinal Alpha", "RPNValue", 0, ""],
            "sigma_s": ["Sigma s [m]", "RPNValue", 0, "Bunch length. Note that sigma_s is actually the length in βz*c*t, so that for βz<<1 the length of the bunch in time will be greater than one might expect."],
            "sigma_dp": ["Sigma dp", "RPNValue", 0, "Fractional momentum spread, δ"],
            "dp_s_coupling": ["dp s Coupling", "RPNValue", 0, "Specifies the coupling between s and δ, defined as ⟨ s δ ⟩/(σsσδ).", -1, 1],
            "halton_sequence": ["Halton Sequence", "BooleanStringArray", "0, 0, 0", "This provides a \"quiet-start\" feature by choosing Halton sequences in place of random number generation. There are three new variables that control this feature. halton_sequence is an array of three flags that permit turning on Halton sequence generation for the horizontal, vertical, or longitudinal planes. For example, halton_sequence[0] = 3*1 will turn on Halton sequences for all three planes, while halton_sequence[2] = 1, will turn it on for the longitudinal plane only.", "X, Y, Z"],
            "halton_radix": ["Halton Radix", "Integer6StringArray", "0, 0, 0, 0, 0, 0", "halton_radix is an array of six integers that permit giving the radix for each sequence (i.e., x, x', y, y', t, p). Each radix must be a prime number. One should never use the same prime for two sequences, unless one randomizes the order of the sequences relative to each other (see the next item). If these are left at zero, then elegant chooses values that eliminate phase-space banding to some extent. The user is cautioned to plot all coordinate combinations for the initial phase space to ensure that no unacceptable banding is present. A suggested way to use Halton sequences is to set halton_radix[0] = 2, 3, 2, 3, 2, 3 and to set randomize_order[0] = 2, 2, 2,. This avoids banding that may result from choosing larger radix values.", "X, X', Y, Y', T, P"],
            "optimized_halton": ["Optimized Halton", "RPNBoolean", "0", "optimized_halton uses the improved halton sequence. (Algorithm 659, Collected Algorithm from ACM. Derandom Algorithm is added by Hongmei CHI (CS/FSU)). It avoids the banding problem automatically and the halton_radix values are ignored."],
            "randomize_order": ["Randomize Order", "RandomizeStringArray", "0, 0, 0", "Allows randomizing the order of assigned coordinates for the pairs (x, x'), (y, y'), and (t,p). 0 means no randomization; 1 means randomize (x, x', y, y', t, p) values independently, which destroys any x-x', y-y', and t-p correlations; 2 means randomize (x, x'), (y, y'), and (t, p) in pair-wise fashion. This is used with Halton sequences to remove banding. It is suggested that that the user employ sddsanalyzebeam to verify that the beam properties when randomization is used.", "X, Y, Z"]
        },
        "bunchFile": {
            "sourceFile": ["Beam File", "InputFile", ""]
        },
        "bunchReport": {
            "x": ["Phase Space Coordinate", "PhaseSpaceCoordinate"],
            "y": ["Phase Space Coordinate", "PhaseSpaceCoordinate"],
            "histogramBins": ["Histogram Bins", "Integer"],
            "colorMap": ["Color Map", "ColorMap", "afmhot"],
            "notes": ["Notes", "Text", ""]
        },
        "elementAnimation": {
            "x": ["Horizontal Value to Plot", "ValueList", ""],
            "xFile": ["File X", "ValueList", ""],
            "y1": ["Vertical Value to Plot", "ValueList", ""],
            "y1File": ["File Y", "ValueList", ""],
            "y2": ["Vertical Value to Plot", "ValueList", ""],
            "y2File": ["File Y2", "ValueList", ""],
            "y3": ["Vertical Value to Plot", "ValueList", ""],
            "y3File": ["File Y3", "ValueList", ""],
            "includeLattice": ["Show Lattice Overlay", "Boolean", "0"],
            "histogramBins": ["Histogram Bins", "Integer", 200],
            "framesPerSecond": ["Frames per Second", "FramesPerSecond", "2"],
            "colorMap": ["Color Map", "ColorMap", "afmhot"],
            "plotRangeType": ["Range", "PlotRangeType", "none"],
            "horizontalSize": ["Horizontal Size", "Float", 0],
            "verticalSize": ["Vertical Size", "Float", 0],
            "horizontalOffset": ["Horizontal Offset", "Float", 0],
            "verticalOffset": ["Vertical Offset", "Float", 0],
            "aspectRatio": ["Aspect Ratio", "AspectRatio", "1"],
            "notes": ["Notes", "Text", ""]
        },
        "parameterTable": {
            "file": ["File", "FileValueList", ""],
            "page": ["Page", "ValueList", ""]
        },
        "rpnVariable": {
            "name": ["Name", "String"],
            "value": ["Value", "RPNValue"]
        },
        "simulation": {
            "visualizationBeamlineId": ["Beamline", "LatticeBeamlineList", ""],
            "simulationMode": ["Execution", "SimulationMode", "serial"]
        },
        "simulationStatus": {},
        "twissReport": {
            "y1": ["Y1 Value", "TwissParameter", "betax"],
            "y2": ["Y2 Value", "TwissParameter", "betay"],
            "y3": ["Y3 Value", "TwissParameter", "etax"],
            "includeLattice": ["Show Lattice Overlay", "Boolean", "1"]
        },
        "command_alter_elements": {
            "name": ["Name", "OptionalStringUpper", "", "A possibly-wildcard-containing string giving the names of the elements to alter. If not specified, then one must specify type."],
            "item": ["Item", "OptionalStringUpper", "", "The name of the parameter to alter."],
            "type": ["Type", "OptionalStringUpper", "", "A possibly-wildcard-containing string giving the names of element types to alter. May be specified with name or by itself."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "A possibly-wildcard-containing string giving the names of elements to excluded from alteration."],
            "value": ["Value", "RPNValue", 0, "The new value for the parameter. Use string_value only if the parameter takes a character string as its value."],
            "string_value": ["String Value", "OptionalString", "", ""],
            "differential": ["Differential", "RPNBoolean", "0", "If nonzero, the new value is the predefined value of the parameter plus the quantity given with value."],
            "multiplicative": ["Multiplicative", "Integer", 0, "If nonozero, the new given value is the predefined value of the parameter times the quantity given with value."],
            "alter_at_each_step": ["Alter at Each Step", "RPNBoolean", "0", "If nonzero, the changes requested by the command are performed at each simulation step. Note that if differential or multiplicative are non-zero, then changes will accumulate. (A more conventional way to perform such variation is with vary_elements.)"],
            "alter_before_load_parameters": ["Alter Before Load Parameters", "RPNBoolean", "0", "If alter_at_each_step, by default the alteration takes place after any load_parameters commands are processed. If this control is non-zero, the alteration takes place before any load_parameters commands are processed."],
            "verbose": ["Verbose", "RPNBoolean", "0", "If nonzero, information is printed to the standard output describing what elements are changed."],
            "allow_missing_elements": ["Allow Missing Elements", "RPNBoolean", "0", "If nonzero, then it is not an error if an element matching name does not exist. Normally, such an occurence is an error and terminates the program."],
            "allow_missing_parameters": ["Allow Missing Parameters", "RPNBoolean", "0", "If nonzero, then it is not an error if an element does not have the parameter named with item. Normally, such an occurence is an error and terminates the program."],
            "start_occurence": ["Start Occurence", "Integer", 0, "If nonzero, these give the starting and ending occurence numbers of elements that will be altered. N.B.: if wildcards are used, occurence number counting is for each set of identically-named elements separately, rather than for the sequence of matched elements."],
            "end_occurence": ["End Occurence", "Integer", 0, ""],
            "s_start": ["S Start", "RPNValue", -1, "If non-negative, these give the gaving and ending position limits for the end-of-element locations of elements to be altered."],
            "s_end": ["S End", "RPNValue", -1, ""],
            "before": ["Before", "OptionalStringUpper", "", "The name of an element. If given, the alteration is applied only to elements that precede the named element in the beamline."],
            "after": ["After", "OptionalStringUpper", "", "The name of an element. If given, the alteration is applied only to elements that follow the named element in the beamline."]
        },
        "command_amplification_factors": {
            "output": ["Output", "OutputFile", "", "The name of a file for text output."],
            "uncorrected_orbit_function": ["Uncorrected Orbit Function", "OutputFile", "", "The name of a file for an SDDS-format output of the uncorrected-orbit amplification function."],
            "corrected_orbit_function": ["Corrected Orbit Function", "OutputFile", "", "The name of a file for an SDDS-format output of the corrected-orbit amplification function."],
            "kick_function": ["Kick Function", "OutputFile", "", "The name of a file for an SDDS-format output of the kick amplification function."],
            "name": ["Name", "OptionalStringUpper", "", "The optionally wildcarded name of the orbit-perturbing elements."],
            "type": ["Type", "OptionalStringUpper", "", "The optional type name of the the orbit-perturbing elements."],
            "item": ["Item", "OptionalStringUpper", "", "The parameter of the elements producing the orbit."],
            "plane": ["Plane", "AmplificationFactorsPlane", "", ""],
            "change": ["Change", "RPNValue", 1e-3, "The parameter change to use in computing the amplification."],
            "number_to_do": ["Number To Do", "Integer", -1, "The number of elements to perturb."],
            "maximum_z": ["Maximum Z", "RPNValue", 0, "The maximum z coordinate of the elements to perturb."]
        },
        "command_analyze_map": {
            "output": ["Output", "OutputFile", "", "The name of a file for SDDS output."],
            "output_order": ["Output Order", "Integer", 1, ""],
            "printout": ["Printout", "OutputFile", "", "The name of a file for text output of the matrix."],
            "delta_x": ["Delta X", "RPNValue", 1e-6, "The amount by which to change the quantity X in computing the derivatives that give the matrix elements."],
            "delta_xp": ["Delta XP", "RPNValue", 1e-6, ""],
            "delta_y": ["Delta Y", "RPNValue", 1e-6, ""],
            "delta_yp": ["Delta YP", "RPNValue", 1e-6, ""],
            "delta_s": ["Delta S", "RPNValue", 1e-6, ""],
            "delta_dp": ["Delta DP", "RPNValue", 1e-6, ""],
            "accuracy_factor": ["Accuracy Factor", "RPNValue", 1e-12, "The fraction of the maximum absolute value of the final coordinate that is considered meaningful. Used to estimate errors and eliminate spurious matrix elements."],
            "center_on_orbit": ["Center On Orbit", "RPNBoolean", "0", "A flag directing the expansion to be made about the closed orbit instead of the design orbit."],
            "verbosity": ["Verbosity", "Integer", 0, "The larger this value, the more output is printed during computations."],
            "canonical_variables": ["Canonical Variables", "RPNBoolean", "0", "If non-zero, the matrix is expressed in terms of canonical variables (x,qx,y,qy,-s,δ) instead of the default (x,x′,y,y′,s,δ)."],
            "printout_order": ["Printout Order", "Integer", 2, "Order of the matrix to be printed to the printout file."],
            "periodic": ["Periodic", "RPNBoolean", "1", "If non-zero, system is assumed to be periodic and lattice functions, tunes, chromaticities, etc are computed."],
            "beta_x": ["Beta X", "RPNValue", 1, "If periodic=0, these are the starting values for the lattice functions."],
            "alpha_x": ["Alpha X", "RPNValue", 0, ""],
            "eta_x": ["Eta X", "RPNValue", 0, ""],
            "etap_x": ["Etap X", "RPNValue", 0, ""],
            "beta_y": ["Beta Y", "RPNValue", 1, ""],
            "alpha_y": ["Alpha Y", "RPNValue", 0, ""],
            "eta_y": ["Eta Y", "RPNValue", 0, ""],
            "etap_y": ["Etap Y", "RPNValue", 0, ""],
            "n_points": ["N Points", "Integer", 9, "Number of points in each phase-space dimension."],
            "max_fit_order": ["Max Fit Order", "Integer", 8, "Maximum order of fits using in determining the matrix elements."]
        },
        "command_aperture_data": {
            "input": ["Input", "InputFile", "", "Name of SDDS file supplying the aperture data. The following columns are all required, in double or float type, with units of m (meters). ( • s — Distance along the central trajectory. • xHalfAperture — Half aperture in the horizontal. • yHalfAperture — Half aperture in the vertical. • xCenter — Center of the aperture in the horizontal. • yCenter — Center of the aperture in the vertical. )"],
            "periodic": ["Periodic", "RPNBoolean", "1", "If non-zero, the aperture is a periodic function of s, with period equal to the range of the data."],
            "persistent": ["Persistent", "RPNBoolean", "0", "If non-zero, the aperture data persists across subsequent run_setup commands. By default, the aperture data is forgotten when a new run_setup command is seen."],
            "disable": ["Disable", "RPNBoolean", "0", "If non-zero, the command is ignored."]
        },
        "command_bunched_beam": {
            "bunch": ["Bunch", "OutputFile", "", "The name of an SDDS file to which the phase-space coordinates of the bunches are to be written."],
            "n_particles_per_bunch": ["N Particles Per Bunch", "Integer", 1, "Number of particles in each bunch."],
            "time_start": ["Time Start", "RPNValue", 0, "The central value of the time coordinate for the bunch."],
            "matched_to_cell": ["Matched To Cell", "OptionalStringUpper", "", "The name of a beamline from which the Twiss parameters of the bunch are to be computed."],
            "emit_x": ["Emit X", "RPNValue", 0, "RMS emittance for the X plane."],
            "emit_nx": ["Emit NX", "RPNValue", 0, "RMS normalized emittance for the X plane. Ignored if emit_X is nonzero."],
            "beta_x": ["Beta X", "RPNValue", 1.0, "Twiss parameters for the X plane."],
            "alpha_x": ["Alpha X", "RPNValue", 0, ""],
            "eta_x": ["Eta X", "RPNValue", 0, ""],
            "etap_x": ["Etap X", "RPNValue", 0, ""],
            "emit_y": ["Emit Y", "RPNValue", 0, ""],
            "emit_ny": ["Emit NY", "RPNValue", 0, ""],
            "beta_y": ["Beta Y", "RPNValue", 1.0, ""],
            "alpha_y": ["Alpha Y", "RPNValue", 0, ""],
            "eta_y": ["Eta Y", "RPNValue", 0, ""],
            "etap_y": ["Etap Y", "RPNValue", 0, ""],
            "use_twiss_command_values": ["Use Twiss Command Values", "RPNBoolean", "0", "If nonzero, then the values for β, α, η, and η^′ are taken from the twiss_output command. It is an error if no twiss_output command has been given."],
            "use_moments_output_values": ["Use Moments Output Values", "RPNBoolean", "0", "If nonzero, then the beam is generated to match the 6D matched, equilibrium beam moments computed by the moments_output command. The distribution type must be gaussian. This mode is incompatible with using closed orbit correction with start_from_centroid=1 (the default value). Po — Central momentum of the bunch."],
            "Po": ["Po", "RPNValue", 0, "Central momentum of the bunch."],
            "sigma_dp": ["Sigma DP", "RPNValue", 0, "Fractional momentum spread, δ, and bunch length. Note that sigma_s is actually the length in βz*c*t, so that for βz<<1 the length of the bunch in time will be greater than one might expect."],
            "sigma_s": ["Sigma S", "RPNValue", 0, ""],
            "dp_s_coupling": ["DP S Coupling", "RPNValue", 0, "Specifies the coupling between s and δ, defined as ⟨ s δ ⟩/(σsσδ)."],
            "emit_z": ["Emit Z", "RPNValue", 0, "Provide another way to specify the longitudinal phase space, either separately from or in combination with sigma_dp, sigma_s, and dp_s_coupling. Basically, which values elegant uses depends on what one sets to nonzero values. If one sets emit_z, then sigma_dp, sigma_s, and dp_s_coupling are ignored. If one doesn't set emit_z, then elegant uses sigma_dp and sigma_s; it additionally uses alpha_z if it is nonzero, otherwise it uses dp_s_coupling. For reference, the relationship between them is C = Σ₅₆ / √Σ₅₅Σ₆₆}} = -α / √1+α^2}. Note that to impart a chirp that results in compression for R₅₆<0 (e.g., a normal four-dipole chicane), one must have αz<0 or C>0."],
            "beta_z": ["Beta Z", "RPNValue", 0, ""],
            "alpha_z": ["Alpha Z", "RPNValue", 0, ""],
            "momentum_chirp": ["Momentum Chirp", "RPNValue", 0, "Permits imparting an additional momentum chirp to the beam, in units of 1/m. E.g., a value of 1 indicates that a 1mm long bunch has a linear variation in momentum of 0.1% from end-to-end. A positive chirp is needed to provide compression of a bunch with an ordinary R₅₆<0 four-dipole chicane."],
            "one_random_bunch": ["One Random Bunch", "RPNBoolean", "1", "If non-zero, then only one random particle distribution is generated. Otherwise, a new distribution will be generated for every simulation step."],
            "symmetrize": ["Symmetrize", "RPNBoolean", "0", "If non-zero, the distribution is symmetric under changes of sign in the coordinates. Automatically results in a zero centroid for all coordinates."],
            "halton_sequence": ["Halton Sequence", "BooleanStringArray", "0, 0, 0", "This provides a \"quiet-start\" feature by choosing Halton sequences in place of random number generation. There are three new variables that control this feature. halton_sequence is an array of three flags that permit turning on Halton sequence generation for the horizontal, vertical, or longitudinal planes. For example, halton_sequence[0] = 3*1 will turn on Halton sequences for all three planes, while halton_sequence[2] = 1, will turn it on for the longitudinal plane only.", "X, Y, Z"],
            "halton_radix": ["Halton Radix", "Integer6StringArray", "0, 0, 0, 0, 0, 0", "halton_radix is an array of six integers that permit giving the radix for each sequence (i.e., x, x', y, y', t, p). Each radix must be a prime number. One should never use the same prime for two sequences, unless one randomizes the order of the sequences relative to each other (see the next item). If these are left at zero, then elegant chooses values that eliminate phase-space banding to some extent. The user is cautioned to plot all coordinate combinations for the initial phase space to ensure that no unacceptable banding is present. A suggested way to use Halton sequences is to set halton_radix[0] = 2, 3, 2, 3, 2, 3 and to set randomize_order[0] = 2, 2, 2,. This avoids banding that may result from choosing larger radix values.", "X, X', Y, Y', T, P"],
            "optimized_halton": ["Optimized Halton", "RPNBoolean", "0", "optimized_halton uses the improved halton sequence. (Algorithm 659, Collected Algorithm from ACM. Derandom Algorithm is added by Hongmei CHI (CS/FSU)). It avoids the banding problem automatically and the halton_radix values are ignored."],
            "randomize_order": ["Randomize Order", "RandomizeStringArray", "0, 0, 0", "Allows randomizing the order of assigned coordinates for the pairs (x, x'), (y, y'), and (t,p). 0 means no randomization; 1 means randomize (x, x', y, y', t, p) values independently, which destroys any x-x', y-y', and t-p correlations; 2 means randomize (x, x'), (y, y'), and (t, p) in pair-wise fashion. This is used with Halton sequences to remove banding. It is suggested that that the user employ sddsanalyzebeam to verify that the beam properties when randomization is used.", "X, Y, Z"],
            "limit_invariants": ["Limit Invariants", "Integer", 0, "If non-zero, the distribution cutoffs are applied to the invariants, rather than to the coordinates. This is useful for gaussian beams when the distribution cutoff is small."],
            "limit_in_4d": ["Limit In 4D", "RPNBoolean", "0", "If non-zero, then the transverse distribution is taken to be a 4-d gaussian or uniform distribution. One of these must be chosen using the distribution_type control. It must be the same for x and y. This is useful, for example, if you want to make a cylindrically symmetric beam."],
            "enforce_rms_values": ["Enforce RMS Values", "BooleanStringArray", "0, 0, 0", "Flags, one for each plane, indicating whether to force the distribution to have the specified RMS properties.", "X, Y, Z"],
            "distribution_cutoff": ["Distribution Cutoff", "Integer3StringArray", "2, 2, 2", "Distribution cutoff parameters for each plane. For gaussian distributions, this is the number of sigmas to use. For other distributions (except dynamic aperture), this number simply multiplies the sizes. This is potentially confusing and hence it is suggested that the distribution cutoff be set to 1 for nongaussian beams. The exception is \"dynamic-aperture\" distribution type. In this case, the cutoff value is the number of grid points in the dimension in question.", "X, Y, Z"],
            "distribution_type": ["Distribution Type", "DistributionTypeStringArray", "gaussian, gaussian, gaussian", "Distribution type for each plane. May be \"gaussian\", \"hard-edge\", \"uniform-ellipse\", \"shell\", \"dynamic-aperture\", \"line\", or \"halo(gaussian)\". For the transverse plane, the interpretation of the emittance is different for the different beam types. For gaussian beams, the emittances are rms values. For all other types, √ε*β times the distribution cutoff defines the edge of the beam in position space, while √ε*(1+α^2)/β times the distribution cutoff defines the edge of the beam in slope space. A hard-edge beam is a uniformly-filled parallelogram in phase space. A uniform-ellipse beam is a uniformly-filled ellipse in phase space. A shell beam is a hollow ellipse in phase space. A dynamic aperture beam has zero slope and uniform spacing in position coordinates. A line beam is a line in phase space. A \"halo(gaussian)\" beam is the part of the gaussian distribution beyond the distribution cutoff.", "X, Y, Z"],
            "centroid": ["Centroid", "Float6StringArray", "0, 0, 0, 0, 0, 0", "Centroid offsets for each of the six coordinates.", "X, X', Y, Y', T, P"],
            "first_is_fiducial": ["First Is Fiducial", "RPNBoolean", "0", "Specifies that the first beam generated shall be a single particle beam, which is suitable for fiducialization. See the section on \"Fiducialization in elegant\" for more discussion."],
            "save_initial_coordinates": ["Save Initial Coordinates", "RPNBoolean", "1", "A flag that, if set, results in saving initial coordinates of tracked particles in memory. This is the default behavior. If unset, the initial coordinates are not saved, but are regenerated each time they are needed. This is more memory efficient and is useful for tracking very large numbers of particles."]
        },
        "command_change_particle": {
            "name": ["Name", "ChangeParticleName", "electron", ""],
            "mass_ratio": ["Mass Ratio", "RPNValue", 0, "If the particle name is \"custom,\" these parameters specify the mass and charge of the particle relative to the electron. E.g., for an anti-proton, one would use a mass ratio of 1836.18 and a charge ratio of 1."],
            "charge_ratio": ["Charge Ratio", "RPNValue", 0, ""]
        },
        "command_change_start": {
            "element_name": ["Element Name", "OptionalString", "", "Name of the element where the lattice will start, which implies removing all elements upstream of the named element. If the element occurs more than once, the first instance is used. The named element will be the first element in the lattice."],
            "ring_mode": ["Ring Mode", "RPNBoolean", "0", "If nonzero, the ring structure of the lattice is preserved by moving the elements upstream of the named element to the end of the lattice."]
        },
        "command_chaos_map": {
            "output": ["Output", "OutputFile", "", "The (incomplete) name of an SDDS file to send output to. Recommended value: “%s.cmap”. For the parallel version, particles will be listed in essentially random order. If needed, sddssort can be used to sort particles by initial coordinates."],
            "xmin": ["Xmin", "RPNValue", -0.1, "Limits of grid of initial x coordinates for tracking."],
            "xmax": ["Xmax", "RPNValue", 0.1, ""],
            "ymin": ["Ymin", "RPNValue", 1e-6, "Limits of grid of initial y coordinates for tracking. ymin should be a small, positive value so that there is some betatron oscillation from which to get the tune."],
            "ymax": ["Ymax", "RPNValue", 0.1, ""],
            "delta_min": ["Delta Min", "RPNValue", 0, "Limits of grid of initial δ coordinates for tracking. Note that particles are not centered around the dispersive closed orbit. Hence, the tracking is appropriate to simulation of dynamics from a touschek scattering event."],
            "delta_max": ["Delta Max", "RPNValue", 0, ""],
            "nx": ["Nx", "Integer", 20, "Number of values of x coordinate in the grid."],
            "ny": ["Ny", "Integer", 21, "Number of values of y coordinate in the grid."],
            "ndelta": ["Ndelta", "Integer", 1, "Number of values of δ coordinate in the grid."],
            "forward_backward": ["Forward Backward", "RPNBoolean", "0", "If non-zero, uses the forward/backward integration technique of Y. Li et al. [56]. The number of passes tracked is still controlled by the n_passes parameter of run_control. In addition, the number of iterations of forward and backward tracking is given by the value of forward_backward. If zero, a less interesting technique is used that computes the change in Jx and Jy from tracking with small changes in initial conditions."],
            "change_x": ["Change X", "RPNValue", 1e-6, "If forward_backward is zero, gives the perturbation to initial x and y used to assess chaotic motion from divergence of trajectories."],
            "change_y": ["Change Y", "RPNValue", 1e-6, ""],
            "verbosity": ["Verbosity", "RPNBoolean", "1", "If nonzero, prints possibly useful information while running."]
        },
        "command_chromaticity": {
            "sextupoles": ["Sextupoles", "OptionalStringUpper", "", "List of names of elements to use to correct the chromaticities. Several names may be given and names may include wildcards. If so, then sextupoles in each group are changed by the same amount for each iteration. This would typically be used when the sextupoles are nominally identical (though perhaps differing in strength because of introduced errors). If that's not the case, the iteration may fail to converge."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "List of names of elements to exclude. This may be used to exclude some sextupoles that are matched by wildcards in the sextupole list."],
            "dnux_dp": ["Dnux DP", "RPNValue", 0, "Desired chromaticity values."],
            "dnuy_dp": ["Dnuy DP", "RPNValue", 0, ""],
            "sextupole_tweek": ["Sextupole Tweek", "RPNValue", 1e-3, "Amount by which to tweak the sextupoles to compute derivatives of chromaticities with respect to sextupole strength. [The word \"tweak\" is misspelled \"tweek\" in the code.]"],
            "correction_fraction": ["Correction Fraction", "RPNValue", 0.9, "Fraction of the correction to apply at each iteration. In some cases, correction is unstable at this number should be reduced."],
            "n_iterations": ["N Iterations", "Integer", 5, "Number of iterations of the correction to perform."],
            "tolerance": ["Tolerance", "RPNValue", 0, "Stop iterating when chromaticities are within this value of the desired values."],
            "strength_log": ["Strength Log", "OutputFile", "", "The name of an SDDS file to which the sextupole strengths will be written."],
            "change_defined_values": ["Change Defined Values", "Integer", 0, "Changes the defined values of the sextupole strengths. This means that when the lattice is saved (using save_lattice), the sextupoles will have the corrected values. This would be used for correcting the chromaticity of a design lattice, for example, but not for correcting chromaticity of a perturbed lattice."],
            "strength_limit": ["Strength Limit", "RPNValue", 0, "Limit on the absolute value of sextupole strength (K_2)."],
            "use_perturbed_matrix": ["Use Perturbed Matrix", "RPNBoolean", "0", "If nonzero, requests use of the perturbed correction matrix in performing correction. For difficult lattices with large errors, this may be necessary to obtain correction. In general, it is not necessary and only slows the simulation."],
            "exit_on_failure": ["Exit On Failure", "RPNBoolean", "0", "If nonzero, then failure to reach the desired chromaticities within the tolerance results in the program exiting."],
            "update_orbit": ["Update Orbit", "RPNBoolean", "0", "If non-zero, the orbit calculation is updated after each nth adjustment of the sextupoles."],
            "verbosity": ["Verbosity", "Integer", 1, "Increasing positive values result in increasing amounts of information printed during execution."],
            "dK2_weight": ["DK2 Weight", "RPNValue", 1, "Weighting factor that is used to minimize the mean-square changes in K_2 values in the event that there are more than two families."]
        },
        "command_closed_orbit": {
            "output": ["Output", "OutputFile", "", "The name of an SDDS file to which the closed orbits will be written."],
            "output_monitors_only": ["Output Monitors Only", "RPNBoolean", "0", "If non-zero, indicates that the closed orbit output should include only the data at the locations of the beam-position monitors."],
            "start_from_centroid": ["Start From Centroid", "RPNBoolean", "1", "A flag indicating whether to force the computation to start from the centroids of the beam distribution."],
            "start_from_dp_centroid": ["Start From DP Centroid", "RPNBoolean", "1", "A flag indicating whether to force the computation to use the momentum centroid of the beam for the closed orbit. This can allow computing the closed orbit for an off-momentum beam, then starting the beam on that orbit using the offset_by_orbit or center_on_orbit parameters of the track command. In contrast to the start_from_centroid, this command doesn't force the algorithm to start from the beam transverse centroids."],
            "closed_orbit_accuracy": ["Closed Orbit Accuracy", "RPNValue", 1e-12, "The desired accuracy of the closed orbit, in terms of the difference between the start and end coordinates, in meters."],
            "closed_orbit_iterations": ["Closed Orbit Iterations", "Integer", 10, "The number of iterations to take in finding the closed orbit."],
            "iteration_fraction": ["Iteration Fraction", "RPNValue", 1, "Fraction of computed change that is used each iteration. For lattices that are very nonlinear or close to unstable, a number less than 1 can be helpful. Otherwise, it only slows the simulation."],
            "fraction_multiplier": ["Fraction Multiplier", "RPNValue", 1.05, "Multiplier to apply to the iteration fraction if iteration is converging."],
            "multiplier_interval": ["Multiplier Interval", "RPNValue", 5, "Interval in number of iterations at which to adjust the interation fraction."],
            "fixed_length": ["Fixed Length", "RPNBoolean", "0", "A flag indicating whether to find a closed orbit with the same length as the design orbit by changing the momentum offset."],
            "start_from_recirc": ["Start From Recirc", "RPNBoolean", "0", "A flag indicating whether to compute the closed orbit from the recirculation (recirc) element in the beamline. In general, if one has a recirculation element, one should give this flag."],
            "verbosity": ["Verbosity", "Integer", 0, "A larger value results in more printouts during the computations."],
            "tracking_turns": ["Tracking Turns", "Integer", 0, "If non-zero, the number of turns to track for detemination of the closed orbit by averaging. This may be useful if the regular closed orbit algorithm complains about convergence issues."],
            "disable": ["Disable", "RPNBoolean", "0", "If non-zero, disables the command."]
        },
        "command_correct": {
            "mode": ["Mode", "CorrectMode", "trajectory", ""],
            "method": ["Method", "CorrectMethod", "global", ""],
            "trajectory_output": ["Trajectory Output", "OutputFile", "", "The name of an SDDS file to which the trajectories or orbits will be written."],
            "corrector_output": ["Corrector Output", "OutputFile", "", "The name of an SDDS file to which information about the final corrector strengths will be written."],
            "statistics": ["Statistics", "OutputFile", "", "The name of an SDDS file to which statistical information about the trajectories (or orbits) and corrector strengths will be written."],
            "bpm_output": ["BPM Output", "OutputFile", "", "The (incomplete) name of an SDDS file to which post-correction BPM errors will be written. The errors are the residual after correction, and include the effects of offsets (DX and DY), setpoints (XSETPOINT, YSETPOINT, and SETPOINT), and tilts (TILT)."],
            "corrector_tweek": ["Corrector Tweek", "StringArray", "1e-3, 1e-3", "The amount by which to change the correctors in order to compute correction coefficients for transport lines. [The word \"tweak\" is misspelled \"tweek\" in the code.] The default value, 1 mrad, may be too large for systems with small apertures. If you get an error message about \"tracking failed for test particle,\" try decreasing this value."],
            "corrector_limit": ["Corrector Limit", "StringArray", "0, 0", "The maximum strength allowed for a corrector."],
            "correction_fraction": ["Correction Fraction", "StringArray", "1, 1", "The fraction of the computed correction strength to actually use for any one iteration."],
            "correction_accuracy": ["Correction Accuracy", "StringArray", "1e-6, 1e-6", "The desired accuracy of the correction in terms of the RMS BPM values."],
            "do_correction": ["Do Correction", "StringArray", "1, 1", "Flags to allow disabling correction in one or both planes (if set to zero)."],
            "remove_smallest_SVs": ["Remove Smallest SVS", "StringArray", "0, 0", "These parameters control the elimination of singular vectors from the inverse response matrix, which can help deal with degeneracy in the correctors and reduce corrector strength. By default, the number of singular vectors is limited to the number of BPMs, which is a basic condition for stability; this can be defeated by setting auto_limit_SVs to 0 for the desired planes. Set remove_smallest_SVs to require removal of a given number of vectors with the smallest singular values; this is ignored if auto_limit_SVs is also requested and would remove more SVs. Set keep_largest_SVs to require keeping at most a given number of the largest SVs. Set minimum_SV_ratio to require removal of any vectors with singular values less than a given factor of the largest singular value."],
            "keep_largest_SVs": ["Keep Largest SVS", "StringArray", "0, 0", ""],
            "minimum_SV_ratio": ["Minimum SV Ratio", "StringArray", "0, 0", ""],
            "auto_limit_SVs": ["Auto Limit SVS", "StringArray", "1, 1", ""],
            "remove_pegged": ["Remove Pegged", "StringArray", "0, 0", "If nonzero, then for the plane in question pegged correctors will be removed from the correction matrix. This results in recomputation of the matrix, following which correction continues with the reduced set of correctors. The pegged corrector is left at its last value."],
            "threading_divisor": ["Threading Divisor", "StringArray", "100, 100", "In threading mode trajectory correction, each corrector is varied between 0 and ±θmax, where θmax is the strength limit. This parameter sets the number of steps to divide the corrector range into on the positive and negative sides. A smaller value results in faster execution but is less reliable."],
            "threading_correctors": ["Threading Correctors", "StringArray", "-1, -1", "In threading mode trajectory correction, gives the number of correctors upstream of the loss point to use for threading the beam further through the system."],
            "bpm_noise": ["BPM Noise", "StringArray", "0, 0", "The BPM noise level."],
            "bpm_noise_cutoff": ["BPM Noise Cutoff", "StringArray", "1.0, 1.0", "Cutoff values for the random distributions of BPM noise."],
            "bpm_noise_distribution": ["BPM Noise Distribution", "StringArray", "uniform, uniform", "May be either \"gaussian\", \"uniform\", or \"plus_or_minus\"."],
            "verbose": ["Verbose", "RPNBoolean", "1", "If non-zero, information about the correction is printed during computations."],
            "fixed_length": ["Fixed Length", "RPNBoolean", "0", "Indicates that the closed orbit length should be kept the same as the design orbit length by changing the momentum offset of the beam."],
            "fixed_length_matrix": ["Fixed Length Matrix", "RPNBoolean", "0", "Indicates that for fixed-length orbit correction, the fixed-length matrix should be computed and used. This will improve convergence but isn't always needed."],
            "n_xy_cycles": ["N XY Cycles", "Integer", 1, "Number of times to alternate between correcting the x and y planes."],
            "minimum_cycles": ["Minimum Cycles", "Integer", 1, "The minimum number of x-y cycles to perform, even if the correction does not improve."],
            "force_alternation": ["Force Alternation", "RPNBoolean", "0", "Forces alternation between x and y correction even if one plane appears to have converged"],
            "n_iterations": ["N Iterations", "Integer", 1, "Number of iterations of the correction in each plane for each x/y cycle."],
            "prezero_correctors": ["Prezero Correctors", "RPNBoolean", "1", "Flag indicating whether to set the correctors to zero before starting."],
            "track_before_and_after": ["Track Before And After", "RPNBoolean", "0", "Flag indicating whether tracking should be done both before and after correction."],
            "start_from_centroid": ["Start From Centroid", "RPNBoolean", "1", "Flag indicating that correction should start from the beam centroid. For orbit correction, only the beam momentum centroid is relevant."],
            "use_actual_beam": ["Use Actual Beam", "RPNBoolean", "0", "Flag indicating that correction should employ tracking of the beam distribution rather than a single particle. This is valid for trajectory correction only."],
            "closed_orbit_accuracy": ["Closed Orbit Accuracy", "RPNValue", 1e-12, "Accuracy of closed orbit computation."],
            "closed_orbit_iterations": ["Closed Orbit Iterations", "Integer", 10, "Number of iterations of closed orbit computation."],
            "closed_orbit_iteration_fraction": ["Closed Orbit Iteration Fraction", "RPNValue", 1, "Fraction of change in closed orbit to use at each iteration."],
            "closed_orbit_tracking_turns": ["Closed Orbit Tracking Turns", "RPNValue", 0, "If non-zero, the absolute value gives the number of turns to track for detemination of the closed orbit by averaging. This may be useful if the regular closed orbit algorithm complains about convergence issues. If less than zero, then only this method is used. If greater than zero, then regular orbit determination is tried first, and tracking is used as a fallback."],
            "use_perturbed_matrix": ["Use Perturbed Matrix", "RPNBoolean", "0", "If nonzero, specifies that prior to each correction elegant shall recompute the response matrix. This is useful if the lattice is changing significantly between corrections."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, the command is ignored."],
            "use_response_from_computed_orbits": ["Use Response From Computed Orbits", "RPNBoolean", "0", "If nonzero, in-plane response matrices are computed using differences of closed orbits, which is slower but may be more accurate. For cross-plane matrices, this is always the case."]
        },
        "command_correct_tunes": {
            "quadrupoles": ["Quadrupoles", "OptionalStringUpper", "", "List of names of quadrupoles to be used. Several names may be given and the names may include wildcards. If so, then quadrupoles in each group are changed by the same amount for each iteration. This would typically be used when the quadrupoles are nominally identical (though perhaps differing in strength because of introduced errors). If that's not the case, the iteration may fail to converge."],
            "tune_x": ["Tune X", "RPNValue", 0, "Desired x and y tune values. If not given, the desired values are assumed to be the unperturbed tunes."],
            "tune_y": ["Tune Y", "RPNValue", 0, ""],
            "n_iterations": ["N Iterations", "Integer", 5, "The number of iterations of the correction to perform."],
            "correction_fraction": ["Correction Fraction", "RPNValue", 0.9, "The fraction of the correction to apply at each iteration."],
            "tolerance": ["Tolerance", "RPNValue", 0, "When both tunes are within this value of the desired tunes, the iteration is stopped."],
            "step_up_interval": ["Step Up Interval", "Integer", 0, "Interval between increases in the correction fraction."],
            "max_correction_fraction": ["Max Correction Fraction", "RPNValue", 0.9, "Maximum correction fraction to allow."],
            "delta_correction_fraction": ["Delta Correction Fraction", "RPNValue", 0.1, "Change in correction fraction after each step_up_interval steps."],
            "strength_log": ["Strength Log", "OutputFile", "", "The name of a SDDS file to which the quadrupole strengths will be written as correction proceeds."],
            "change_defined_values": ["Change Defined Values", "Integer", 0, "Changes the defined values of the quadrupole strengths. This means that when the lattice is saved (using save_lattice), the quadrupoles will have the corrected values. This would be used for correcting the tunes of a design lattice, for example, but not for correcting tunes of a perturbed lattice."],
            "use_perturbed_matrix": ["Use Perturbed Matrix", "RPNBoolean", "0", "If nonzero, requests use of the perturbed correction matrix in performing correction. For difficult lattices with large errors, this may be necessary to obtain correction. In general, it is not necessary and only slows the simulation."],
            "dK1_weight": ["DK1 Weight", "RPNValue", 1, "Weighting factor that is used to minimize the mean-square changes in K_1 values in the event that there are more than two families."]
        },
        "command_correction_matrix_output": {
            "response": ["Response", "StringArray", ",,,", "Array of filenames for SDDS output of the x and y response matrices, plus the cross-plane response matrices. Recommended values, in order: \"%s.hrm\" (horizontal response to horizontal correctors), \"%s.vrm\" (vertical response to vertical correctors), \"%s.vhrm\" (vertical response to horizontal correctors), and \"%s.hvrm\" (horizontal response to vertical correctors)."],
            "inverse": ["Inverse", "StringArray", ",", "Array of filenames for SDDS output of the x and y inverse response matrices. Recommended values: \"%s.hirm\" and \"%s.virm\"."],
            "KnL_units": ["KNL Units", "RPNBoolean", "0", "Flag that, if set, indicates use of \"units\" of m/K0L rather than m/rad. This results in a sign change for the horizontal data."],
            "BnL_units": ["BNL Units", "RPNBoolean", "0", "Flag that, if set, indicates use of \"units\" of m/(T*m) rather than m/rad. This is useful for linac work in that the responses are automatically scaled with beam momentum."],
            "output_at_each_step": ["Output At Each Step", "RPNBoolean", "0", "Flag that, if set, specifies output of the data at each simulation step. By default, the data is output immediately for the defined lattice."],
            "output_before_tune_correction": ["Output Before Tune Correction", "RPNBoolean", "0", "Flag that, if set, specifies that when output_at_each_step is set, that output shall occur prior to correcting the tunes."],
            "fixed_length": ["Fixed Length", "RPNBoolean", "0", "Flag that, if set, specifies output of the fixed-path-length matrix."],
            "coupled": ["Coupled", "RPNBoolean", "0", "If nonzero, the cross-plane response matrices are computed."],
            "use_response_from_computed_orbits": ["Use Response From Computed Orbits", "RPNBoolean", "0", "If nonzero, in-plane response matrices are computed using differences of closed orbits, which is slower but may be more accurate. For cross-plane matrices, this is always the case."]
        },
        "command_coupled_twiss_output": {
            "filename": ["Filename", "OutputFile", "", "The name of the SDDS file to which coupled twiss parameters and beam sizes will be written. Suggested value: \"%s.ctwi\"."],
            "output_at_each_step": ["Output At Each Step", "RPNBoolean", "0", "If nonzero, then this is a setup command and results in computations occurring for each simulation step (e.g., for each perturbed machine if errors are included). If zero, then this is an action command and computations are done immediately (e.g., for the unperturbed machine). If you wish to compute Twiss parameters on a closed orbit or after other calculations, be sure to set this control to a nonzero value."],
            "emittances_from_twiss_command": ["Emittances From Twiss Command", "RPNBoolean", "1", "If nonzero, then the values of the horizontal emittance and the momentum spread are taken from the uncoupled computation done with the twiss_output command. In this case, the user must issue a twiss_output command prior to the coupled_twiss_output. If zero, then the values of the horizontal emittance and the momentum spread are taken from the parameters emit_x and sigma_dp, respectively. emit_x — Gives the horizontal emittance, if emittances_from_twiss_command=0."],
            "emit_x": ["Emit X", "RPNValue", 0, ""],
            "emittance_ratio": ["Emittance Ratio", "RPNValue", 0.01, "Gives the ratio of the x and y emittances. Used to determine the vertical emittance from the horizontal emittance. Note that the computation is not self-consistent. I.e., the user is free to enter any emittance ratio desired, whether it is consistent with the machine optics or now."],
            "sigma_dp": ["Sigma DP", "RPNValue", 0, "Gives the momentum spread, if emittances_from_twiss_command=0."],
            "calculate_3d_coupling": ["Calculate 3D Coupling", "RPNBoolean", "1", ""],
            "verbosity": ["Verbosity", "Integer", 0, ""],
            "concat_order": ["Concat Order", "Integer", 2, ""]
        },
        "command_divide_elements": {
            "name": ["Name", "OptionalStringUpper", "", "A possibly wildcard-containing string specifying the elements to which this specification applies."],
            "type": ["Type", "OptionalStringUpper", "", "A possibly wildcard-containing string specifying the element types to which this specification applies."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "A possibily wildcard-containing string specifying elements to be excluded from the specification."],
            "divisions": ["Divisions", "Integer", 0, "The number of times to subdivide the specified elements. If zero, then maximum_length should be nonzero."],
            "maximum_length": ["Maximum Length", "RPNValue", 0, "The maximum length of a slice. This is usually preferrable to specifying the number of divisions, particularly when the elements divided may be of different lengths. If zero, then divisions should be nonzero."],
            "clear": ["Clear", "RPNBoolean", "0", "If nonzero, all prior division specifications are deleted."]
        },
        "command_elastic_scattering": {
            "losses": ["Losses", "OutputFile", "", "The (incomplete) name of an SDDS file to which the record of initial scattering location, initial scattering angle, and loss coordinates will be written."],
            "output": ["Output", "OutputFile", "", "The (incomplete) name of an SDDS file to which the final coordinates of all surviving particles will be written."],
            "log_file": ["Log File", "OutputFile", "", "The (incomplete) name of an SDDS file to which statistical data will be written as the simulations run. Users should check the MinParticles and MaxParticles columns as the simulation runs to ensure reasonable load balance (e.g., within 10-20%). If balance is poor, consider changing the values of n_phi and n_theta slightly. The product of these values should not evenly divide the number of working cores (which is one less than the total number of cores)."],
            "theta_min": ["Theta Min", "RPNValue", 0.001, "Minimum polar scattering angle in radians. Should be small enough that no particle scattered by this angle are lost, regardless of the scattering location. See also twiss_scaling."],
            "theta_max": ["Theta Max", "RPNValue", 0.01, "Maximum polar scattering angle in radians. Should be large enough that no particle scattered by this angle survives, regardless of scattering location."],
            "n_theta": ["N Theta", "Integer", 11, "Number of polar scattering angle values on the range theta_min to theta_max."],
            "n_phi": ["N Phi", "Integer", 37, "Number of azimuthal scattering angles on the range [0,π]."],
            "twiss_scaling": ["Twiss Scaling", "RPNBoolean", "0", "If nonzero, then theta_min is scaled by √(βx(s)βy(s))∕(βx(0)βy(0)), where s is the location of the scattering location and s = 0 is the start of the lattice."],
            "s_start": ["S Start", "RPNValue", 0, "Range of s location for simulated scattering sites."],
            "s_end": ["S End", "RPNValue", 1.7976931348623158e+308, ""],
            "include_name_pattern": ["Include Name Pattern", "OptionalStringUpper", "", "Wildcard-containing string to match to element names in selecting scattering sites."],
            "include_type_pattern": ["Include Type Pattern", "OptionalStringUpper", "", "Wildcard-containing string to match to element types in selecting scattering sites."],
            "verbosity": ["Verbosity", "Integer", 1, "Higher values may result in more verbose informational output."]
        },
        "command_error_control": {
            "clear_error_settings": ["Clear Error Settings", "RPNBoolean", "1", "Clear all previous error settings."],
            "summarize_error_settings": ["Summarize Error Settings", "RPNBoolean", "0", "Summarize current error settings. If non-zero, then the command has no other function except showing a summary of the current error settings."],
            "no_errors_for_first_step": ["No Errors For First Step", "RPNBoolean", "0", "If non-zero, then there will be no errors for the first step. This can be useful for fiducialization of phase and momentum profiles."],
            "error_log": ["Error Log", "OutputFile", "", "The name of a SDDS file to which error values will be written."],
            "error_factor": ["Error Factor", "RPNValue", 1, "A value by which to multiply the error amplitudes in all error commands."]
        },
        "command_error_element": {
            "name": ["Name", "OptionalStringUpper", "", "The possibly wildcarded name of the elements for which errors are being specified."],
            "element_type": ["Element Type", "OptionalStringUpper", "", "An optional, possibly wildcarded string giving the type of elements to which the errors should be applied. E.g., element_type=*MON* would match all beam position monitors. If this item is given, then name may be left blank."],
            "item": ["Item", "OptionalStringUpper", "", "The parameter of the elements to which the error pertains."],
            "type": ["Type", "ErrorElementType", "gaussian", ""],
            "amplitude": ["Amplitude", "RPNValue", 0, "The amplitude of the errors."],
            "cutoff": ["Cutoff", "RPNValue", 3, "The cutoff for the gaussian random distribution in units of the amplitude. Ignored for other distribution types."],
            "bind": ["Bind", "Integer", 1, "These parameters control \"binding\" of errors among elements, which means assigning the same error contribution to several elements. This occurs if bind is nonzero, which it is by default! If bind is negative, then the sign of the error will alternate between successive elements. bind_number can be used to limit the number of elements bound together. In particular, if bind_number is positive, then a positive value of bind indicates that bind_number successive elements having the same name will have the same error value. Finally, by default, elegant only binds the errors of objects having the same name, even if they are assigned errors by the same error_element command (i.e., through a wildcard name). If bind_across_names is nonzero, then binding is done even for elements with different names."],
            "bind_number": ["Bind Number", "Integer", 0, ""],
            "bind_across_names": ["Bind Across Names", "RPNBoolean", "0", ""],
            "post_correction": ["Post Correction", "RPNBoolean", "0", "A flag indicating whether the errors should be added after orbit, tune, and chromaticity correction."],
            "fractional": ["Fractional", "RPNBoolean", "0", "A flag indicating whether the errors are fractional, in which case the amplitude refers to the amplitude of the fractional error."],
            "additive": ["Additive", "RPNBoolean", "1", "A flag indicating that the errors should be added to the prior value of the parameter. If zero, then the errors replace the prior value of the parameter."],
            "allow_missing_elements": ["Allow Missing Elements", "RPNBoolean", "0", "A flag indicating that execution may continue even if no matching elements are found."],
            "after": ["After", "OptionalStringUpper", "", "The name of an element. If given, the error is applied only to elements that follow the named element in the beamline."],
            "before": ["Before", "OptionalStringUpper", "", "The name of an element. If given, the error is applied only to elements that precede the named element in the beamline."],
            "sample_file": ["Sample File", "Input File", "", "If the error type is \"sampled\", then sample_file must contain the name of an SDDS containing the numerical column named by sample_file_column. The values in this column from the first page of the file are used for assigning error values. sample_mode may be one of \"random\", \"shuffle\", or \"sequentual\", with the following meanings: random — Values are drawn randomly from the list as needed, without regard to reuse of a given value. shuffle — Values are drawn from the list in a random order until all are used, then a new random order is created. This ensures that all values are used with equal probability. sequential — Values are used in the order given until all are used, repeatedly as needed starting from the beginning of the list."],
            "sample_file_column": ["Sample File Column", "OptionalString", "", ""],
            "sample_mode": ["Sample Mode", "ErrorElementSampleMode", "", ""]
        },
        "command_find_aperture": {
            "output": ["Output", "OutputFile", "", "The name of an SDDS file to send output to."],
            "search_output": ["Search Output", "OutputFile", "", "The name of an SDDS file for output of detailed information on each tracked particle (single-particle mode only)."],
            "boundary": ["Boundary", "OutputFile", "", "The name of an SDDS file for the boundary points of the aperture search."],
            "mode": ["Mode", "FindApertureMode", "many-particle", ""],
            "xmin": ["Xmin", "RPNValue", -0.1, "Region of the aperture search. The minimum values are relevant only for many- and single-particle modes."],
            "xmax": ["Xmax", "RPNValue", 0.1, ""],
            "xpmin": ["Xpmin", "RPNValue", 0, "Region of the aperture search, in slope coordinates. The minimum values are relevant only for many- and single-particle modes. Ignored unless xmin=xmax and ymin=ymax."],
            "xpmax": ["Xpmax", "RPNValue", 0, ""],
            "ymin": ["Ymin", "RPNValue", 0, ""],
            "ymax": ["Ymax", "RPNValue", 0.1, ""],
            "ypmin": ["Ypmin", "RPNValue", 0, ""],
            "ypmax": ["Ypmax", "RPNValue", 0, ""],
            "nx": ["NX", "Integer", 21, "For many- and single-particle modes, the number of x values to take in initial search. For line modes, this determines the initial x and y step sizes via Δ x = x(max)/n_x and Δ y = y(max)/n_x."],
            "ny": ["NY", "Integer", 11, "For many- and single-particle modes, the number of y values to take in search. Ignored for line modes."],
            "n_splits": ["N Splits", "Integer", 0, "If positive, the number of times to do interval splitting. Interval splitting refers to searching between the original grid points in order to refine the results. This is done only for single-particle and line modes."],
            "split_fraction": ["Split Fraction", "RPNValue", 0.5, "If interval splitting is done, how the interval is split."],
            "desired_resolution": ["Desired Resolution", "RPNValue", 0.01, "If interval splitting is done, fraction of xmax-xmin to which to resolve the aperture. Ignored for all but single-particle mode."],
            "assume_nonincreasing": ["Assume Nonincreasing", "RPNBoolean", "0", "If this variable is non-zero, the search assumes that the aperture at y+sign(y)*Δ y is no larger than that at y. This results in tracking of fewer particles but may give a pessimistic result. Used only for single- and multi-particle modes."],
            "verbosity": ["Verbosity", "Integer", 0, "A larger value results in more printouts during computations."],
            "offset_by_orbit": ["Offset By Orbit", "RPNBoolean", "0", "A flag indicating whether to offset the transverse beam coordinates by the closed orbit before tracking. The default value is zero for backward compatibility, but the recommended value is 1."],
            "n_lines": ["N Lines", "Integer", 11, "In \"n-lines\" mode, the number of lines to search."],
            "optimization_mode": ["Optimization Mode", "RPNBoolean", "0", "If non-zero, then find_aperture is a setup command and can be used with elegant's internal optimizer. The quantity DaArea is defined, giving the area of the dynamic aperture for use in the penalty function. This is available only for the line search modes."],
            "full_plane": ["Full Plane", "RPNBoolean", "0", "If non-zero, then the search covers both positive and negative y values. Only available in line-search modes."]
        },
        "command_floor_coordinates": {
            "filename": ["Filename", "OutputFile", "", "The name of an SDDS file to send output to."],
            "X0": ["X0", "RPNValue", 0, "Initial X, Z, and angle coordinate of the beamline."],
            "Z0": ["Z0", "RPNValue", 0, ""],
            "theta0": ["Theta0", "RPNValue", 0, ""],
            "include_vertices": ["Include Vertices", "RPNBoolean", "0", "Flag that, if set, specifies including in the output the coordinates of the vertices of bending magnets."],
            "vertices_only": ["Vertices Only", "RPNBoolean", "0", "Flag that, if set, specifies that output will contain only the coordinates of the vertices of bending magnets."],
            "magnet_centers": ["Magnet Centers", "RPNBoolean", "0", "Flag that, if set, specifies that output will contain the coordinates of the centers of all magnets. By default, the coordinates of the downstream end are given."],
            "store_vertices": ["Store Vertices", "RPNBoolean", "0", "Flag that, if set, results in storing the floor coordinates for dipole magnet vertex points. The coordinates are stored in variables with names of the form magnetName#occurrenceNumber-VP.property, where property is X, Y, Z, theta, phi, and psi."]
        },
        "command_frequency_map": {
            "output": ["Output", "OutputFile", "", "The name of an SDDS file to send output to."],
            "xmin": ["Xmin", "RPNValue", -0.1, "Limits of grid of initial x coordinates for tracking."],
            "xmax": ["Xmax", "RPNValue", 0.1, ""],
            "ymin": ["Ymin", "RPNValue", 1e-6, "Limits of grid of initial y coordinates for tracking. ymin should be a small, positive value so that there is some betatron oscillation from which to get the tune."],
            "ymax": ["Ymax", "RPNValue", 0.1, ""],
            "delta_min": ["Delta Min", "RPNValue", 0, "Limits of grid of initial δ coordinates for tracking. Note that particles are not centered around the dispersive closed orbit. Hence, the tracking is appropriate to simulation of dynamics from a touschek scattering event."],
            "delta_max": ["Delta Max", "RPNValue", 0, ""],
            "nx": ["NX", "Integer", 21, "Number of values of x coordinate in the grid."],
            "ny": ["NY", "Integer", 21, "Number of values of y coordinate in the grid."],
            "ndelta": ["Ndelta", "Integer", 1, "Number of values of δ coordinate in the grid."],
            "verbosity": ["Verbosity", "RPNBoolean", "1", "If nonzero, prints possibly useful information while running."],
            "include_changes": ["Include Changes", "RPNBoolean", "0", "If nonzero, then computes not only the tunes, but also the changes in the tunes. Use of this feature results in a doubling of the number of turns tracked."],
            "quadratic_spacing": ["Quadratic Spacing", "RPNBoolean", "0", "If non-zero, the spacing of points is quadratic rather than linear, thus emphasizing the higher amplitude regions."],
            "full_grid_output": ["Full Grid Output", "RPNBoolean", "0", "If non-zero, all grid points are represented in the output file, even if tracking or tune determination failed. This makes it possible to plot with programs (e.g., sddscontour) that require a strictly uniform grid."]
        },
        "command_global_settings": {
            "inhibit_fsync": ["Inhibit FSYNC", "RPNBoolean", "0", "By default, elegant forces file synchronization across a network file system to ensure that users see up-to-date files as soon as possible. In cases where a great deal of output is generated, this can degrade performance. Setting this parameter to 1 will turn off synchronization until the end of the run."],
            "echo_namelists": ["Echo Namelists", "RPNBoolean", "1", "By default, elegant echoes all namelist input to the terminal. If this parameter is set to 0, this output will be inhibited."],
            "SR_gaussian_limit": ["SR Gaussian Limit", "RPNValue", 3, "By default, elegant uses a 3-σ cutoff for the gaussian random numbers used in simulation of synchrotron radiation from CSBEND, CSRCSBEND, KQUAD, KSEXT, and SREFFECTS. This parameter allows changing the cutoff."],
            "inhibit_seed_permutation": ["Inhibit Seed Permutation", "RPNBoolean", "0", "If nonzero, randomization of the user-supplied random number seed is not performed. This feature is useful in that it provides a higher degree of apparent randomness, in that small changes in the seed result in very different random sequences."],
            "log_file": ["Log File", "OutputFile", "", "By default, elegant writes status information to the terminal. If a filename is supplied for this parameter, the output will instead go to the file. On Linux and Unix, using /dev/null will result in the output being discarded."],
            "error_log_file": ["Error Log File", "OutputFile", "", "By default, elegant writes error messages to the terminal. If a filename is supplied for this parameter, the output will instead go to the file. On Linux and Unix, using /dev/null will result in the output being discarded."],
            "mpi_randomization_mode": ["Mpi Randomization Mode", "Integer", 1, "Controls how the random numbers are seeded on multiple processors ( •[1] — This is the original default, which showed issues in some simulations. The seed on the ith processor is s_0+2*i. •[2] — The seed on the ith processor is s_0+2*i^2. •[3] — This is the new default. The seed on the ith processor is s_0+i*(i+1). •[4] — The seed on the ith processor is s_0+R_i, where R_i is the ith random integer returned by the system rand() function. )"],
            "exact_normalized_emittance": ["Exact Normalized Emittance", "RPNBoolean", "0", "By default, elegant uses an approximate computation for the normalized emittance, namely, εn = ε⟨βγ⟩, where ε is the geometric emittance computed from the trace-space coordinates. If this variable is set to a non-zero value, elegant instead uses a slower but more accurate method, namely, using the momentum coordinates.. The results will show up in the sigma and final output files, if these are requested in the run_setup command."],
            "parallel_tracking_based_matrices": ["Parallel Tracking Based Matrices", "RPNBoolean", "1", "If non-zero, then the matrices determined by tracking for various elements (e.g., BRAT, BGGEXP, CCBEND) are computed using parallel resources in Pelegant. This can save considerable wall clock time. N.B.: This is set to zero when using parallel_optimization_setup."],
            "share_tracking_based_matrices": ["Share Tracking Based Matrices", "RPNBoolean", "1", "If non-zero, then the matrices determined by tracking for various elements (e.g., BRAT, BGGEXP, CCBEND) are computed only once for a set of identical elements, then shared."],
            "tracking_matrix_step_factor": ["Tracking Matrix Step Factor", "RPNValue", 1, "The default step size for tracking-based matrices is 5 × 10-5 (in the appropriate units for each corodinate). This can be increased or decreased by supplying a value for tracking_matrix_step_factor."],
            "tracking_matrix_points": ["Tracking Matrix Points", "RPNValue", 9, "By default, five grid points are used in each dimension for tracking-based matrix determination. This can be increased by setting tracking_matrix_points to a larger, odd value, at the expense of longer running time. (The run time scales approximately as the sixth power of this value.)"],
            "tracking_matrix_step_size": ["Tracking Matrix Step Size", "Float6StringArray", "5e-5, 5e-5, 5e-5, 5e-5, 5e-5, 5e-5", "Sets the step sizes, in each of the six coordinates, used for tracking-based matrix determination"]
        },
        "command_ignore_elements": {
            "name": ["Name", "OptionalStringUpper", "", "Possibily wild-card containing string specifying the elements to which the operation is to be applied."],
            "type": ["Type", "OptionalStringUpper", "", "Possibily wild-card containing string specifying the element types to which the operation is to be applied."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "Possibily wild-card containing string specifying elements to be excluded from the operation. Does not affect elements included by other specifications."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, the command is ignored."],
            "clear": ["Clear", "RPNBoolean", "0", "If nonzero, all prior specifications are deleted."],
            "completely": ["Completely", "RPNBoolean", "0", "If nonzero, the element is ignore not only for tracking, but for all purposes. (This allows, for example, requesting sigma and centroid output from run_setup.)"]
        },
        "command_inelastic_scattering": {
            "losses": ["Losses", "OutputFile", "", "The (incomplete) name of an SDDS file to which the record of initial scattering location, initial scattering δ, and loss coordinates will be written."],
            "output": ["Output", "OutputFile", "", "The (incomplete) name of an SDDS file to which the final coordinates of all surviving particles will be written."],
            "log_file": ["Log File", "OutputFile", "", "The (incomplete) name of an SDDS file to which statistical data will be written as the simulations run. Users should check the MinParticles and MaxParticles columns as the simulation runs to ensure reasonable load balance (e.g., within 10-20%). If balance is poor, consider changing the value of n_delta slightly."],
            "k_min": ["K Min", "RPNValue", 0.001, "Minimum energy k of the brehmsstrahlung photon as a fraction of the beam energy. The electron has δ = -k after scattering. k_min should be small enough that no electron scattered by -k_min is lost, regardless of the scattering location."],
            "momentum_aperture": ["Momentum Aperture", "InputFile", "", "If given, names a file giving the momentum aperture vs s, which is interpolated at the scattering locations to obtain the local momentum aperture. Such a file may be obtained from running the momentum_aperture command. The absolute values of the values in the deltaNegative column will be used in place of k_min. The k_min values thus obtained are multiplied by momentum_aperture_scale, so there is some assurance that the minimally-scattered particles will survive. This ensures that the results are valid for computation of loss rates, for example."],
            "momentum_aperture_scale": ["Momentum Aperture Scale", "RPNValue", 0.95, ""],
            "momentum_aperture_periodicity": ["Momentum Aperture Periodicity", "RPNValue", 0, ""],
            "n_k": ["N K", "Integer", 101, "Number of scattering values on the range k_min to k_max."],
            "s_start": ["S Start", "RPNValue", 0, "Range of s location for simulated scattering sites."],
            "s_end": ["S End", "RPNValue", 1.7976931348623158e+308, ""],
            "include_name_pattern": ["Include Name Pattern", "OptionalStringUpper", "", "Wildcard-containing string to match to element names in selecting scattering sites."],
            "include_type_pattern": ["Include Type Pattern", "OptionalStringUpper", "", "Wildcard-containing string to match to element types in selecting scattering sites."],
            "verbosity": ["Verbosity", "Integer", 1, "Higher values may result in more verbose informational output."],
            "soft_failure": ["Soft Failure", "RPNBoolean", "0", "If nonzero, failure to kind a loss does not result in aborting the run."],
            "allow_watch_file_output": ["Allow Watch File Output", "RPNBoolean", "0", "If nonzero, WATCH elements provide output during tracking."]
        },
        "command_insert_elements": {
            "name": ["Name", "OptionalStringUpper", "", "Possibly wild-card containing string specifying the names of the elements after which the new element is inserted. A list of comma- or space-separated names may be given."],
            "type": ["Type", "OptionalStringUpper", "", "Possibly wild-card containing string specifying the type of the elements after which the new element is inserted."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "Possibly wild-card containing string specifying the names of elements to be excluded from the specification."],
            "s_start": ["S Start", "RPNValue", -1, "If positive, these give the starting and ending s locations for insertion of new elements. Note that the s locations are not updated as elements are inserted, but only after completion of all insertions covered by a single command."],
            "s_end": ["S End", "RPNValue", -1, ""],
            "skip": ["Skip", "Integer", 1, "New elements are inserted at every nth specified location."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, the command is ignored."],
            "insert_before": ["Insert Before", "RPNBoolean", "0", "If nonzero, the insertions are before the selected elements. By default, insertion is after the selected elements."],
            "add_at_end": ["Add At End", "RPNBoolean", "0", "If nonzero, the element is also inserted to the end of the beamline."],
            "add_at_start": ["Add At Start", "RPNBoolean", "0", "If nonzero, the element is also inserted to the start of the beamline, ahead of all other elements."],
            "element_def": ["Element Def", "OptionalString", "", "The definition of the new element should be just as it would be entered in the lattice file."],
            "total_occurrences": ["Total Occurrences", "Integer", 0, "These parameters are used to insert the new elements after specified occurrences of the element name. total_occurrences specifies how many new elements to add, up to a maximum of 100, while the entries in the array occurrence specify the occurrences after which to add the new elements. If total_occurrences is non-zero, then skip must be set to zero and the name must be the exact name (no wild-card matching)."],
            "occurrence": ["Occurrence", "StringArray", "0", ""]
        },
        "command_insert_sceffects": {
            "name": ["Name", "OptionalStringUpper", "", "Possibily wild-card containing string specifying the name of the elements after which to insert the space charge kick element."],
            "type": ["Type", "OptionalStringUpper", "", "Possibily wild-card containing string specifying the type of the elements after which to insert the space charge kick element."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "Possibily wild-card containing string specifying the name of elements to be excluded from the insertion of the space charge kick element."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, the command is ignored."],
            "clear": ["Clear", "RPNBoolean", "0", "If nonzero, all prior space charge insertions are deleted."],
            "element_prefix": ["Element Prefix", "OptionalString", "MYSC", "Name under which the space charge kick will appear in the beamline."],
            "skip": ["Skip", "RPNBoolean", "0", "If nonzero, the given number of insertion locations are skipped. If zero, only one space charge kick is inserted at the end of beamline."],
            "vertical": ["Vertical", "RPNBoolean", "0", "If non-zero, then space charge is included in the plane in question."],
            "horizontal": ["Horizontal", "RPNBoolean", "0", ""],
            "nonlinear": ["Nonlinear", "RPNBoolean", "0", ""],
            "uniform_distribution": ["Uniform Distribution", "Integer", 0, "Used for bi-Gaussian distributed beam (coasting beam), i.e., beam that is uniform in z but gaussian in x and y."],
            "verbosity": ["Verbosity", "Integer", 0, "Larger non-zero values request greater amounts of detail in printouts."],
            "averaging_factor": ["Averaging Factor", "RPNValue", 1, "For nonlinear space charge mode only, this parameter allows applying an infinite-impulse-response (IIR) filter to the turn-by-turn beam size data in order to reduce the effects of noise. A value of 1 means that only data from the present turn is used, while values approaching 0 will tend to use the initial beam sizes only."]
        },
        "command_ion_effects": {
            "pressure_profile": ["Pressure Profile", "InputFile", "", "Name of an SDDS file giving the s-dependent gas pressure for various gas species. Column names will be matched to the entries in the SourceName column of the ion_properties file."],
            "pressure_factor": ["Pressure Factor", "RPNValue", 1, "Factor by which to multiply the pressures given in the pressure_profile."],
            "ion_properties": ["Ion Properties", "InputFile", "", "Name of an SDDS file giving properties of ions. Column names are • IonName — String column giving the name of the ion. • Mass — Floating-point column giving the ion mass, in AMU. • ChargeState — Integer column giving the ion charge state (a positive integer). • SourceName — String column giving the name of the source gas for this ion. In a future release, the source may also be another type of ion, to allow for multiple ionization. • CrossSection — Floating-point column giving the cross section for producing the ion from the source, in Mb."],
            "beam_output": ["Beam Output", "OutputFile", "", "Possibly incomplete name of an SDDS file to which beam data will be written."],
            "beam_output_all_locations": ["Beam Output All Locations", "RPNBoolean", "0", "If nonzero, beam_output includes data at the location of all IONEFFECTS elements."],
            "ion_density_output": ["Ion Density Output", "OutputFile", "", "Possibly incomplete name of an SDDS file to which ion density data will be written."],
            "ion_output_all_locations": ["Ion Output All Locations", "RPNBoolean", "1", "If nonzero, ion_density_output includes data at the location of all IONEFFECTS elements."],
            "ion_species_output": ["Ion Species Output", "RPNBoolean", "0", ""],
            "ion_output_interval": ["Ion Output Interval", "Integer", 1, "The interval in bunches between output of ion data."],
            "field_calculation_method": ["Field Calculation Method", "IonEffectsFieldCalculationMethod", "", "By default, the fields are computed on the assumption that the beam and ion distributions are gaussian. This is a good assumption for the beam, but not highly accurate for the ions. More accurate, but slower, methods is sums of two or three gaussians, or sums of two or three lorentzians"],

            "distribution_fit_target": ["Distribution Fit Target", "RPNValue", 0.03, ""],
            "distribution_fit_tolerance": ["Distribution Fit Tolerance", "RPNValue", 1e-5, ""],
            "distribution_fit_evaluations": ["Distribution Fit Evaluations", "Integer", 300, ""],
            "distribution_fit_passes": ["Distribution Fit Passes", "Integer", 3, ""],
            "distribution_fit_restarts": ["Distribution Fit Restarts", "Integer", 10, ""],
            "hybrid_simplex_comparison_interval": ["Hybrid Simplex Comparison Interval", "Integer", -1, ""],
            "fit_residual_type": ["Fit Residual Type", "IonEffectsFitResidualType", "max-ad-plus-ad-charge", ""],
            "macro_ions": ["Macro Ions", "Integer", 0, "The number of macro ions to generate per bunch on each turn for which generation is done. The macro ion charge is adjusted according to the cross section and bunch charge. May be overriden by the MACRO_IONS parameter on individual IONEFFECTS elements."],
            "symmetrize": ["Symmetrize", "RPNBoolean", "0", "If nonzero, ions are emitted in symmetric pairs to ensure that the centroids don’t deviate from the electron beam centroids because of noise. Doubles the number of macro ions that are emitted. Intended primarily for testing purposes."],
            "generation_interval": ["Generation Interval", "Integer", 1, "The number of bunches between generation of ions. The macro ion charge is adjusted to account for this, so the effective ion charge after many turns is the same. May be overridden with the GENERATION_INTERVAL parameter on individual IONEFFECTS elements. The actual condition for generation of ions is such that the generating bunches vary on each turn. This can be used to effectively reduce macro_ions below 1, to prevent generation of too many macro ions."],
            "multiple_ionization_interval": ["Multiple Ionization Interval", "Integer", 100, "The number of bunches between multiple ionization calculations. The macro ion charge is adjusted to account for this, so the effective ion charge after many turns is the same."],
            "multiple_ionization_energy_peak": ["Multiple Ionization Energy Peak", "RPNValue", 20, "Specifies the distribution of the energy of multiply-ionized ions in terms of the peak (or centroid) of the distribution and its rms width, in eV."],
            "multiple_ionization_energy_rms": ["Multiple Ionization Energy RMS", "RPNValue", 10, ""],

            "ion_span": ["Ion Span", "Float2StringArray", "0, 0", "The transverse half-extent, in meters, of the region within which ions are modeled. Ions moving outside this region are considered lost. May be overriden by the X_SPAN and Y_SPAN parameters on individual IONEFFECTS elements."],
            "ion_bin_divisor": ["Ion Bin Divisor", "Float2StringArray", "10.0, 10.0", "For histogram fitting methods, the number of ion bins per rms parameter of the electron beam."],
            "ion_range_multiplier": ["Ion Range Multiplier", "Float2StringArray", "2.0, 2.0", "For histogram fitting methods, used to determine the full span of the ion binning region bins in units of the rms parameter of the ion distribution. The sign of the value determines which algorithm is used. For m < 0, the binning range is |m |σion. For m = 0, the full span of the ion distribution is included; this may result in a very large number of bins being used to cover a few outlying ions, and is not recommended. For m > 0, the code first finds the approximate range containing the central 80% of the ions, then multiplies by m to get the range used."],
            "ion_sigma_limit_multiplier": ["Ion Sigma Limit Multiplier", "Float2StringArray", "0, 0", "For histogram fitting methods, the minimum value for either of the ion sigmas (for bigaussian) or size parameters (for bilorentizan) in units of the bin size. Use to prevent one of the gaussians or lorentzians from being too delta-function-like."],
            "ion_histogram_max_bins": ["Ion Histogram Max Bins", "Integer", 1000, "Maximum number of ion bins for fitting methods. If this limit is reached, the span of the histograms will be reduced to ensure that the central portion is resolved. If the value is too large, the histograms may be noisy, which will make the fits unreliable. Also, a large value will result in reduced parallel efficiency, as processors must pass around more data."],
            "ion_histogram_min_per_bin": ["Ion Histogram Min Per Bin", "Integer", 5, "Minimum number of ions per bin (on average)."],
            "ion_histogram_output": ["Ion Histogram Output", "OutputFile", "", "Controls for the output of ion histograms when using histogram fitting methods. ion_histogram_output gives the (incomplete) filename. ion_histogram_output_s_start and ion_histogram_output_s_end give limits on the s coordinate of the IONEFFECTS element. ion_histogram_output_interval gives the interval in passes between output."],
            "ion_histogram_output_s_start": ["Ion Histogram Output S Start", "RPNValue", -1, ""],
            "ion_histogram_output_s_end": ["Ion Histogram Output S End", "RPNValue", -1, ""],
            "ion_histogram_output_interval": ["Ion Histogram Output Interval", "Integer", 1000, ""],
            "ion_histogram_min_output_bins": ["Ion Histogram Min Output Bins", "Integer", 200, ""],
            "disable_until_pass": ["Disable Until Pass", "Integer", 0, ""],
            "freeze_ions_until_pass": ["Freeze Ions Until Pass", "Integer", 0, ""],
            "freeze_electrons_until_pass": ["Freeze Electrons Until Pass", "Integer", 0, ""],
            "verbosity": ["Verbosity", "Integer", 0, "Larger values result in more output during running. Used for debugging only."]
        },
        "command_linear_chromatic_tracking_setup": {
            "nux": ["Nux", "StringArray", "-1, 0, 0, 0", "Provide the horizontal tune plus its first three chromatic derivatives, i.e., ∂ νx/∂δ, ∂^2 νx/∂δ^2, and ∂^3 νx/∂δ^3."],
            "betax": ["Betax", "StringArray", "1.0, 0", "Provide the horizontal beta function plus its chromatic derivative."],
            "alphax": ["Alphax", "StringArray", "0, 0", "Provide the horizontal alpha function plus its chromatic derivative."],
            "etax": ["Etax", "StringArray", "0, 0", "Provide the first- and second-order horizontal dispersion: ηx = ηx[0] + ηx[1]δ."],
            "etapx": ["Etapx", "StringArray", "0, 0", "Provide the first- and second-order horizontal dispersion slope."],
            "nuy": ["Nuy", "StringArray", "-1, 0, 0, 0", ""],
            "betay": ["Betay", "StringArray", "1.0, 0", ""],
            "alphay": ["Alphay", "StringArray", "0, 0", ""],
            "etay": ["Etay", "StringArray", "0, 0", ""],
            "etapy": ["Etapy", "StringArray", "0, 0", ""],
            "alphac": ["Alphac", "StringArray", "0, 0", "Provide the first and second-order momentum compaction. N.B: if you are tracking with an rf cavity, be sure that your lattice length equal to the actual circumference. See the example below."]
        },
        "command_link_control": {
            "clear_links": ["Clear Links", "RPNBoolean", "1", "Clear all previously set links."],
            "summarize_links": ["Summarize Links", "RPNBoolean", "0", "Summarize all current set links."],
            "verbosity": ["Verbosity", "Integer", 0, "A larger value results in more output during computations."]
        },
        "command_link_elements": {
            "target": ["Target", "OptionalStringUpper", "", "The name of the elements to be modified by the link. May contain wild-cards."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "Wildcard sequence to match to element names. If a match is found, the element is excluded from the link."],
            "item": ["Item", "OptionalStringUpper", "", "The parameter that will be modified."],
            "source": ["Source", "OptionalStringUpper", "", "The name of the elements to be linked to."],
            "source_from_target_edit": ["Source From Target Edit", "OptionalStringUpper", "", "If given and if source is not given, an editing command to create the name of the elements to be linked to from the name of the target. Uses the syntax of the editstring program."],
            "source_position": ["Source Position", "LinkElementsSourcePosition", "before", ""],
            "mode": ["Mode", "LinkElementsMode", "dynamic", ""],
            "equation": ["Equation", "OptionalString", "", "An rpn equation for the new item value in terms of the item values for the source. The prior value of the item is on the top of the stack. To refer to the source parameter values, use the name of the parameters. To refer to the initial source parameter values, append \"0\" to the parameter name. These names must appear in capital letters."],
            "minimum": ["Minimum", "RPNValue", "-1.79E308", "Minimum and maximum values that will be assigned to the target parameter."],
            "maximum": ["Maximum", "RPNValue", "1.79E308", ""],
            "exclude_self": ["Exclude Self", "RPNBoolean", "1", "If nonzero, self-links are blocked. It is not recommended to change this."]
        },
        "command_load_parameters": {
            "filename": ["Filename", "InputFile", "", ""],
            "include_name_pattern": ["Include Name Pattern", "OptionalStringUpper", "", "A comma- or space-separated list of wildcard patterns to be used in selecting, respectively, which elements to include and which to exclude from loading. To be used, data must match at least one inclusion pattern and no exclusion patterns."],
            "exclude_name_pattern": ["Exclude Name Pattern", "OptionalStringUpper", "", ""],
            "include_item_pattern": ["Include Item Pattern", "OptionalStringUpper", "", "A comma- or space-separated list of wildcard patterns to be used in selecting, respectively, which items (i.e., which element parameters) to include and which to exclude from loading. To be used, data must match at least one inclusion pattern and no exclusion patterns."],
            "exclude_item_pattern": ["Exclude Item Pattern", "OptionalStringUpper", "", ""],
            "include_type_pattern": ["Include Type Pattern", "OptionalStringUpper", "", "Wildcard patterns to be used in selecting, respectively, which element types (e.g., QUAD, DRIFT) to include and which to exclude from loading. To be used, data must match at least one inclusion pattern and no exclusion patterns."],
            "exclude_type_pattern": ["Exclude Type Pattern", "OptionalStringUpper", "", ""],
            "edit_name_command": ["Edit Name Command", "OptionalString", "", "A command using the syntax of the editstring program, allowing the strings in the ElementName column to be modified before values are assigned."],
            "change_defined_values": ["Change Defined Values", "RPNBoolean", "0", "Changes the defined values of the parameters. This means that when the lattice is saved (using save_lattice), the parameters will have the altered values. Also, if one wants to alter the values for all steps of the simulation, one must set this flag. Note that the ElementOccurence data is normally ignored if change_defined_values is nonzero. This is because there is only one definition of each element, even if it is used multiple times. This behavior can be altered with the next control."],
            "clear_settings": ["Clear Settings", "RPNBoolean", "0", "If set, clear all settings and files being used for loading parameters."],
            "allow_missing_elements": ["Allow Missing Elements", "RPNBoolean", "0", "If set, allow elements in the file that are not in the lattice. In this case, the nonapplicable data is simply ignored."],
            "allow_missing_parameters": ["Allow Missing Parameters", "RPNBoolean", "0", "If set, it is not an error if any element in the lattice lacks a parameter that exists in the file."],
            "allow_missing_files": ["Allow Missing Files", "RPNBoolean", "0", "If set, it is not an error if any listed file is missing."],
            "force_occurence_data": ["Force Occurence Data", "RPNBoolean", "0", "If set, then occurence data is used even in change_defined_values mode."],
            "verbose": ["Verbose", "Integer", 0, "If set, provide informational printouts about changes to parameters."],
            "skip_pages": ["Skip Pages", "Integer", 0, "Specify the number of pages of input to skip."],
            "use_first": ["Use First", "RPNBoolean", "0", "It is possible that the input file will contain multiple lines for any given parameter. In this case, elegant will by default process all lines. For example, if the lines give differential values, then all would be included. However, if the lines give absolute values, then the last one will overwrite the previous values; this flag allows overriding the behavior in this case to force elegant to use the first value. This can have speed advantages for cases where there are many identical occurences of the same element."]
        },
        "command_matrix_output": {
            "printout": ["Printout", "OutputFile", "", "The name of a file to which the matrix output will be printed (as text)."],
            "printout_order": ["Printout Order", "Integer", 1, "The order to which the matrix is printed."],
            "full_matrix_only": ["Full Matrix Only", "RPNBoolean", "0", "A flag indicating that only the matrix of the entire accelerator is to be output."],
            "print_element_data": ["Print Element Data", "RPNBoolean", "1", "A flag indicating whether the element data should be printed out."],
            "mathematica_full_matrix": ["Mathematic Full Matrix", "RPNBoolean", "0", "If non-zero, print the full linear matrix in a format that can read by Mathematica."],
            "mathematica_matrix_name": ["Mathematica Matrix Name", "String", "MFull", "The name of the Mathematica variable to which the linear matrix will be assigned."],
            "mathematica_matrix_file": ["Mathematica Matrix File", "OutputFile", "", "The name a file to which the Mathematica-format matrix will be written."],
            "SDDS_output": ["SDDS Output", "OutputFile", "", "The name of an SDDS file to which the matrix will be written."],
            "SDDS_output_order": ["SDDS Output Order", "Integer", 1, "The order to which the matrix is output in SDDS format."],
            "individual_matrices": ["Individual Matrices", "RPNBoolean", "0", "If non-zero, the matrices in the SDDS file are the individual on-trajectory matrices of the elements, rather than the concatenated matrix of the beamline."],
            "SDDS_output_match": ["SDDS Output Match", "OptionalStringUpper", "", "A wildcard string which element names must match in order for data to appear in the SDDS output file."],
            "output_at_each_step": ["Output At Each Step", "RPNBoolean", "0", "A flag indicating whether matrix output is desired at every simulation step."],
            "start_from": ["Start From", "OptionalStringUpper", "", "The optional name of the accelerator element from which to begin concatenation and output."],
            "start_from_occurence": ["Start From Occurrence", "Integer", 1, "If start_from is not NULL, the number of the occurrence of the named element from which to start."]
        },
        "command_modulate_elements": {
            "name": ["Name", "OptionalStringUpper", "", "A possibly-wildcard-containing string giving the names of the elements to modulate. If not specified, then one must specify type."],
            "item": ["Item", "OptionalStringUpper", "", "The name of the parameter to modulate."],
            "type": ["Type", "OptionalStringUpper", "", "A possibly-wildcard-containing string giving the names of element types to modulate. May be specified with name or by itself."],
            "expression": ["Expression", "OptionalString", "", "RPN expression for the modulation amplitude A. The value of the time is on top of the stack."],
            "filename": ["Filename", "InputFile", "", "Name of SDDS file from which to read modulation data, if expression is not used."],
            "time_column": ["Time Column", "OptionalString", "", "Name of column in filename giving time data for the modulation table."],
            "convert_pass_to_time": ["Convert Pass To Time", "RPNBoolean", "0", "By default, the mean arrival time of the beam is used to compute the time value for computing the modulation amplitude. If the arrival time vales are offset by CHANGE_T=1 on RFCA elements, this won’t work as desired. In that case, one can compute the time from the pass number and the position of the element within the lattice."],
            "amplitude_column": ["Amplitude Column", "OptionalString", "", "Name of column in filename giving amplitude data for the modulation. Together, time_column and amplitude_column define a function A(t)."],
            "refresh_matrix": ["Refresh Matrix", "RPNBoolean", "0", "Frequently there is a matrix associated with an element even if tracking through the element does not use the matrix. In this case, elegant doesn't normally update the matrix for the element as it modulates the element, since that may involve a significant time penalty. If this parameter is set to a non-zero value, the matrix will be updated. For elements that use a matrix for tracking, the matrix is always updated."],
            "differential": ["Differential", "Integer", 1, "Determine how the amplitude function A(t) is used to obtain the new value of the parameter. There are four cases ( • differential=1, multiplicative=0: v(t) = v_0 + A(t) (default). • differential=0, multiplicative=0: v(t) = A(t). • differential=1, multiplicative=1: v(t) = v_0 + v_0 A(t). • differential=0, multiplicative=1: v(t) = v_0 A(t). )"],
            "multiplicative": ["Multiplicative", "Integer", 0, ""],
            "start_occurence": ["Start Occurence", "RPNBoolean", "0", "If nonzero, these give the starting and ending occurrence numbers of elements that will be modulated. N.B.: if wildcards are used, occurrence number counting is for each set of identically-named elements separately, rather than for the sequence of matched elements."],
            "end_occurence": ["End Occurence", "Integer", 0, ""],
            "s_start": ["S Start", "RPNValue", -1, "If non-negative, these give the gaving and ending position limits for the end-of-element locations of elements to be modulated."],
            "s_end": ["S End", "RPNValue", -1, ""],
            "before": ["Before", "OptionalStringUpper", "", "The name of an element. If given, the modulation is applied only to elements that precede the named element in the beamline."],
            "after": ["After", "OptionalStringUpper", "", "The name of an element. If given, the modulation is applied only to elements that follow the named element in the beamline."],
            "verbose": ["Verbose", "RPNBoolean", "0", "If nonzero, information is printed to the standard output as changes are made. Use for debugging only, since otherwise it may slow the simulation."],
            "verbose_threshold": ["Verbose Threshold", "RPNValue", 0, "If nonzero, verbose information is printed only when the fractional change exceeds the given value."],
            "record": ["Record", "OptionalString", "", "Gives a possibly incomplete filename to which will be written a record of the values of the modulation."],
            "flush_record": ["Flush Record", "Integer", 1, "Gives the interval in steps at which to flush the record file. Higher values result in less frequent updates to the record, but may improve performance."]
        },
        "command_moments_output": {
            "filename": ["Filename", "OutputFile", "", "The name of a file to which the moments results will be written."],
            "output_at_each_step": ["Output At Each Step", "RPNBoolean", "0", "A flag indicating, if set, that computations and/or output is desired at each step of the simulation. If you wish to compute Twiss parameters on a closed orbit or after other calculations, be sure to set this control to a nonzero value."],
            "output_before_tune_correction": ["Output Before Tune Correction", "RPNBoolean", "0", "A flag indicating, if set, that output is desired both before and after tune correction."],
            "final_values_only": ["Final Values Only", "RPNBoolean", "0", "A flag indicating, if set, that only the final values of the Twiss parameters should be output, and not the parameters as a function of s."],
            "verbosity": ["Verbosity", "Integer", 0, "Larger numbers result in an increasing amount of informational output to the standard output stream."],
            "matched": ["Matched", "RPNBoolean", "1", "A flag indicating, if set, that the periodic or matched moments should be found."],
            "equilibrium": ["Equilibrium", "RPNBoolean", "1", "A flag indicating, if set, that the equilibrium moments should be found. If matched=1 and equilibrium=0, then the initial twiss parameters are computed from the periodic solution for the beamline."],
            "radiation": ["Radiation", "RPNBoolean", "1", "A flag indicating, if set, that synchrotron radiation effects should be included. N.B.: this flag is all that needs to be set if the lattice contains no kick elements. However, if the lattice contains CSBEND, CSRCSBEND, KQUAD, or KQUAD elements (or other elements with SYNCH_RAD and ISR parameters), then the SYNCH_RAD andISR must be set to 1 as well."],
            "n_slices": ["N Slices", "Integer", 10, "The number of slices into which to cut individual dipoles, quadrupoles, and sextuoples for computations. 10 has been found to work for all rings tested, but users are advised to ensure it is sufficient for their cases."],
            "slice_etilted": ["Slice Etilted", "Integer", 1, ""],
            "emit_x": ["Emit X", "RPNValue", 0, "If matched=0, then these specify the starting beam ellipses in all three planes. ) This command performs several functions. In the most basic form, it propagates beam moments, i.e., the 6x6 sigma matrix, from the beginning to the end of a transport line, including coupling from rotated elements or offset sextupoles. This can be performed with or without synchrotron radiation effects in dipoles, quadrupoles, and sextupoles. These computations include the evolution of the trajectory due to errors and (if included) synchrotron radiation. If desired, the command will instead compute the periodic beam moments. In this case, the user must include an appropriate rf cavity in the lattice in order to get valid results. (By \"appropriate rf cavity\" we mean that it must have the right voltage, frequency, and phase to support stored beam.) It is also suggested that the user compute the closed orbit using closed_orbit so that the computations are performed on the closed orbit. The results of moments computation may be subjected to optimization using values at marker elements. See the documentation for MARK for more details. Notes: ( • When using CSBEND, KQUAD, and KSEXT elements, one may find that the calculations of moments_output do not make sense. This is because, by default, synchrotron radiation is disabled on these elements. To resolve the issue, set ISR=1 and SYNCH_RAD=1 on CSBEND at a miminum. If a closed orbit is present, making the same setting on the KQUAD and KSEXT is also suggested. It is essential to do this if there is an rf frequency offset. • When bending magnets are tilted, elegant has problems computing the moments and closed orbit self-consistently when the bending radius is small. To address this, the n_slices parameter is set to 1 for tilted bending magnets when slice_etilted=0. This reduces the accuracy of the calculations. Users are strongly advised to check that this is acceptable."],
            "beta_x": ["Beta X", "RPNValue", 0, ""],
            "alpha_x": ["Alpha X", "RPNValue", 0, ""],
            "eta_x": ["Eta X", "RPNValue", 0, ""],
            "etap_x": ["Etap X", "RPNValue", 0, ""],
            "emit_y": ["Emit Y", "RPNValue", 0, ""],
            "beta_y": ["Beta Y", "RPNValue", 0, ""],
            "alpha_y": ["Alpha Y", "RPNValue", 0, ""],
            "eta_y": ["Eta Y", "RPNValue", 0, ""],
            "etap_y": ["Etap Y", "RPNValue", 0, ""],
            "emit_z": ["Emit Z", "RPNValue", 0, ""],
            "beta_z": ["Beta Z", "RPNValue", 0, ""],
            "alpha_z": ["Alpha Z", "RPNValue", 0, ""]
        },
        "command_momentum_aperture": {
            "output": ["Output", "OutputFile", "", "The name of a file to which the momentum aperture results will be written."],
            "x_initial": ["X Initial", "RPNValue", 0, "The initial x and y coordinate values for tracking. It is essential that y_initial be nonzero if one wants to see losses due to vertical resonances."],
            "y_initial": ["Y Initial", "RPNValue", 0, ""],
            "delta_negative_start": ["Delta Negative Start", "RPNValue", 0, "Starting values of scans in the negative and positive directions."],
            "delta_positive_start": ["Delta Positive Start", "RPNValue", 0, ""],
            "delta_negative_limit": ["Delta Negative Limit", "RPNValue", -0.10, "Limiting values of scans in the negative and positive directions."],
            "delta_positive_limit": ["Delta Positive Limit", "RPNValue", 0.10, ""],
            "delta_step_size": ["Delta Step Size", "RPNValue", 0.01, "Initial size of steps in δ. This should be fairly large in order to save time."],
            "steps_back": ["Steps Back", "Integer", 1, "Number of steps to back up after a particle is lost, relative to the last surviving δ, before continuing with a smaller step size. If this is set to zero, there is a risk of finding a too-large momentum aperture (a stable island)."],
            "splits": ["Splits", "Integer", 2, "Number of times to split the step size in order to refine the location of the maximum surviving momentum offsets. When a particle is lost, the algorithm steps back to a momentum offset where a particle survived, subdivides the step size, and continues searching."],
            "split_step_divisor": ["Split Step Divisor", "Integer", 10, "Factor by which to subdivide the step size for each split."],
            "skip_elements": ["Skip Elements", "Integer", 0, "Number of elements to skip before starting to compute momentum apertures."],
            "process_elements": ["Process Elements", "Integer", 2147483647, "Number of elements for which to compute momentum aperture."],
            "s_start": ["S Start", "RPNValue", 0, "Limiting s coordinates of the elements from which tracking will start. The default values will exclude no elements."],
            "s_end": ["S End", "RPNValue", 1.79e308, ""],
            "include_name_pattern": ["Include Name Pattern", "OptionalStringUpper", "", "If given, tracking will start only at the entrance to elements that match the given wildcard pattern."],
            "include_type_pattern": ["Include Type Pattern", "OptionalStringUpper", "", "If given, tracking will start only at the entrance to elements whose type matches the given wildcard pattern."],
            "fiducialize": ["Fiducialize", "RPNBoolean", "0", "If given, an initially on-energy particle is tracked before the momentum aperture search begins, in order to fiducialize the reference momentum. This is useful if there are synchrotron radiation losses or energy gain due to cavities in the system."],
            "verbosity": ["Verbosity", "Integer", 1, "Larger values result in more detailed printouts as calculations proceed. Mostly for debugging."],
            "soft_failure": ["Soft Failure", "RPNBoolean", "0", "Normally, if elegant fails to find the momentum aperture, it aborts. If soft_failure is non-zero, it instead assigns a momentum aperture equal to the search limit."],
            "output_mode": ["Output Mode", "Integer", 0, "Normally, elegant puts the values for positive and negative momentum aperture in different columns. Each element thus has a single row of data in the output file. If output_mode=1, elegant instead puts the values for positive and negative apertures in successive rows, with a reduced number of columns. This is mostly advantageous for the parallel version, since it allows using twice as many simultaneous processors. If output_mode=2, elegant tracks many more probe particles simultaneously, which is better for massively parallel systems. The number of particles tracked is the number of elements selected times the number of probe points between delta_negative_limit and delta_positive_limit."],
            "forbid_resonance_crossing": ["Forbid Resonance Crossing", "RPNBoolean", "0", "Normally, elegant allows the momentum aperture search to cross integer and half-integer resonances if no unstable particles are found. If this is undesirable, this flag can be set to 1."]
        },
        "command_obstruction_data": {
            "input": ["Input", "InputFile", "", "Name of SDDS file containing obstruction data. The file must contain two columns, Z and X, giving the global coordinates of points on the obstruction contour in the Y = 0 plane, in units of meters. The file may contain more than one page, with each page giving a closed contour for a separate obstruction."],
            "periods": ["Periods", "Integer", 1, "Obstructions represented by the provided data are to be repeated in a periodic fashion the number of times given. It is assumed that the system is a storage ring."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, then the command is ignored."],
            "y_spacing": ["Y Spacing", "RPNValue", 0, "If nonzero, then the input file is expected to have data for multiple vertical planes, instead of the default y = 0 midplane. The plane for each page is identified by the parameter Y in the input file."],
            "y_limit": ["Y Limit", "Float2StringArray", "-10, 10", "Allows specifying maximum limits on the vertical coordinate, beyond which particles are lost."]
        },
        "command_optimization_constraint": {
            "quantity": ["Quantity", "OptionalString", "", "The quantity to be constrained, given as the name of a quantity from among the optimization variables, optimization covariables, and the \"final\" parameters (see the entry for run_setup for the last of these). The optimization (co)variables are referred to as <element-name>.<parameter-name>, in all capital letters. Other quantities, such as Twiss parameters or anything else but what is listed just above, are not recognized. Expressions involving multiple quantities are not supported."],
            "lower": ["Lower", "RPNValue", 0, "The lower and upper limits allowed for the expression."],
            "upper": ["Upper", "RPNValue", 0, ""]
        },
        "command_optimization_covariable": {
            "name": ["Name", "OptionalStringUpper", "", "The name of the element."],
            "item": ["Item", "OptionalStringUpper", "", "The parameter of the element to be changed."],
            "equation": ["Equation", "OptionalString", "", "An rpn equation for the value of the parameter in terms of the values of any parameters of any optimization variable. These latter appear in the equation in the form <element-name>.<parameter-name>, in all capital letters. The original values of all variables and covariable may be accessed via names like <element-name>.<parameter-name>0."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, the covariable is ignored."]
        },
        "command_optimization_setup": {
            "equation": ["Equation", "OptionalString", "", "An rpn equation for the optimization function, expressed in terms of any parameters of any optimization variables, the \"final\" parameters of the beam (as recorded in the final output file available in the run_setup namelist), and selected quantities from Twiss parameter, tune shift with amplitude, closed orbit, beam moments, driving terms, and other computations."],
            "mode": ["Mode", "OptimizationSetupMode", "minimize", ""],
            "method": ["Method", "OptimizationSetupMethod", "simplex", ""],
            "tolerance": ["Tolerance", "RPNValue", -0.01, "The convergence criterion for the optimization, with a negative value indicating a fractional criterion."],
            "target": ["Target", "RPNValue", 0, "The value which, if reached, results in immediate termination of the optimization, whether it has converged or not."],
            "center_on_orbit": ["Center On Orbit", "RPNBoolean", "0", "A flag indicating whether to center the beam transverse coordinates on the closed orbit before tracking."],
            "center_momentum_also": ["Center Momentum Also", "RPNBoolean", "1", "A flag indicating whether to center the momentum coordinate also."],
            "soft_failure": ["Soft Failure", "RPNBoolean", "1", "A flag indicating, if set, that failure of an optimization pass should not result in termination of the optimization."],
            "n_passes": ["N Passes", "Integer", 2, "The number of optimization passes made to achieve convergence (\"simplex\" only). A pass ends (roughly) when the number of evaluations is completed or the function doesn't change within the tolerance. A new pass involves starting the optimization again using step sizes determined from the range of the simplex and the factor simplex_pass_factor."],
            "n_evaluations": ["N Evaluations", "Integer", 500, "The number of allowed evaluations of the optimization function. If simplex optimization is used, this is the number of allowed evaluations per pass."],
            "n_restarts": ["N Restarts", "Integer", 0, "The number of complete restarts of the optimization (simplex only). This is an additional loop around the n_passes loop. The difference is that a restart involves using the optimized result but the original step sizes. It is highly recommended that this feature be used if convergence problems are seen."],
            "matrix_order": ["Matrix Order", "Integer", 1, "Specifies the highest order of matrix elements that should be available for fitting. Elements up to third order are available for the terminal point of the beamline, and up to secod order for interior fit points. Names for first-, second-, and third-order elements are of the form Rij, Tijk, and Uijkl."],
            "log_file": ["Log File", "OutputFile", "", "A file to which progress reports will be written as optimization proceeds. For SDDS data, use the final output file from the run_setup namelist."],
            "term_log_file": ["Term Log File", "OutputFile", "", "This names a file to which the values of the optimization terms are written at the completion of optimization, which can be convenient when large numbers of terms are used. For example, by using sddssort one could find which terms are contributing most to the penalty value."],
            "output_sparsing_factor": ["Output Sparsing Factor", "Integer", 0, "If set to a value larger than 0, results in sparsing of output to the \"final\" file (see run_setup). This can make a significant difference in the optimization speed."],
            "balance_terms": ["Balance Terms", "RPNBoolean", "0", "If nonzero, then all terms of the optimization expression have their weights adjusted so they make equal contributions to the penalty function. This can help prevent optimization of a single term at the expense of others. It is performed only for the initial value of the optimization function."],
            "restart_worst_term_factor": ["Restart Worst Term Factor", "RPNValue", 1, "Often when there are convergence problems, it is because a few terms are causing difficulty. Convergence can often be obtained by increasing the weighting of these terms. If restart_worst_term_factor is positive, then elegant will multiply the weight of the restart_worst_terms largest terms by this factor at the beginning of a restart."],
            "restart_worst_terms": ["Restart Worst Terms", "Integer", 1, ""],
            "verbose": ["Verbose", "Integer", 1, ""],
            "simplex_divisor": ["Simplex Divisor", "RPNValue", 3, "The factor by which simplex step sizes are changed as the optimization algorithm searches for a valid initial simplex."],
            "simplex_pass_range_factor": ["Simplex Pass Range Factor", "RPNValue", 1, "When starting a new pass, the simplex optimizer takes the range over the previous simplex of each variable times this factor as the starting step size for that variable. This can be useful if the optimization brings the system close to an instability. In such a case, the simplex routine may have trouble constructing an initial simplex if the range of the variables is large. Setting this control to a value less than 1 may help."],
            "include_simplex_1d_scans": ["Include Simplex 1D Scans", "RPNBoolean", "1", "If nonzero, optimizer performs single-variable scans prior to starting simplex optimization. This is usually a good idea, but in some cases it will cause problems. For example, if your design is on the edge of being unstable, you may get some many errors from the initial steps that the single-variable optimizer can't continue. Disabling the single-variable scans will sometimes solve this."],
            "start_from_simplex_vertex1": ["Start From Simplex Vertex1", "RPNBoolean", "0", "If nonzero, optimizer uses the initial simplex vertex as the starting point for each new 1d scan. Otherwise, it uses the result of the previous scan."],
            "restart_random_numbers": ["Restart Random Numbers", "RPNBoolean", "0", "If nonzero, the random number generators used by elegant are reset for each evaluation of the optimization function. This is valuable if one is optimizing tracking results that involve random processes (e.g., ISR or scattering)."]
        },
        "command_optimization_term": {
            "term": ["Term", "OptionalString", "", "An rpn expression giving one term to be optimized. If more than one optimization_term command is given, then the terms are added. The advantage of using this command over giving an equation via optimization_setup is that elegant will report the value of each term as it performs the optimization (if a log_file is given to optimization_setup). This permits determination of which terms are causing problems for the optimization. Please see the entry for equation under optimization_setup for details on designing optimization terms."],
            "weight": ["Weight", "RPNValue", 1, "The weight to assign to this term. If zero, the term is ignored."],
            "field_string": ["Field String", "OptionalString", "", "These parameters are used to perform substitution of a series of values into the string given by term. This can be used to make an identical constraint at a number of instances of the same marker. For example, to constraint Cx to zero at instances 1, 3, 5, ..., 39, of marker M1, one could use ( &optimization_term term = \"M1#@.Cx sqr\", field_string = @, field_initial_value = 1, field_final_value = 39, field_interval = 2 &end )"],
            "field_initial_value": ["Field Initial Value", "Integer", 0, ""],
            "field_final_value": ["Field Final Value", "Integer", 0, ""],
            "field_interval": ["Field Interval", "Integer", 1, ""],
            "input_file": ["Input File", "InputFile", "", "If given, input_file is taken as the name of an SDDS file, which is expected to have a string column named by input_column. Each row of the column is taken as a separate optimization term."],
            "input_column": ["Input Column", "OptionalString", "", ""],
            "verbose": ["Verbose", "RPNBoolean", "0", "If nonzero, optimization terms are echoed to the terminal as they are created or read from the input file."]
        },
        "command_optimization_variable": {
            "name": ["Name", "OptionalStringUpper", "", "The name of the element."],
            "item": ["Item", "OptionalStringUpper", "", "The parameter of the element to be varied."],
            "lower_limit": ["Lower Limit", "RPNValue", 0, "The lower and upper limits allowed for the parameter. If these are equal, the range of the parameter is unlimited."],
            "upper_limit": ["Upper Limit", "RPNValue", 0, ""],
            "differential_limits": ["Differential Limits", "RPNBoolean", "0", "If nonzero, then the lower and upper limits are being given relative to the initial value, rather than in absolute terms."],
            "step_size": ["Step Size", "RPNValue", 1, "The initial step size (\"simplex\" optimization ) or the grid size in this dimension (\"grid\" or \"sample\" optimization)."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, the variable is ignored."],
            "force_inside": ["Force Inside", "RPNBoolean", "0", "If nonzero, the initial value is forced inside the allowed range defined by the lower_limit and upper_limit parameters."],
            "no_element": ["No Element", "Integer", 0, "Allows defining a variable that is not connected to a beamline element, and giving the initial value for the variable. The variable can them be used in other optimization-related commands, e.g., optimization_covariable."],
            "initial_value": ["Initial Value", "RPNValue", 0, ""]
        },
        "command_optimize": {
            "summarize_setup": ["Summarize Setup", "RPNBoolean", "0", "A flag indicating, if set, that a summary of the optimization parameters should be printed."]
        },
        "command_parallel_optimization_setup": {
            "method": ["Method", "ParallelOptimizationSetupMethod", "simplex", ""],
            "hybrid_simplex_tolerance": ["Hybrid Simplex Tolerance", "RPNValue", -0.01, "For the parallel “hybridsimplex” method, these set, respectively, the tolerance value for changes between full iterations (restarts). If the result does not improve by more than hybrid_simplex_tolerance after hybrid_simplex_tolerance_count iterations, the optimization terminates."],
            "hybrid_simplex_tolerance_count": ["Hybrid Simplex Tolerance Count", "RPNValue", 2, ""],
            "hybrid_simplex_comparison_interval": ["Hybrid Simplex Comparison Interval", "Integer", 0, ""],
            "random_factor": ["Random Factor", "RPNValue", 1, "The factor to scale the step size for both parallel swarm and genetic methods."],
            "n_iterations": ["N Iterations", "Integer", 10000, "The maximal number of generations/iterations for the parallel genetic and particle swarm optimization."],
            "max_no_change": ["Max No Change", "Integer", 10000, "The maximal number of generations in which no change in the best evaluation is allowed before the genetic method stops (genetic method only)."],
            "population_size": ["Population Size", "Integer", 100, "The number of individuals to be generated for each generation/iteration for the swarm and genetic method. For the hybridsimplex method, the number of individuals is equal to the number of processors used."],
            "population_log": ["Population Log", "OutputFile", "", "An SDDS file to which the best individual in a population can be written after each iteration as optimization proceeds."],
            "print_all_individuals": ["Print All Individuals", "RPNBoolean", "0", "If nonzero, all the strings in a population will be recorded in the population_log file. This is supported for the genetic method only."],
            "output_sparsing_factor": ["Output Sparsing Factor", "Integer", 1, "For genetic optimization, this is used to set the frequency of printing strings in the log file with the number of generations as the interval."],
            "crossover": ["Crossover", "OptionalString", "twopoint", "For genetic optimization, it allows the user to choose a crossover type from \"onepoint\", \"twopoint\" and \"uniform\". \"twopoint\" is the default crossover type. If the dimension is 2, it will be set to onepoint crossover."],
            "simplex_log": ["Simplex Log", "OutputFile", "", "For the parallel “hybridsimplex” method, rootname for files to which data from each simplex optimization will be written. Intended only for debugging as it will adversely impact performance."],
            "simplex_log_interval": ["Simplex Log Interval", "Integer", 1, "Interval at which simplex_log files will be updated."]
        },
        "command_print_dictionary": {
            "filename": ["Filename", "OutputFile", "", "The name of a file to which the dictionary will be written. By default, the output is in LaTeX format."],
            "SDDS_form": ["SDDS Form", "RPNBoolean", "0", "If non-zero, then the output is in SDDS format."]
        },
        "command_ramp_elements": {
            "name": ["Name", "OptionalStringUpper", "", "A possibly-wildcard-containing string giving the names of the elements to modulate. If not specified, then one must specify type."],
            "item": ["Item", "OptionalStringUpper", "", "The name of the parameter to modulate."],
            "type": ["Type", "OptionalStringUpper", "", "A possibly-wildcard-containing string giving the names of element types to modulate. May be specified with name or by itself."],
            "start_pass": ["Start Pass", "Integer", 0, "The starting and ending pass, i(start) and i(end) for the ramp. For passes less than start_pass, the ramp value is start_value. For passes greater than end_pass, the ramp value is end_value."],
            "end_pass": ["End Pass", "Integer", 4294967295, ""],
            "start_value": ["Start Value", "RPNValue", 0, "The end-point values S (start) and E (end) of the ramp."],
            "end_value": ["End Value", "RPNValue", 0, ""],
            "refresh_matrix": ["Refresh Matrix", "RPNBoolean", "0", "Frequently there is a matrix associated with an element even if tracking through the element does not use the matrix. In this case, elegant doesn’t normally update the matrix for the element as it modulates the element, since that may involve a significant time penalty. If this parameter is set to a non-zero value, the matrix will be updated. For elements that use a matrix for tracking, the matrix is always updated."],
            "differential": ["Differential", "Integer", 1, "Determine how the amplitude function A(t) is used to obtain the new value of the parameter. There are four cases ( • differential=1, multiplicative=0: v(t) = v_0 + R(i) (default). • differential=0, multiplicative=0: v(t) = R(i). • differential=1, multiplicative=1: v(t) = v_0 + v_0 R(i). • differential=0, multiplicative=1: v(t) = v_0 R(i). )"],
            "multiplicative": ["Multiplicative", "Integer", 0, ""],
            "start_occurence": ["Start Occurence", "RPNBoolean", "0", "If nonzero, these give the starting and ending occurrence numbers of elements that will be modulated. N.B.: if wildcards are used, occurrence number counting is for each set of identically-named elements separately, rather than for the sequence of matched elements."],
            "end_occurence": ["End Occurence", "Integer", 0, ""],
            "exponent": ["Exponent", "RPNValue", 1, "The exponent p for the variation of values between the start and end of the ramp. Note that i=0 on the first pass."],
            "s_start": ["S Start", "RPNValue", -1, "If non-negative, these give the gaving and ending position limits for the end-of-element locations of elements to be modulated."],
            "s_end": ["S End", "RPNValue", -1, ""],
            "before": ["Before", "OptionalStringUpper", "", "The name of an element. If given, the modulation is applied only to elements that precede the named element in the beamline."],
            "after": ["After", "OptionalStringUpper", "", "The name of an element. If given, the modulation is applied only to elements that follow the named element in the beamline."],
            "verbose": ["Verbose", "RPNBoolean", "0", "If nonzero, information is printed to the standard output as changes are made. Use for debugging only, since otherwise it may slow the simulation."],
            "record": ["Record", "OptionalString", "", "Gives a possibly incomplete filename to which will be written a record of the values of the ramp."]
        },
        "command_replace_elements": {
            "name": ["Name", "OptionalStringUpper", "", "Possibly wild-card containing string specifying the name of the elements to be removed or replaced."],
            "type": ["Type", "OptionalStringUpper", "", "Possibly wild-card containing string specifying the type of the elements to be removed or replaced."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "Possibly wild-card containing string specifying the name of elements to be excluded from this command."],
            "skip": ["Skip", "Integer", 1, "The element is removed or replaced at every nth specified location."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, the command is ignored."],
            "element_def": ["Element Def", "OptionalString", "", "If NULL, the specified elements are removed from the beamline. If not NULL, the specified elements are replaced with the new element defined here. The definition of the element should be just as it would be entered in the lattice file."],
            "total_occurrences": ["Total Occurrences", "Integer", 0, "These parameters are used to replace or delete specified occurrences of the element name. total_occurrences specifies how many elements to replace or delete up to a maximum of 100, while the entries in the array occurrence specify the occurrences to replace or delete. If total_occurrences is non-zero, then skip must be set to zero and the name must be the exact name (no wild-card matching)."],
            "occurrence": ["Occurrence", "StringArray", "0", ""]
        },
        "command_rf_setup": {
            "filename": ["Filename", "OutputFile", "", "Name of a file to which data related to the rf settings will be written."],
            "name": ["Name", "OptionalStringUpper", "", "A possibly-wildcard-containing string giving the names of the elements to set. If not given, all RFCA elements are selected."],
            "start_occurence": ["Start Occurence", "Integer", -1, "If nonzero, these give the starting and ending occurrence numbers of elements that will be set."],
            "end_occurence": ["End Occurence", "Integer", -1, ""],
            "s_start": ["S Start", "RPNValue", -1, "If non-negative, these give the gaving and ending position limits for the end-of-element locations of elements to be set."],
            "s_end": ["S End", "RPNValue", -1, ""],
            "set_for_each_step": ["Set For Each Step", "RPNBoolean", "0", "If nonzero, then the setup is repeated at each simulation step. In this case, one must also give output_at_each_step=1 for twiss_output."],
            "near_frequency": ["Near Frequency", "RPNValue", 0, "to the given frequency."],
            "harmonic": ["Harmonic", "Integer", -1, "If nonzero, then the rf frequency is set to the given harmonic of the revolution frequency."],
            "bucket_half_height": ["Bucket Half Height", "RPNValue", 0, "If nonzero, the voltage is computed so as to give the specified bucket half height. and q is the overvoltage factor, related to the rf voltage by q = V/U_0. (See Wiedemann, Vol. 1, 8.2.2.)"],
            "over_voltage": ["Over Voltage", "RPNValue", 0, "If nonzero, the voltage is set to the given factor relative to the energy loss per turn."],
            "total_voltage": ["Total Voltage", "RPNValue", 0, "If nonzero, the total rf voltage is set to the given value. The frequency and phase are computed for this voltage."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, command does nothing."],
            "output_only": ["Output Only", "RPNBoolean", "0", "If nonzero, command generates output file but does not change rf cavity settings."],
            "track_for_frequency": ["Track for Frequency", "RPNBoolean", "0", "If nonzero, particle tracking is used to determine the rf frequency. If zero, the ideal length of the lattice is used."]
        },
        "command_rpn_expression": {
            "expression": ["Expression", "OptionalString", "", "An rpn expression. This expression is executed immediately and can be used, for example, to read in rpn commands from a file or store values in rpn memories."]
        },
        "command_rpn_load": {
            "tag": ["Tag", "OptionalString", "", "Option string that will be pre-pended to the names of all the numerical columns in the file in order to create RPN variable names. E.g., if the input file was from the twiss_output command and tag = tw1 was given, then RPN variables tw1.betax, tw1.alphax, etc. would be used. N.B.: If the tag is blank, then nothing is appended to the names from the file. This can be dangerous since the names may conflict with the names of other variables!"],
            "filename": ["Filename", "InputFile", "", "The name of the SDDS file from which to read data. By default, data is taken from all columns from the last row of the last page of the file. This default behavior can be altered using one or more of the following parameters: ("],
            "match_column": ["Match Column", "OptionalString", "", "The name of a string column to use in selecting the row from which data will be taken."],
            "match_column_value": ["Match Column Value", "OptionalString", "", "The value that the column named by match_column must have to be selected from the file. By default, the last row with a matching value is used."],
            "matching_row_number": ["Matching Row Number", "Integer", -1, "If a nonnegative value is given, then the matching_row_number th matching row is selected (0 is the first row, 1 the second, etc). Otherwise, the last match row is used. Ignored if match_column is not given."],
            "match_parameter": ["Match Parameter", "OptionalString", "", "The name of a string parameter to use in selecting the page from which data will be taken."],
            "match_parameter_value": ["Match Parameter Value", "OptionalString", "", "The value that the parameter named by match_parameter must have to be selected from the file. By default, the last page with a matching value is used."],
            "use_row": ["Use Row", "Integer", -1, "If nonnegative, specifies the row number to use, starting at 0 for the first row. Ignored if match_column is given."],
            "use_page": ["Use Page", "Integer", -1, "If nonnegative, specifies the page number to use, starting at 1 for the first page. Takes precedence over match_parameter if both are given."],
            "load_parameters": ["Load Parameters", "RPNBoolean", "0", "If nonzero, specifies loading the SDDS parameter data rather than the column data."]
        },
        "command_run_control": {
            "n_steps": ["N Steps", "RPNValue", 1, "The number of separate repetitions of the action implied by the next action command. If random errors are defined, this is also the number of separate error ensembles."],
            "bunch_frequency": ["Bunch Frequency", "RPNValue", 0, "The frequency to use in calculating the time delay between repetitions."],
            "n_indices": ["N Indices", "Integer", 0, "The number of looping indices for which to expect definitions in subsequent vary_element commands. If nonzero, then n_steps is ignored."],
            "n_passes": ["N Passes", "Integer", 1, "The number of passes to make through the beamline per repetition."],
            "n_passes_fiducial": ["N Passes Fiducial", "Integer", 0, "The number of passes to make through the beamline per repetition for the fiducial beam. If non-positive, use n_passes. For ring tracking, should probably always be set to 1."],
            "reset_rf_for_each_step": ["Reset RF For Each Step", "RPNBoolean", "1", "If nonzero, the rf phases are established anew for each bunch tracked. Should be zero to simulate phase and timing jitter."],
            "first_is_fiducial": ["First Is Fiducial", "RPNBoolean", "0", "If nonzero, the first bunch seen is taken to establish the reference phases and momentum profile. If zero, each bunch is treated as a new fiducializing bunch."],
            "restrict_fiducialization": ["Restrict Fiducialization", "RPNBoolean", "0", "If nonzero, then momentum profile fiducialization occurs only after elements that are intended change the momentum, such as rf cavities. If zero, then each element is fiducialized to the average momentum of the beam. Active only if first_is_fiducial=1 and overrides the always_change_p0 setting in run_setup."]
        },
        "command_run_setup": {
            "lattice": ["Lattice", "ElegantLatticeList", "", "Name of the lattice definition file."],
            "use_beamline": ["Use Beamline", "LatticeBeamlineList", "", "Name of the beamline to use."],
            "output": ["Output", "OutputFile", "", "The name of an SDDS file into which final phase-space coordinates will be written."],
            "centroid": ["Centroid", "OutputFile", "", "The name of an SDDS file into which beam centroids as a function of s will be written."],
            "sigma": ["Sigma", "OutputFile", "", "The name of an SDDS file into which the beam sigma matrix as a function of z will be written."],
            "final": ["Final", "OutputFile", "", "The name of an SDDS file into which final beam and transport parameters will be written."],
            "acceptance": ["Acceptance", "OutputFile", "", "The name of an SDDS file into which the initial coordinates of transmitted particles will be written."],
            "losses": ["Losses", "OutputFile", "", "The name of an SDDS file into which information on lost particles will be written."],
            "losses_include_global_coordinates": ["Losses Include Global Coordinates", "RPNBoolean", "0", "If nonzero, the losses output file includes the global coordinates of lost particles."],
            "magnets": ["Magnets", "OutputFile", "", "The name of an SDDS file into which a magnet layout representation will be written."],
            "parameters": ["Parameters", "OutputFile", "", "The name of an SDDS file into which parameters of accelerator elements are written. N.B.: this file does not contain any non-numerical parameters of the lattice. Hence, it is not a complete description of the settings of the lattice."],
            "rfc_reference_output": ["Rfc Reference Output", "OutputFile", "", "The (incomplete) name of an SDDS file into which the internally-determined reference times for RFCA and RFCW elements are written. This file can be loaded with load_parameters to exactly reproduce cavity phasing, e.g., for backtracking."],
            "combine_bunch_statistics": ["Combine Bunch Statistics", "RPNBoolean", "0", "A flag indicating whether to combine statistical information for all simulation steps. If non-zero, then the sigma and centroid data will be combined over all simulation steps."],
            "wrap_around": ["Wrap Around", "RPNBoolean", "1", "A flag indicating whether the s coordinate should wrap-around or increase monotonically in multipass simulations. If zero, then the centroid and sigma data is computed for each turn with the s coordinate increasing continuously."],
            "final_pass": ["Final Pass", "RPNBoolean", "0", "A flag indicating whether the centroid and sigma output should be computed only from the data from the final pass. By default, the statistics include data from all passes."],
            "default_order": ["Default Order", "Integer", 2, "The default order of transfer matrices used for elements having matrices."],
            "concat_order": ["Concat Order", "Integer", 0, "If non-zero, the order of matrix concatenation used."],
            "print_statistics": ["Print Statistics", "RPNBoolean", "0", "A flag indicating whether to print information as each element is tracked. If greater than 0, information is printed after each element from the beginning of tracking. If equal to n with n<0, information is printed only after pass |n|."],
            "show_element_timing": ["Show Element Timing", "RPNBoolean", "0", "A flag indicating whether to collect and report execution time statistics binned by element type."],
            "monitor_memory_usage": ["Monitor Memory Usage", "RPNBoolean", "0", "A flag indicating whether to monitor memory usage during tracking to detect memory leaks."],
            "random_number_seed": ["Random Number Seed", "Integer", 987654321, "A seed for the random number generators. If zero, a seed will be generated from the system clock."],
            "correction_iterations": ["Correction Iterations", "Integer", 1, "Number of iterations of tune and chromaticity correction."],
            "p_central": ["P Central", "RPNValue", 0, "Central momentum of the beamline, about which expansions are done. This is βγ."],
            "p_central_mev": ["P Central Mev", "RPNValue", 0, "Central momentum of the beamline in MeV/c, about which expansions are done. Ignored if p_central is nonzero."],
            "always_change_p0": ["Always Change P0", "RPNBoolean", "0", "If nonzero, then elegant will match the reference momentum to the beam momentum after each element. For example, in a beamline with radiation losses, one might want to adjust downstream magnets to match the energy of the incoming beam."],
            "expand_for": ["Expand For", "InputFile", "", "Name of an SDDS file containing particle information, from which the central momentum will be set. The file contents are the same as required for elegant input with the sdds_beam namelist."],
            "tracking_updates": ["Tracking Updates", "RPNBoolean", "1", "A flag indicating whether to print summary information about tracking."],
            "echo_lattice": ["Echo Lattice", "RPNBoolean", "0", "If nonzero, the lattice input is echoed to the standard output as the lattice is parsed. This can help detect certain problems with the lattice that cause elegant to crash."],
            "element_divisions": ["Element Divisions", "Integer", 0, "Specify how many pieces to split elements into. Only certain elements (basically, those with a matrix) are split. Results in creation of element_divisions new elements having the same name as each split element."],
            "load_balancing_on": ["Load Balancing On", "Integer", 0, "If 1, load-balancing is performed for parallel mode. This can result in non-deterministic results if the load-balancing is different on two otherwise identical runs. Load-balancing variations may occur in heterogeneous clusters, clusters with multiple users, or for other reasons. In such situations, turning off load balancing can be useful if, for example, one is performing parameter scans and wishes to eliminate spurious sources of variation. If -1, then the load balance is checked and reported, but no rebalancing takes place."],
            "back_tracking": ["Back Tracking", "RPNBoolean", "0", "If nonzero, then back-tracking is performed. The beamline is reversed in order and the beam is propagated backwards through the elements. Only a selection of elements are supported at present, including CHARGE, CSBEND, DRIF, EDRIFT, EHCOR, EHVCOR, EVCOR, HMON, KOCT, KQUAD, KSEXT, MARK, MONI, QUAD, RFCA, SBEN, SEXT, TRWAKE, UKICKMAP, VMON, WAKE, and WATCH."]
        },
        "command_sasefel": {
            "output": ["Output", "OutputFile", "", "The filename of an SDDS file to which output will be written."],
            "model": ["Model", "OptionalString", "Ming Xie", "The name of the FEL model used. At present, only one model is supported; the \"Ming-Xie\" model is based on the simple parametrization M. Xie."],
            "beta": ["Beta", "RPNValue", 0, "The value of the beta function, in meters."],
            "undulator_K": ["Undulator K", "RPNValue", 3.1, "The K parameter of the undulator."],
            "undulator_period": ["Undulator Period", "RPNValue", 0.033, "The undulator period, in meters."],
            "slice_fraction": ["Slice Fraction", "RPNValue", 0, "The fraction of beam beam contained by each analysis slice and the number of such slices. By default, no slice analysis is done. Instead, the beam is analyzed only as a whole. If slice_fraction*n_slices is less than 1, then the slice analysis is centered on the median of the time distribution. E.g., if n_slices=1 and slice_fraction=0.1, then the central 10% of the beam would be analyzed. More typically, one gives values such that slice_fraction*n_slices is equal to 1, so that every part of the beam is analyzed. There are separate values in the output file for each slice, plus the whole-beam and slice-averaged results."],
            "n_slices": ["N Slices", "Integer", 0, ""]
        },
        "command_save_lattice": {
            "filename": ["Filename", "OutputFile", "", "The name of a file to which the element and beamline definitions will be written."],
            "output_seq": ["Output Seq", "RPNBoolean", "0", "If non-zero, the lattice will be saved as a single beamline sequence. Elements used for the beamline are re-arranged according to their type. Note: sub-beamline definitions in the original lattice file will be destroyed from the output file. This feature is intended to be used together with insert_elements and replace_elements."]
        },
        "command_sdds_beam": {
            "input": ["Input", "BeamInputFile", "", "Name of an SDDS file containing coordinates of input particles."],
            "input_type": ["Input Type", "SddsBeamInputType", "elegant", ""],
            "n_particles_per_ring": ["N Particles Per Ring", "Integer", 0, "For spiffe data, gives the number of particles to generate for each ring of charge."],
            "selection_parameter": ["Selection Parameter", "OptionalString", "", "The name of a parameter in the SDDS file to be used for selection of pages of data."],
            "selection_string": ["Selection String", "OptionalString", "", "The value of the selection_parameter selection parameter required for a page to be used. E.g., if one has a file from the shower program containing positrons, electrons, and photons, one might want to select only the positrons."],
            "one_random_bunch": ["One Random Bunch", "RPNBoolean", "0", "A flag indicating whether, for spiffe data, a new random distribution should be calculated for each step of the simulation."],
            "reuse_bunch": ["Reuse Bunch", "RPNBoolean", "0", "A flag indicating whether to use the bunch again or not. If set, then the first bunch in the file is used repeatedly for as many tracking steps as requested. Otherwise, each bunch is used only once and the number of steps is limited to the number of bunches (e.g., the number of pages in the file when prebunched=0)."],
            "prebunched": ["Prebunched", "Integer", -1, "Deprecated. Use track_pages_separately instead."],
            "track_pages_separately": ["Track Pages Separately", "RPNBoolean", "0", "If non-zero, then separate pages of the input file are tracked separately. Otherwise, the entire file is tracked together."],
            "use_bunched_mode": ["Use Bunched Mode", "RPNBoolean", "0", "If non-zero, then the IDSlotsPerBunch parameter is used to determine the bunch assignment of particles in the beam based on values in the particleID column. In particular, the bunch number is ⌊ (I-1)/S ⌋, where I is the particle ID and S=IDSlotsPerBunch."],
            "fiducialization_bunch": ["Fiducialization Bunch", "Integer", 0, "If non-negative, then rf cavities (e.g., RFCA, RFDF, RAMPRF) are phased to the indicated bunch (0 is the first bunch). Otherwise, rf cavities are phased to the entire beam (which is probably not what is wanted)."],
            "sample_interval": ["Sample Interval", "RPNBoolean", "1", "If non-zero, only every sample_interval th particle is used."],
            "n_tables_to_skip": ["N Tables To Skip", "Integer", 0, "Number of SDDS pages to skip at the beginning of the file."],
            "center_transversely": ["Center Transversely", "RPNBoolean", "0", "If non-zero, the transverse centroids of the distribution are made to be zero."],
            "center_arrival_time": ["Center Arrival Time", "RPNBoolean", "0", "If non-zero, the mean arrival time of particles at the start of the accelerator is set to zero."],
            "sample_fraction": ["Sample Fraction", "RPNValue", 1, "If non-unity, the randomly selected fraction of the distribution to use."],
            "p_lower": ["P Lower", "RPNValue", 0, "If different, the lower and upper limit on βγ of particles to use."],
            "p_upper": ["P Upper", "RPNValue", 0, ""],
            "save_initial_coordinates": ["Save Initial Coordinates", "RPNBoolean", "1", "A flag that, if set, results in saving initial coordinates of tracked particles in memory. This is the default behavior. If unset, the initial coordinates are not saved, but are reread from disk each time they are needed. This is more memory efficient and is useful for tracking very large numbers of particles."],
            "reverse_t_sign": ["Reverse T Sign", "Integer", 0, ""],
            "n_duplicates": ["N Duplicates", "Integer", 0, "This specifies duplicating the particles from the input file to allow tracking more particles. n_duplicates specifies the number of duplications, where the default value of 0 indicates no duplication. If n-fold duplication is invoked, the particle ID of a new particle is equal to the particle ID of its parent particle plus i N_p, where i=1,...,n+1 is the duplication index and N_p is the number of particles in the parent bunch. This should be kept in mind when using the particle ID to segregate the beam into bunches."],
            "duplicate_stagger": ["Duplicate Stagger", "StringArray", "0, 0, 0, 0, 0, 0", "Specifies offsetting of the coordinates x, x^′, y, y^′, t, and δ for each duplication by the specified amounts. One assumes that some stochastic process such as synchrotron radiation will cause further differentiation of duplicate particles. One can also use SCATTER or DSCATTER elements in the beamline for this purpose."]
        },
        "command_set_reference_particle_output": {
            "match_to": ["Match To", "InputFile", "", "Name of an SDDS file from which a particle distribution will be read. The coordinates of this distribution will be compared to those from tracking to compute a contribution to the optimization penalty function."],
            "weight": ["Weight", "Float6StringArray", "1, 1, 1, 1, 0, 1", "Weight to be assigned to each plane. By default, path-length coordinates are not compared."],
            "comparison_mode": ["Comparison Mode", "SetReferenceParticleOutputComparisonMode", "", "May be one of “max-ad”, “sum-ad”, and “sum-sqr”, corresponding to maximum absolute deviation, sum of absolute deviations, and sum of squared deviations. The default is maximum absolute deviation."]
        },
        "command_slice_analysis": {
            "output": ["Output", "OutputFile", "", "The filename of the output file."],
            "n_slices": ["N Slices", "Integer", 0, "Number of slices to use."],
            "s_start": ["S Start", "RPNValue", 0, "Position in beamline at which to start and stop performing slice analysis."],
            "s_end": ["S End", "RPNValue", 1e300, ""],
            "final_values_only": ["Final Values Only", "RPNBoolean", "0", "If nonzero, then slice quantities are computed only at the end of the beamline."]
        },
        "command_steering_element": {
            "name": ["Name", "OptionalStringUpper", "", "Optional: the (possibly wild-carded) name of the element to add to the steering list. If not given, then element_type must be given."],
            "element_type": ["Element Type", "OptionalStringUpper", "", "Optional: the (possibly wild-carded) name of the element type to add to the steering list. If not given, then name must be given."],
            "item": ["Item", "OptionalStringUpper", "", "The parameter of the element to be varied."],
            "plane": ["Plane", "SteeringElementPlane", "h", ""],
            "tweek": ["Tweek", "RPNValue", 1e-3, "The amount by which to change the item to compute the steering strength."],
            "limit": ["Limit", "RPNValue", 0, "The maximum allowed absolute value of the item."],
            "start_occurence": ["Start Occurence", "Integer", 0, "If nonzero, these give the starting and ending occurence numbers of elements that will be included. N.B.: if wildcards are used, occurence number counting is for each set of identically-named elements separately, rather than for the sequence of matched elements."],
            "end_occurence": ["End Occurence", "Integer", 0, ""],
            "occurence_step": ["Occurence Step", "Integer", 1, ""],
            "s_start": ["S Start", "RPNValue", -1, "If non-negative, these give the gaving and ending position limits for the end-of-element locations of elements to be included."],
            "s_end": ["S End", "RPNValue", -1, ""],
            "after": ["After", "OptionalStringUpper", "", "The name of an element. If given, only elements that follow the named element in the beamline are included."],
            "before": ["Before", "OptionalStringUpper", "", "The name of an element. If given, only elements that precede the named element in the beamline are included."]
        },
        "command_touschek_scatter": {
            "charge": ["Charge", "RPNValue", 0, ""],
            "frequency": ["Frequency", "RPNValue", 1, ""],
            "emit_x": ["Emit X", "RPNValue", 0, ""],
            "emit_nx": ["Emit NX", "RPNValue", 0, ""],
            "emit_y": ["Emit Y", "RPNValue", 0, ""],
            "emit_ny": ["Emit NY", "RPNValue", 0, ""],
            "sigma_dp": ["Sigma DP", "RPNValue", 0, ""],
            "sigma_s": ["Sigma S", "RPNValue", 0, ""],
            "distribution_cutoff": ["Distribution Cutoff", "StringArray", "3, 3, 3", ""],
            "Momentum_Aperture_scale": ["Momentum Aperture Scale", "RPNValue", 0.85, ""],
            "Momentum_Aperture": ["Momentum Aperture", "OptionalString", "", ""],
            "XDist": ["Xdist", "OptionalString", "", ""],
            "YDist": ["Ydist", "OptionalString", "", ""],
            "ZDist": ["Zdist", "OptionalString", "", ""],
            "TranDist": ["Trandist", "OptionalString", "", ""],
            "FullDist": ["Fulldist", "OptionalString", "", ""],
            "bunch": ["Bunch", "OptionalString", "", ""],
            "loss": ["Loss", "OptionalString", "", ""],
            "distribution": ["Distribution", "OptionalString", "", ""],
            "initial": ["Initial", "OptionalString", "", ""],
            "output": ["Output", "OptionalString", "", ""],
            "nbins": ["Nbins", "Integer", 100, ""],
            "sbin_step": ["Sbin Step", "RPNValue", 1, ""],
            "n_simulated": ["N Simulated", "Integer", 5000000, ""],
            "ignored_portion": ["Ignored Portion", "RPNValue", 0.01, ""],
            "i_start": ["I Start", "Integer", 0, ""],
            "i_end": ["I End", "Integer", 1, ""],
            "do_track": ["Do Track", "Integer", 0, ""],
            "match_position_only": ["Match Position Only", "Integer", 0, ""],
            "overwrite_files": ["Overwrite Files", "Integer", 1, ""],
            "verbosity": ["Verbosity", "Integer", 0, ""]
        },
        "command_track": {
            "center_on_orbit": ["Center On Orbit", "RPNBoolean", "0", "A flag indicating whether to center the beam transverse coordinates on the closed orbit before tracking."],
            "center_momentum_also": ["Center Momentum Also", "RPNBoolean", "1", "A flag indicating whether to center the momentum coordinate also."],
            "offset_by_orbit": ["Offset By Orbit", "RPNBoolean", "0", "A flag indicating whether to offset the transverse beam coordinates by the closed orbit before tracking. Similar to center_on_orbit, but the initial centroids of the beam are preserved. The beam is simply displaced by the closed orbit rather than being centered on it."],
            "offset_momentum_also": ["Offset Momentum Also", "RPNBoolean", "1", "A flag indicating whether to also offset the beam momentum to the momentum of the closed orbit. If the start_from_centroid or start_from_dp_centroid parameters are used on the closed_orbit command, this flag should be set to 0; otherwise, one will offset the beam central momentum by its own value."],
            "soft_failure": ["Soft Failure", "RPNBoolean", "1", "If there is an error during tracking (e.g., a failure of orbit correction), continue to produce file output. This creates essentially empty slots in the files corresponding to the failed steps."],
            "use_linear_chromatic_matrix": ["Use Linear Chromatic Matrix", "RPNBoolean", "0", "For each particle, a first-order matrix is computed for the particular momentum offset of the particle using the linear chromaticity and linear dependence of the beta functions on momentum."],
            "longitudinal_ring_only": ["Longitudinal Ring Only", "RPNBoolean", "0", "Tracks longitudinal coordinates only for a ring."],
            "stop_tracking_particle_limit": ["Stop Tracking Particle Limit", "Integer", -1, "If a non-negative is given, then elegant will stop tracking when the number of particles falls below the given value. It will be as if all the particles were lost."],
            "check_beam_structure": ["Check Beam Structure", "RPNBoolean", "0", "For debugging use only."]
        },
        "command_transmute_elements": {
            "name": ["Name", "OptionalStringUpper", "", "Possibily wild-card containing string specifying the elements to which the transmutation specification is to be applied."],
            "type": ["Type", "OptionalStringUpper", "", "Possibily wild-card containing string specifying the element types to which the transmutation specification is to be applied."],
            "exclude": ["Exclude", "OptionalStringUpper", "", "Possibily wild-card containing string specifying elements to be excluded from the specified transmutation. Does not affect elements transmuted due to other specifications."],
            "new_type": ["New Type", "OptionalStringUpper", "DRIF", "Type into which specified elements will be transmuted."],
            "disable": ["Disable", "RPNBoolean", "0", "If nonzero, the command is ignored."],
            "clear": ["Clear", "RPNBoolean", "0", "If nonzero, all prior transmutation specifications are deleted."]
        },
        "command_tune_footprint": {
            "delta_output": ["Delta Output", "OutputFile", "", "The optional name of an SDDS file to send tune and diffusion rate vs δ output to."],
            "xy_output": ["XY Output", "OutputFile", "", "The optional name of an SDDS file to send tune and diffusion rate vs (x, y) output to."],
            "xmin": ["Xmin", "RPNValue", -0.02, "Limits of grid of initial x coordinates for tracking."],
            "xmax": ["Xmax", "RPNValue", 0.02, ""],
            "ymin": ["Ymin", "RPNValue", 1e-6, "Limits of grid of initial y coordinates for tracking. ymin should typically be a small, positive value so that there is some betatron oscillation from which to get the tune."],
            "ymax": ["Ymax", "RPNValue", 0.02, ""],
            "x_for_delta": ["X For Delta", "RPNValue", 1e-6, ""],
            "y_for_delta": ["Y For Delta", "RPNValue", 1e-6, ""],
            "delta_min": ["Delta Min", "RPNValue", 0, "Limits of grid of initial δ coordinates for tracking. Not that particles are not centered around the dispersive closed orbit."],
            "delta_max": ["Delta Max", "RPNValue", 0, ""],
            "nx": ["NX", "Integer", 20, "Number of values of x coordinate in the grid. If zero, amplitude footprint is not determined."],
            "ny": ["NY", "Integer", 21, "Number of values of y coordinate in the grid. If zero, amplitude footprint is not determined."],
            "ndelta": ["Ndelta", "Integer", 21, "Number of values of δ coordinate in the grid. If zero, chromatic footprint is not determined."],
            "separate_xy_for_delta": ["Separate Xy for Delta", "RPNBoolean", "0", "If nonzero, tracking for the x and y momentum-dependent tunes will be done separately, so that when x-plane tracking is performed, y = 0 initially. This might be helpful if nonlinear coupling of y motion into the x plane causes the x tune to be poorly determined for small x amplitudes. Increase the tracking time by a factor of two."],
            "verbosity": ["Verbosity", "RPNBoolean", "1", "If nonzero, prints possibly useful information while running."],
            "quadratic_spacing": ["Quadratic Spacing", "RPNBoolean", "1", "If nonzero, points are spaced \"quadratically,\" which actually means that their squares are spaced linearly. It is highly recommended to keep this turned on, since otherwise problems determining the tune when x ≈ 0 may result in invalid results."],
            "compute_diffusion": ["Compute Diffusion", "RPNBoolean", "1", "If nonzero, diffusion is computed, which requires tracking twice as many turns."],
            "diffusion_rate_limit": ["Diffusion Rate Limit", "Integer", -5, "where N is the number of turns tracked to determine each tune (equal to half of n_passes)."],
            "immediate": ["Immediate", "RPNBoolean", "0", "If nonzero, the calculations take place immediately, instead of only during optimization. If you wish to compute Twiss parameters on a closed orbit or after other calculations, be sure to set this control to zero."],
            "filtered_output": ["Filtered Output", "RPNBoolean", "1", "If nonzero, output is only provided for particles inside the stable footprint."],
            "ignore_half_integer": ["Ignore Half Integer", "RPNBoolean", "0", "If nonzero, half-integer resonances are ignored in determining the tune footprint."]
        },
        "command_tune_shift_with_amplitude": {
            "turns": ["Turns", "Integer", 2048, "The number of turns to track. If zero, then the concatenated matrix is used instead of tracking, and all other parameters of this command are irrelevant. The matrix method doesn't work well with all lattices. The order of the concatenated matrix is given by the concat_order control in twiss_output."],
            "x0": ["X0", "RPNValue", 1e-6, "The initial x and y amplitudes to use for determining the small-amplitude tunes."],
            "y0": ["Y0", "RPNValue", 1e-6, ""],
            "x1": ["X1", "RPNValue", 3e-4, "The initial x and y amplitudes to user for determining the tune shifts. These values should be small enough to ensure linearity in the tune shift."],
            "y1": ["Y1", "RPNValue", 3e-4, ""],
            "grid_size": ["Grid Size", "Integer", 6, "Size of the grid of points in x and y."],
            "lines_only": ["Lines Only", "RPNBoolean", "0", "If nonzero, then instead of a full set of grid_size^2 particles, only two lines of particles with x=0 and/or y=0 are tracked. In this case, no A_x^i*A_y^j terms are computed (except for i=0 or j=0). However, in addition to being faster, the results may be more reliable, e.g., ∂ νx/∂ A_y = ∂ νy/∂ A_x may be more closely satisfied."],
            "sparse_grid": ["Sparse Grid", "RPNBoolean", "0", "If nonzero, then instead of a full set of grid_size^2 particles, a sparse grid of particles is tracked. Will save time at some expense in accuracy."],
            "spread_only": ["Spread Only", "Integer", 0, "Compute the tune spread only and don't bother with the tune shift coefficients. These tune spreads can be optimized and appear in the twiss output file under the names nuxTswaLower, nuxTswaUpper, and similarly for the y plane. This is the recommended way to reduce tune shift with amplitude, as the tune spread is more reliable than the coefficients of the expansion. (Particles that get lost are automatically ignored in both types of computations.)"],
            "nux_roi_width": ["Nux Roi Width", "RPNValue", 0.02, "Widths of the region of interest for x and y tunes. As the grid is filled in, elegant finds the tune for each tracked particle on the grid. Successive tune values are looked for in the region of the given width around the previous tune value. This prevents jumping from the main tune peak to another peak, which can happen when the tune spectrum has many lines."],
            "nuy_roi_width": ["Nuy Roi Width", "RPNValue", 0.02, ""],
            "scale_down_factor": ["Scale Down Factor", "RPNValue", 2, "scale_up_limit, scaling_iterations — These control automatic scaling of the amplitudes. If elegant sees a tune shift larger than scale_down_limit it will decrease x0 (or y0) by the factor scale_down_factor. If elegant sees a tune shift smaller than scale_up_limit it will increase x0 (or y0) by the factor scale_up_factor. Suggestion: if you find yourself playing with these values and the initial amplitudes in order to get reliable TSWA coefficients, try just using the tune spread."],
            "scale_up_factor": ["Scale Up Factor", "RPNValue", 1.05, ""],
            "scale_down_limit": ["Scale Down Limit", "RPNValue", 0.01, ""],
            "scale_up_limit": ["Scale Up Limit", "RPNValue", 1e-4, ""],
            "scaling_iterations": ["Scaling Iterations", "Integer", 10, ""],
            "use_concatenation": ["Use Concatenation", "RPNBoolean", "0", "If nonzero, then tracks with the concatenated matrix instead of element-by-element. The order of the concatenated matrix is given by the concat_order control in twiss_output. The user should experiment with this option to see if the results are reliable for a particular lattice."],
            "verbose": ["Verbose", "RPNBoolean", "0", "If nonzero, information about the progress of the algorithm is printed to the screen."],
            "order": ["Order", "Integer", 2, ""],
            "tune_output": ["Tune Output", "OptionalString", "", ""]
        },
        "command_twiss_analysis": {
            "match_name": ["Match Name", "OptionalStringUpper", "", "Optional wildcard string to match to element names for selection of elements to inculde in the analysis."],
            "start_name": ["Start Name", "OptionalStringUpper", "", "Name of the element at which to start analysis. If the element occurs more than once, the first occurrence is used."],
            "end_name": ["End Name", "OptionalStringUpper", "", "Name of the element at which to end analysis. If the element occurs more than once, the first occurrence is used."],
            "s_start": ["S Start", "RPNValue", -1, "Position (in meters) at which to start analysis."],
            "s_end": ["S End", "RPNValue", -1, "Position (in meters) at which to end analysis."],
            "tag": ["Tag", "OptionalString", "", "Name prefix for quantities computed by the analysis. The quantity names will have the form tag.statistic.quantity, where statistic is one of min, max, and ave, and quantity is one of betax, betay, etax, etay, alphax, alphay, etaxp, and etayp. E.g., if tag is region1, then one could use expressions like region1.max.betax in optimization."],
            "verbosity": ["Verbosity", "Integer", 0, ""],
            "clear": ["Clear", "RPNBoolean", "0", "If nonzero, all previously defined analysis regions are deleted."]
        },
        "command_twiss_output": {
            "filename": ["Filename", "OutputFile", "", "The name of an SDDS file to which the Twiss parameters will be written."],
            "matched": ["Matched", "RPNBoolean", "1", "A flag indicating, if set, that the periodic or matched Twiss parameters should be found. If zero, calculations are performed in transport line mode starting from the given initial values of betax, alphax, etc. N.B.: This may give different values for the chromaticity even if the initial values are identical to those for a periodic solution. The reason has to do with different assumptions about the initial conditions for particles in a transport line vs a ring."],
            "output_at_each_step": ["Output At Each Step", "RPNBoolean", "0", "A flag indicating, if set, that output is desired at each step of the simulation. If you wish to compute Twiss parameters on a closed orbit or after other calculations, be sure to set this control to a nonzero value."],
            "output_before_tune_correction": ["Output Before Tune Correction", "RPNBoolean", "0", "A flag indicating, if set, that output is desired both before and after tune correction."],
            "final_values_only": ["Final Values Only", "RPNBoolean", "0", "A flag indicating, if set, that only the final values of the Twiss parameters should be output, and not the parameters as a function of s."],
            "statistics": ["Statistics", "RPNBoolean", "0", "A flag indicating, if set, that minimum, maximum, and average values of Twiss parameters should be computed and included in output."],
            "radiation_integrals": ["Radiation Integrals", "RPNBoolean", "0", "A flag indicating, if set, that radiation integrals should be computed and included in output. N.B.: Radiation integral computation is not correct for systems with vertical bending, nor does it take into account coupling. See the moments_output command if you need such computations."],
            "concat_order": ["Concat Order", "Integer", 3, "Order of matrix concatenation to use for determining matrix for computation of Twiss parameters. Using a lower order will result in inaccuracy for nonlinear lattices with orbits and/or momentum errors. However, for on-momentum conditions with zero orbit, it is much faster to use concat_order=1."],
            "higher_order_chromaticity": ["Higher Order Chromaticity", "RPNBoolean", "0", "If nonzero, requests computation of the second- and third-order chromaticity. To obtain reliable values, the user should use concat_order=3 in this namelist and the highest available order for all beamline elements. elegant computes the higher-order chromaticity by finding the trace of off-momentum matrices obtained by concantenation of the matrix for higher_order_chromaticity_points values of δ over the full range higher_order_chromaticity_range. If quick_higher_order_chromaticity is nonzero, then a quicker concatenation method is used that gives the second-order chromaticity only."],
            "higher_order_chromaticity_points": ["Higher Order Chromaticity Points", "Integer", 5, ""],
            "higher_order_chromaticity_range": ["Higher Order Chromaticity Range", "RPNValue", 4e-4, ""],
            "chromatic_tune_spread_half_range": ["Chromatic Tune Spread Half Range", "RPNValue", 0, "Half range of δ for which the chromatic tune spread is computed. The results are available in for optimization and in the twiss output file under the names nuxChromUpper, nuxChromLower, and similarly for the y plane. This computation uses the chromaticities."],
            "quick_higher_order_chromaticity": ["Quick Higher Order Chromaticity", "RPNBoolean", "0", ""],
            "beta_x": ["Beta X", "RPNValue", 1, "If matched is zero, the initial values for the X plane."],
            "alpha_x": ["Alpha X", "RPNValue", 0, ""],
            "eta_x": ["Eta X", "RPNValue", 0, ""],
            "etap_x": ["Etap X", "RPNValue", 0, ""],
            "beta_y": ["Beta Y", "RPNValue", 1, ""],
            "alpha_y": ["Alpha Y", "RPNValue", 0, ""],
            "eta_y": ["Eta Y", "RPNValue", 0, ""],
            "etap_y": ["Etap Y", "RPNValue", 0, ""],
            "reference_file": ["Reference File", "InputFile", "", "If given, the name of a file from which twiss parameter data will be taken to give the starting values. Ignored if matched is nonzero. The file should have the beta and alpha functions with the same names as the file created by this command."],
            "reference_element": ["Reference Element", "OptionalString", "", "Element in reference_file at which to take the twiss parameter values. If not given, the values at the last element in reference_file are used."],
            "reference_element_occurrence": ["Reference Element Occurrence", "Integer", 0, "Ignored if reference_element is not given. Otherwise, the occurence number of reference_element to use. If 0, the last occurence is used."],
            "reflect_reference_values": ["Reflect Reference Values", "RPNBoolean", "0", "If nonzero, reference values of α(x,y) and η(x,y)′ are multiplied by -1. This permits matching backwards from the reference point."],
            "cavities_are_drifts_if_matched": ["Cavities Are Drifts If Matched", "RPNBoolean", "1", "By default, if matched=1, elegant treats rf cavities as drift spaces, allowing the user to have a cavity in the ring definition without it affecting the lattice functions. By setting cavities_are_drifts_if_matched=0, one can force elegant to use the actual matrix for the rf cavity. The differences between the results are generally small, but the default behavior disagrees with the results of moments_output. This feature is not available for cavities that change the beam energy (CHANGE_P0=1 in element definition or always_change_p0=1 on run_setup)."],
            "compute_driving_terms": ["Compute Driving Terms", "RPNBoolean", "0", "If nonzero, then resonance driving terms and tune shifts with amplitude are computed by summing over dipole, quadrupole, sextupole, and octupole elements. For dipoles, only the effects of gradients and sextupole terms are included; curvature effects are not present in the theory. In addition, these quantities may be optimized by using those names in optimization terms (see list below)."],
            "leading_order_driving_terms_only": ["Leading Order Driving Terms Only", "RPNBoolean", "0", "If nonzero, only the leading order driving terms are computed. I.e., terms involving double sums over sextupole and quadrupole strengths are not computed. However, leading-order octupole terms are computed, even though they affect the same terms as the second-order sextupole and quadrupole terms. This option is provided because computing the higher-order terms is time-consuming and not always worthwhile."],
            "s_dependent_driving_terms_file": ["S Dependent Driving Terms File", "OutputFile", "", "The name of a SDDS file to which magnitude, real and imaginary parts of s-dependent driving terms will be written. If you wish to compute s-dependent driving terms, be sure to set this parameter. The following first order resonant driving terms are implemented as defined in: f10010, f10100, f30000, f12000, f10200, f01200, f01110, f00300, f00120, f20100, f20010 and f11010. Please note that the notation and meaning of the driving terms differs from those computed when compute_driving_terms=1!"],
            "local_dispersion": ["Local Dispersion", "RPNBoolean", "1", "Normally, elegant will ignore acceleration in computing the dispersion. That is, the dispersion would be the \"local\" dispersion ∂ x / ∂ δ, where δ was the local fractional momentum deviation. In a linac or other systems with rf elements, one might also be interested in the \"global\" dispersion ∂ x / ∂ δ0, where δ0 is the energy deviation at the beginning of the system. In this case, set local_dispersion=0. Alternatively, one may look at the Ri6 elements of the matrix from matrix_output."]
        },
        "command_vary_element": {
            "index_number": ["Index Number", "Integer", 0, "A non-negative integer giving the number of the index."],
            "index_limit": ["Index Limit", "Integer", 0, "A positive integer giving the number of values the index will take. Must be given if this index_number has not been listed in a previous vary_element command, unless enumeration_file is given."],
            "name": ["Name", "OptionalStringUpper", "", "The name of an element."],
            "item": ["Item", "OptionalStringUpper", "", "The parameter of the element to vary."],
            "initial": ["Initial", "RPNValue", 0, "The initial and final values of the parameter."],
            "final": ["Final", "RPNValue", 0, ""],
            "differential": ["Differential", "RPNBoolean", "0", "If nonzero, the initial and final values are taken as offsets from the predefined value of the parameter."],
            "multiplicative": ["Multiplicative", "RPNBoolean", "0", "If nonzero, the initial and final values are taken as multipliers to be applied to the predefined value of the parameter in order to obtain the actual initial and final values."],
            "geometric": ["Geometric", "RPNBoolean", "0", "If nonzero, then variation is geometric rather than arithmetic."],
            "enumeration_file": ["Enumeration File", "InputFile", "", "Name of an SDDS file giving values for the item."],
            "enumeration_column": ["Enumeration Column", "OptionalString", "", "Column of the SDDS file giving the values."]
        },
        "ALPH": {
            "name": ["Name", "ValidatedString"],
            "xmax": ["XMAX [M]", "RPNValue", 0, "size of alpha"],
            "xs1": ["XS1 [M]", "RPNValue", 0, "inner scraper position relative to XMAX"],
            "xs2": ["XS2 [M]", "RPNValue", 0, "outer scraper position relative to XMAX"],
            "dp1": ["DP1", "RPNValue", -1, "inner scraper fractional momentum deviation"],
            "dp2": ["DP2", "RPNValue", 1, "outer scraper fractional momentum deviation"],
            "xpuck": ["XPUCK [M]", "RPNValue", -1, "position of scraper puck"],
            "widthpuck": ["WIDTHPUCK [M]", "RPNValue", 0, "size of scraper puck"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "tilt": ["TILT", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "part": ["PART", "AlphPart", "0", ""],
            "order": ["ORDER", "RPNValue", 0, "matrix order [1,3]"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "APCONTOUR": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "resolution": ["RESOLUTION [M]", "RPNValue", 0, "z resolution of finding intersection"],
            "invert": ["INVERT", "RPNBoolean", "0", "if non-zero, contour defines an obstruction rather than an aperture"],
            "sticky": ["STICKY", "RPNBoolean", "0", "if non-zero, effect persists in downstream elements until canceled or replaced"],
            "cancel": ["CANCEL", "RPNBoolean", "0", "if non-zero, sole effect is to cancel previous sticky APCONTOUR"],
            "filename": ["FILENAME", "InputFile", "", "name of file containing contour data"],
            "xcolumn": ["XCOLUMN", "OptionalString", "", "name of column containing x data"],
            "ycolumn": ["YCOLUMN", "OptionalString", "", "name of column containing y data"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "BGGEXP": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "insertion length"],
            "lfield": ["LFIELD [M]", "RPNValue", -1, "expected length of the field map. If negative, use L."],
            "filename": ["FILENAME", "InputFile", "", "name of file generalized gradient data"],
            "normal_filename": ["NORMAL FILENAME", "InputFile", "", "name of file containing generalized gradient data for normal terms, new convention"],
            "skew_filename": ["SKEW FILENAME", "InputFile", "", "name of file containing generalized gradient data for skew terms, new convention"],
            "strength": ["STRENGTH", "RPNValue", 1, "factor by which to multiply field"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "bx": ["BX [T]", "RPNValue", 0, "add BX*STRENGTH to Bx field"],
            "by": ["BY [T]", "RPNValue", 0, "add BY*STRENGTH to By field"],
            "maximum_m": ["MAXIMUM M", "Integer", -1, "data with m greater than this is ignored"],
            "maximum_2n": ["MAXIMUM 2N", "Integer", -1, "data with 2*n greater than this is ignored"],
            "z_interval": ["Z INTERVAL", "Integer", 1, "input z data is sampled at this interval"],
            "symplectic": ["SYMPLECTIC", "RPNBoolean", "0", "if nonzero, use implicit symplectic integrator. At minimum, should always be used to validate the sufficiency of the non-symplectic integrator."],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "if nonzero, include classical, single-particle synchrotron radiation"],
            "isr": ["ISR", "RPNBoolean", "0", "if nonzero, include incoherent synchrotron radiation (quantum excitation)"],
            "particle_output_file": ["PARTICLE OUTPUT FILE", "OutputFile", "", "name of file for phase-space output. Use for debugging only!"],
            "is_bend": ["IS BEND", "RPNBoolean", "0", "if nonzero, magnet is a bending magnet; vertex, entry, and exit points should be defined."],
            "xvertex": ["XVERTEX [M]", "RPNValue", 0, "For dipoles: x position of vertex in coordinate system of the fields."],
            "zvertex": ["ZVERTEX [M]", "RPNValue", 0, "For dipoles: z position of vertex in coordinate system of the fields."],
            "xentry": ["XENTRY [M]", "RPNValue", 0, "For dipoles: x position of reference entry point in coordinate system of the fields."],
            "zentry": ["ZENTRY [M]", "RPNValue", 0, "For dipoles: z position of reference entry point in coordinate system of the fields."],
            "xexit": ["XEXIT [M]", "RPNValue", 0, "For dipoles: x position of reference exit point in coordinate system of the fields."],
            "zexit": ["ZEXIT [M]", "RPNValue", 0, "For dipoles: z position of reference exit point in coordinate system of the fields."],
            "dxexpansion": ["DXEXPANSION [M]", "RPNValue", 0, "x position of the generalized gradient expansion relative to the reference trajectory."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "BMAPXY": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "strength": ["STRENGTH", "RPNValue", 0, "factor by which to multiply field"],
            "accuracy": ["ACCURACY", "RPNValue", 0, "integration accuracy"],
            "method": ["METHOD", "BmapxyMethod", "", "integration method"],
            "filename": ["FILENAME", "InputFile", "", "name of file containing columns (x, y, Fx, Fy) giving normalized field (Fx, Fy) vs (x, y)"],
            "fx": ["FX", "OptionalString", "", "rpn expression for Fx in terms of x and y"],
            "fy": ["FY", "OptionalString", "", "rpn expression for Fy in terms of x and y"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "BMXYZ": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "insertion length"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "lfield": ["LFIELD [M]", "RPNValue", -1, "expected length of the field map. If negative, use L."],
            "strength": ["STRENGTH", "RPNValue", 1, "factor by which to multiply field"],
            "fse": ["FSE", "RPNValue", 0, "Fractional Strength Error."],
            "accuracy": ["ACCURACY", "RPNValue", 0, "integration accuracy"],
            "method": ["METHOD", "BmxyzMethod", "", "integration method"],
            "filename": ["FILENAME", "InputFile", "", "name of file containing columns (x, y, z) and either (Bx, By, Bz) or (Fx, Fy, Fz)"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical, single-particle synchrotron radiation?"],
            "check_fields": ["CHECK FIELDS", "RPNBoolean", "0", "check fields by computing divB and curlB errors?"],
            "inject_at_z0": ["INJECT AT Z0", "RPNBoolean", "0", "By default, particles are placed at the entrance to the field map regardless of the z coordinate values. If nonzero, particles start at z=0."],
            "drift_matrix": ["DRIFT MATRIX", "RPNBoolean", "0", "If non-zero, instead of tracking to determine the matrix, just assume a drift-space matrix."],
            "xy_interpolation_order": ["XY INTERPOLATION ORDER", "Integer", 1, "Order of interpolation in x and y."],
            "xy_grid_excess": ["XY GRID EXCESS", "Integer", 0, "Number of rows or columns to add in each dimension to the minimum."],
            "single_precision": ["SINGLE PRECISION", "RPNBoolean", "0", "If nonzero, store field data in single precision to reduce memory requirements."],
            "particle_output_file": ["PARTICLE OUTPUT FILE", "OutputFile", "", "name of file for phase-space output inside element. Use for debugging only in serial version."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "BOFFAXE": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "insertion length"],
            "lfield": ["LFIELD [M]", "RPNValue", -1, "expected length of the field map for verification purposes only."],
            "filename": ["FILENAME", "InputFile", "", "name of file containing derivative data"],
            "z_column": ["Z COLUMN", "OptionalString", "", "name of longitunidal coordinate column in the data file"],
            "field_column": ["FIELDCOLUMN", "OptionalString", "", "name of derivative column in the data file"],
            "order": ["ORDER", "Integer", 1, "order of transverse derivative"],
            "expansion_order": ["EXPANSION ORDER", "Integer", 0, "order of expansion in x and y. If zero, determined by data in file."],
            "strength": ["STRENGTH", "RPNValue", 1, "factor by which to multiply field"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "bx": ["BX [T]", "RPNValue", 0, "add BX*STRENGTH to Bx field"],
            "by": ["BY [T]", "RPNValue", 0, "add BY*STRENGTH to By field"],
            "z_interval": ["ZINTERVAL", "Integer", 1, "input z data is sampled at this interval"],
            "z_subdivisions": ["Z SUBDIVISIONS", "Integer", 1, "Number of subdivisions of z interval to use in integration"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "if nonzero, include classical, single-particle synchrotron radiation"],
            "isr": ["ISR", "RPNBoolean", "0", "if nonzero, include incoherent synchrotron radiation (quantum excitation)"],
            "particle_output_file": ["PARTICLE OUTPUT FILE", "OutputFile", "", "name of file for phase-space and field output. Use for debugging only!"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "BRANCH": {
            "name": ["Name", "ValidatedString"],
            "counter": ["COUNTER", "Integer", 0, "Counter, which is decremented by 1 for each pass."],
            "interval": ["INTERVAL", "Integer", 0, "Interval between branching. If non-positive, use COUNTER-based method instead."],
            "offset": ["OFFSET", "Integer", 0, "If INTERVAL method used, offset of branch passes."],
            "verbosity": ["VERBOSITY", "Integer", 0, "Larger values result in more output during running."],
            "default_to_else": ["DEFAULT_TO_ELSE", "RPNBoolean", "0", "If non-zero, defaults to ELSE_TO when performing tracking for closed orbit, twiss_output, etc."],
            "branch_to": ["BRANCH TO", "OptionalStringUpper", "", "Optional name of element to which to jump when counter is non-positive."],
            "else_to": ["ELSE TO", "OptionalStringUpper", "", "Optional name of element to which to jump when counter is positive."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "BRAT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "Nominal bending angle. Will be refined to match geometry specified by input/output and vertex coordinates"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "accuracy": ["ACCURACY", "RPNValue", 0, "integration accuracy"],
            "filename": ["FILENAME", "InputFile", "", "name of file containing columns (x, y, z, Bx, By, Bz)"],
            "xvertex": ["XVERTEX [M]", "RPNValue", 0, "x coordinate of vertex point"],
            "zvertex": ["ZVERTEX [M]", "RPNValue", 0, "z coordinate of vertex point"],
            "xentry": ["XENTRY [M]", "RPNValue", 0, "x coordinate of nominal entry point"],
            "zentry": ["ZENTRY [M]", "RPNValue", 0, "z coordinate of nominal entry point"],
            "xexit": ["XEXIT [M]", "RPNValue", 0, "x coordinate of nominal exit point"],
            "zexit": ["ZEXIT [M]", "RPNValue", 0, "z coordinate of nominal exit point"],
            "dxmap": ["DXMAP [M]", "RPNValue", 0, "x displacement of map"],
            "dzmap": ["DZMAP [M]", "RPNValue", 0, "z displacement of map"],
            "yawmap": ["YAWMAP [RAD]", "RPNValue", 0, "yaw of map about x=z=0"],
            "factor": ["FACTOR", "RPNValue", 1, "factor by which to multiply fields"],
            "delta_by_inside": ["DELTA BY INSIDE [T]", "RPNValue", 0, "Vertical magnetic field to add to the map value when inside the hard-edge boundaries"],
            "use_ftable": ["USE FTABLE", "RPNBoolean", "0", "If nonzero, use FTABLE method for integration. Value gives the number of kicks."],
            "xy_interpolation_order": ["XY INTERPOLATION ORDER", "Integer", 1, "Order of interpolation in x and y."],
            "xy_grid_excess": ["XY GRID EXCESS", "Integer", 0, "Number of rows or columns to add in each dimension to the minimum."],
            "xy_extrapolate": ["XY EXTRAPOLATE", "RPNBoolean", "0", "If nonzero, will extrapolate the field map in (x,y) if particle is outside. Otherwise, field is assumed to be zero."],
            "use_sben_matrix": ["USE SBEN MATRIX", "RPNBoolean", "0", "If nonzero, instead of using tracking to determine the matrix, will just use a sector-bend matrix."],
            "single_precision": ["SINGLE PRECISION", "RPNBoolean", "0", "If nonzero, store field data in single precision to reduce memory requirements. Incompatible with FTABLE mode."],
            "particle_output_file": ["PARTICLE OUTPUT FILE", "OutputFile", "", "Filename template for particle output. Can be very resource intensive!"],
            "particle_output_lost_only": ["PARTICLE OUTPUT LOST ONLY", "RPNBoolean", "0", "If non-zero, particle output includes only lost particles."],
            "particle_output_selection_interval": ["PARTICLE OUTPUT SELECTION INTERVAL", "Integer", 1, "Interval between particles selected for output."],
            "particle_output_sample_interval": ["PARTICLE_OUTPUT_SAMPLE_INTERVAL", "Integer", 1, "Interval in integration steps for particle output."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "BUMPER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "kick angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "b2": ["B2 [1/M²]", "RPNValue", 0, "Sextupole term: By=Bo*(1+b2*x^2)"],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "time offset of waveform"],
            "periodic": ["PERIODIC", "RPNBoolean", "0", "is waveform periodic?"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "fire_on_pass": ["FIRE ON PASS", "RPNValue", 0, "pass number to fire on"],
            "n_kicks": ["N KICKS", "RPNValue", 0, "Number of kicks to use for simulation. 0 uses an exact result but ignores b2."],
            "waveform": ["WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving kick factor vs time"],
            "waveformX": ["X", "String", ""],
            "waveformY": ["Y", "String", ""],
            "deflection_map": ["DEFLECTION MAP", "InputFile", "", "optional filename giving the spatial variation of the deflection"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CCBEND": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "arc length (not chord length!)"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bend angle"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric quadrupole strength"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric sextupole strength"],
            "k3": ["K3 [1/M⁴]", "RPNValue", 0, "geometric octupole strength"],
            "k4": ["K4 [1/M⁵]", "RPNValue", 0, "geometric decapole strength"],
            "k5": ["K5 [1/M⁶]", "RPNValue", 0, "geometric 12-pole strength"],
            "k6": ["K6 [1/M⁷]", "RPNValue", 0, "geometric 14-pole strength"],
            "k7": ["K7 [1/M⁸]", "RPNValue", 0, "geometric 16-pole strength"],
            "k8": ["K8 [1/M⁹]", "RPNValue", 0, "geometric 18-pole strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "yaw": ["YAW [RAD]", "RPNValue", 0, "rotation about vertical axis through entrance point"],
            "hgap": ["HGAP [M]", "RPNValue", 0, "half-gap between poles"],
            "fint1": ["FINT1", "RPNValue", 0, "edge integral for entrance"],
            "fint2": ["FINT2", "RPNValue", 0, "edge integral for exit"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "xkick": ["XKICK [RAD]", "RPNValue", 0, "horizontal steering angle (approximate)"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "fse_dipole": ["FSE DIPOLE", "RPNValue", 0, "fractional strength error of dipole component"],
            "fse_quadrupole": ["FSE QUADRUPOLE", "RPNValue", 0, "fractional strength error of quadrupole component"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "error rotation about incoming longitudinal axis"],
            "n_kicks": ["N_KICKS", "Integer", 4, "number of kicks"],
            "integration_order": ["INTEGRATION ORDER", "Integer", 4, "integration order (2 or 4)"],
            "systematic_multipoles": ["SYSTEMATIC MULTIPOLES", "InputFile", "", "input file for systematic multipoles"],
            "edge_multipoles": ["EDGE MULTIPOLES", "InputFile", "", "input file for systematic entrance/exit edge multipoles"],
            "edge1_multipoles": ["EDGE1 MULTIPOLES", "InputFile", "", "input file for systematic entrance edge multipoles. Overrides EDGE_MULTIPOLES."],
            "edge2_multipoles": ["EDGE2 MULTIPOLES", "InputFile", "", "input file for systematic exit edge multipoles. Overrides EDGE_MULTIPOLES."],
            "random_multipoles": ["RANDOM MULTIPOLES", "InputFile", "", "input file for random multipoles"],
            "systematic_multipole_factor": ["SYSTEMATIC MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply systematic and edge multipoles"],
            "random_multipole_factor": ["RANDOM MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply random multipoles"],
            "reference_order": ["REFERENCE_ORDER", "Integer", 0, "Reference order for multipole errors. Overridden by value in multipole files, if those are given."],
            "min_normal_order": ["MIN NORMAL ORDER", "Integer", -1, "If nonnegative, minimum order of systematic and random normal multipoles to use from data files."],
            "min_skew_order": ["MIN SKEW ORDER", "Integer", -1, "If nonnegative, minimum order of systematic and random skew multipoles to use from data files."],
            "max_normal_order": ["MAX NORMAL ORDER", "Integer", -1, "If nonnegative, maximum order of systematic and random normal multipoles to use from data files."],
            "max_skew_order": ["MAX SKEW ORDER", "Integer", -1, "If nonnegative, maximum order of systematic and random skew multipoles to use from data files."],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical, single-particle synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (quantum excitation)?"],
            "isr1part": ["ISR1PART", "RPNBoolean", "1", "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "use_rad_dist": ["USE RAD DIST", "RPNBoolean", "0", "If nonzero, overrides SYNCH_RAD and ISR, causing simulation of radiation from distributions, optionally including opening angle."],
            "add_opening_angle": ["ADD OPENING ANGLE", "RPNBoolean", "1", "If nonzero, radiation opening angle effects are added if USE_RAD_DIST is nonzero."],
            "optimize_fse": ["OPTIMIZE FSE", "RPNBoolean", "1", "Optimize strength (FSE) to obtain the ideal deflection angle."],
            "optimize_dx": ["OPTIMIZE DX", "RPNBoolean", "1", "Optimize x offset to obtain centered trajectory."],
            "optimize_fse_once": ["OPTIMIZE FSE ONCE", "RPNBoolean", "0", "If nonzero, the FSE offset is optimized only once, even if relevant parameters are changed."],
            "optimize_dx_once": ["OPTIMIZE DX ONCE", "RPNBoolean", "0", "If nonzero, the x offset is optimized only once, even if relevant parameters are changed."],
            "compensate_kn": ["COMPENSATE KN", "RPNBoolean", "0", "If nonzero, K1 and K2 strengths are adjusted to compensate for the changes in FSE needed to center the trajectory."],
            "edge_order": ["EDGE ORDER", "Integer", 3, "Gives order of edge effects. Does not affect edge multipoles."],
            "dx_dy_sign": ["DX DY SIGN", "RPNBoolean", "1", "Prior to 2020.4, the sign of DX and DY was reversed for ANGLE<0. For backward compatibility, this is retained. Set this field to a positive value to use a consistent convention."],
            "verbose": ["VERBOSE", "RPNBoolean", "0", "If nonzero, print messages showing optimized FSE and x offset."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CENTER": {
            "name": ["Name", "ValidatedString"],
            "x": ["X", "RPNBoolean", "1", "center x coordinates?"],
            "xp": ["XP", "RPNBoolean", "1", "center x' coordinates?"],
            "y": ["Y", "RPNBoolean", "1", "center y coordinates?"],
            "yp": ["YP", "RPNBoolean", "1", "center y' coordinates?"],
            "s": ["S", "RPNBoolean", "0", "center s coordinates?"],
            "delta": ["DELTA", "RPNBoolean", "0", "center delta coordinates?"],
            "t": ["T", "RPNBoolean", "0", "center t coordinates?"],
            "once_only": ["ONCE ONLY", "RPNBoolean", "0", "compute centering offsets for first beam only, apply to all?"],
            "on_pass": ["ON PASS", "RPNValue", -1, "If nonnegative, do centering on the nth pass only."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CEPL": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "ramp_time": ["RAMP TIME [S]", "RPNValue", 1e-09, "time to ramp to full strength"],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "offset of ramp-start time"],
            "voltage": ["VOLTAGE [V]", "RPNValue", 0, "maximum voltage between plates due to ramp"],
            "gap": ["GAP [M]", "RPNValue", 0.01, "gap between plates"],
            "static_voltage": ["STATIC VOLTAGE [V]", "RPNValue", 0, "static component of voltage"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy"],
            "x_max": ["X MAX [M]", "RPNValue", 0, "x half-aperture"],
            "y_max": ["Y MAX [M]", "RPNValue", 0, "y half-aperture"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "n_steps": ["N STEPS", "RPNValue", 100, "number of steps (for nonadaptive integration)"],
            "method": ["METHOD", "CeplMethod", "runge-kutta", "integration method"],
            "fiducial": ["FIDUCIAL", "TPFiducial", "t,median", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CHARGE": {
            "name": ["Name", "ValidatedString"],
            "total": ["TOTAL [C]", "RPNValue", 0, "total charge in beam"],
            "per_particle": ["PER PARTICLE [C]", "RPNValue", 0, "charge per macroparticle"],
            "allow_total_change": ["ALLOW TOTAL CHANGE", "RPNBoolean", "0", "If nonzero, allow total charge to change while tracking even if number of particles does not change. Useful for ramping of charge."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CLEAN": {
            "name": ["Name", "ValidatedString"],
            "mode": ["MODE", "CleanMode", "stdeviation", ""],
            "xlimit": ["XLIMIT", "RPNValue", 0, "Limit for x"],
            "xplimit": ["XPLIMIT", "RPNValue", 0, "Limit for x'"],
            "ylimit": ["YLIMIT", "RPNValue", 0, "Limit for y"],
            "yplimit": ["YPLIMIT", "RPNValue", 0, "Limit for y'"],
            "tlimit": ["TLIMIT", "RPNValue", 0, "Limit for t"],
            "deltalimit": ["DELTALIMIT", "RPNValue", 0, "Limit for (p-p0)/p0"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CORGPIPE": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "radius": ["RADIUS [M]", "RPNValue", 0, "pipe radius"],
            "period": ["PERIOD [M]", "RPNValue", 0, "period of corrugations (<<radius recommended)"],
            "gap": ["GAP [M]", "RPNValue", 0, "gap in corrugations (<period required)"],
            "depth": ["DEPTH [M]", "RPNValue", 0, "depth of corrugations (<<radius, >period recommended)"],
            "dt": ["DT [S]", "RPNValue", 0, "maximum time duration of wake (0 for autoscale)"],
            "tmax": ["TMAX [S]", "RPNValue", 0, "maximum time duration of wake (0 for autoscale)"],
            "n_bins": ["N BINS", "RPNValue", 0, "number of bins for charge histogram (0 for autoscale)"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "0", "interpolate wake?"],
            "smoothing": ["SMOOTHING", "RPNBoolean", "0", "Use Savitzky-Golay filter to smooth current histogram?"],
            "sg_halfwidth": ["SG HALFWIDTH", "RPNValue", 4, "Savitzky-Golay filter half-width for smoothing"],
            "sg_order": ["SG ORDER", "RPNValue", 1, "Savitzky-Golay filter order for smoothing"],
            "change_p0": ["CHANGE P0", "RPNBoolean", "0", "change central momentum?"],
            "allow_long_beam": ["ALLOW LONG BEAM", "RPNBoolean", "0", "allow beam longer than wake data?"],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the wake to full strength."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CSBEND": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "arc length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bend angle"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric quadrupole strength"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric sextupole strength"],
            "k3": ["K3 [1/M⁴]", "RPNValue", 0, "geometric octupole strength"],
            "k4": ["K4 [1/M⁵]", "RPNValue", 0, "geometric decapole strength"],
            "k5": ["K5 [1/M⁶]", "RPNValue", 0, "geometric 12-pole strength"],
            "k6": ["K6 [1/M⁷]", "RPNValue", 0, "geometric 14-pole strength"],
            "k7": ["K7 [1/M⁸]", "RPNValue", 0, "geometric 16-pole strength"],
            "k8": ["K8 [1/M⁹]", "RPNValue", 0, "geometric 18-pole strength"],
            "e1": ["E1 [RAD]", "RPNValue", 0, "entrance edge angle"],
            "e2": ["E2 [RAD]", "RPNValue", 0, "exit edge angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "h1": ["H1 [1/M]", "RPNValue", 0, "entrance pole-face curvature"],
            "h2": ["H2 [1/M]", "RPNValue", 0, "exit pole-face curvature"],
            "hgap": ["HGAP [M]", "RPNValue", 0, "half-gap between poles"],
            "fint": ["FINT", "RPNValue", 0.5, "edge-field integral"],
            "fint1": ["FINT1", "RPNValue", -1, "edge-field integral. If negative, use FINT."],
            "fint2": ["FINT2", "RPNValue", -1, "edge-field integral. If negative, use FINT."],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "xkick": ["XKICK [RAD]", "RPNValue", 0, "horizontal steering angle (approximate)"],
            "ykick": ["YKICK [RAD]", "RPNValue", 0, "vertical steering angle (approximate)"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "fse_dipole": ["FSE DIPOLE", "RPNValue", 0, "fractional strength error of dipole component"],
            "fse_quadrupole": ["FSE QUADRUPOLE", "RPNValue", 0, "fractional strength error of quadrupole component"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "error rotation about incoming longitudinal axis"],
            "n_kicks": ["N KICKS", "RPNValue", 4, "number of kicks"],
            "etilt_sign": ["ETILT SIGN", "RPNBoolean", "1", "Sign of ETILT relative to TILT. -1 is the old convention prior to 2020.5"],
            "nonlinear": ["NONLINEAR", "RPNBoolean", "1", "include nonlinear field components?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "edge1_effects": ["EDGE1 EFFECTS", "RPNBoolean", "1", "include entrance edge effects?"],
            "edge2_effects": ["EDGE2 EFFECTS", "RPNBoolean", "1", "include exit edge effects?"],
            "edge_order": ["EDGE ORDER", "RPNValue", 1, "order to which to include edge effects"],
            "integration_order": ["INTEGRATION ORDER", "RPNValue", 4, "integration order (2 or 4)"],
            "expand_hamiltonian": ["EXPAND HAMILTONIAN", "RPNBoolean", "0", "If 1, Hamiltonian is expanded to leading order."],
            "edge1_kick_limit": ["EDGE1 KICK LIMIT", "RPNValue", -1, "maximum kick entrance edge can deliver"],
            "edge2_kick_limit": ["EDGE2 KICK LIMIT", "RPNValue", -1, "maximum kick exit edge can deliver"],
            "kick_limit_scaling": ["KICK LIMIT SCALING", "RPNBoolean", "0", "scale maximum edge kick with FSE?"],
            "use_bn": ["USE BN", "RPNBoolean", "0", "use b<n>instead of K<n>?"],
            "expansion_order": ["EXPANSION ORDER", "RPNValue", 0, "Order of field expansion. (0=auto)"],
            "b1": ["B1 [1/M]", "RPNValue", 0, "K1 = b1/rho, where rho is bend radius"],
            "b2": ["B2 [1/M²]", "RPNValue", 0, "K2 = b2/rho"],
            "b3": ["B3 [1/M³]", "RPNValue", 0, "K3 = b3/rho"],
            "b4": ["B4 [1/M⁴]", "RPNValue", 0, "K4 = b4/rho"],
            "b5": ["B5 [1/M⁵]", "RPNValue", 0, "K5 = b5/rho"],
            "b6": ["B6 [1/M⁶]", "RPNValue", 0, "K6 = b6/rho"],
            "b7": ["B7 [1/M⁷]", "RPNValue", 0, "K7 = b7/rho"],
            "b8": ["B8 [1/M⁸]", "RPNValue", 0, "K8 = b8/rho"],
            "xreference": ["XREFERENCE", "RPNValue", 0, "reference x for interpretation of fn values"],
            "f1": ["F1", "RPNValue", 0, "Fractional field error fn=bn*xr^n/n!, adds to K1 or b1."],
            "f2": ["F2", "RPNValue", 0, "Fractional field error fn=bn*xr^n/n!, adds to K2 or b2."],
            "f3": ["F3", "RPNValue", 0, "Fractional field error fn=bn*xr^n/n!, additive."],
            "f4": ["F4", "RPNValue", 0, "Fractional field error fn=bn*xr^n/n!, additive."],
            "f5": ["F5", "RPNValue", 0, "Fractional field error fn=bn*xr^n/n!, additive."],
            "f6": ["F6", "RPNValue", 0, "Fractional field error fn=bn*xr^n/n!, additive."],
            "f7": ["F7", "RPNValue", 0, "Fractional field error fn=bn*xr^n/n!, additive."],
            "f8": ["F8", "RPNValue", 0, "Fractional field error fn=bn*xr^n/n!, additive."],
            "g1": ["G1", "RPNValue", 0, "Fractional skew field error."],
            "g2": ["G2", "RPNValue", 0, "Fractional skew field error."],
            "g3": ["G3", "RPNValue", 0, "Fractional skew field error."],
            "g4": ["G4", "RPNValue", 0, "Fractional skew field error."],
            "g5": ["G5", "RPNValue", 0, "Fractional skew field error."],
            "g6": ["G6", "RPNValue", 0, "Fractional skew field error."],
            "g7": ["G7", "RPNValue", 0, "Fractional skew field error."],
            "g8": ["G8", "RPNValue", 0, "Fractional skew field error."],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "isr1part": ["ISR1PART", "RPNValue", 1, "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "sqrt_order": ["SQRT ORDER", "RPNValue", 0, "Order of expansion of square-root in Hamiltonian. 0 means no expansion."],
            "use_rad_dist": ["USE RAD DIST", "RPNBoolean", "0", "If nonzero, overrides SYNCH RAD and ISR, causing simulation of radiation from distributions, optionally including opening angle."],
            "add_opening_angle": ["ADD OPENING ANGLE", "RPNBoolean", "1", "If nonzero, radiation opening angle effects are add if USE RAD DIST is nonzero."],
            "photon_output_file": ["PHOTON OUTPUT FILE", "OutputFile", "", "output file for photons, if USE_RAD_DIST=1"],
            "photon_low_energy_cutoff": ["PHOTON LOW ENERGY CUTOFF [eV]", "RPNValue", 0, "Lower limit of photon energy to output."],
            "reference_correction": ["REFERENCE CORRECTION", "RPNBoolean", "0", "If nonzero, reference trajectory is subtracted from particle trajectories to compensate for inaccuracy in integration."],
            "tracking_matrix": ["TRACKING MATRIX", "RPNBoolean", "0", "If nonzero, matrix up to third order used for twiss parameters etc is computed from tracking. Experimental."],
            "fse_correction": ["FSE CORRECTION", "RPNBoolean", 0, "If nonzero, FSE is adjusted to compensate for edge effects when EDGE1_EFFECTS or EDGE2_EFFECTS = 2"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CSRCSBEND": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "arc length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bend angle"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric quadrupole strength"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric sextupole strength"],
            "k3": ["K3 [1/M⁴]", "RPNValue", 0, "geometric octupole strength"],
            "k4": ["K4 [1/M⁵]", "RPNValue", 0, "geometric decapole strength"],
            "k5": ["K5 [1/M⁶]", "RPNValue", 0, "geometric 12-pole strength"],
            "k6": ["K6 [1/M⁷]", "RPNValue", 0, "geometric 14-pole strength"],
            "k7": ["K7 [1/M⁸]", "RPNValue", 0, "geometric 16-pole strength"],
            "k8": ["K8 [1/M⁹]", "RPNValue", 0, "geometric 18-pole strength"],
            "e1": ["E1 [RAD]", "RPNValue", 0, "entrance edge angle"],
            "e2": ["E2 [RAD]", "RPNValue", 0, "exit edge angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "h1": ["H1 [1/M]", "RPNValue", 0, "entrance pole-face curvature"],
            "h2": ["H2 [1/M]", "RPNValue", 0, "exit pole-face curvature"],
            "hgap": ["HGAP [M]", "RPNValue", 0, "half-gap between poles"],
            "fint": ["FINT", "RPNValue", 0.5, "edge-field integral"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "error rotation about incoming longitudinal axis"],
            "n_kicks": ["N KICKS", "RPNValue", 4, "number of kicks"],
            "etilt_sign": ["ETILT_SIGN", "RPNBoolean", "1", "Sign of ETILT relative to TILT. -1 is the old convention prior to 2020.5"],
            "nonlinear": ["NONLINEAR", "RPNBoolean", "1", "include nonlinear field components?"],
            "linearize": ["LINEARIZE", "RPNBoolean", "0", "use linear matrix instead of symplectic integrator?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "edge1_effects": ["EDGE1 EFFECTS", "RPNBoolean", "1", "include entrance edge effects?"],
            "edge2_effects": ["EDGE2 EFFECTS", "RPNBoolean", "1", "include exit edge effects?"],
            "edge_order": ["EDGE ORDER", "RPNValue", 1, "order to which to include edge effects"],
            "integration_order": ["INTEGRATION ORDER", "RPNValue", 4, "integration order (2 or 4)"],
            "bins": ["BINS", "RPNValue", 0, "number of bins for CSR wake"],
            "bin_once": ["BIN ONCE", "RPNBoolean", "0", "bin only at the start of the dipole?"],
            "bin_range_factor": ["BIN RANGE FACTOR", "RPNValue", 1.2, "Factor by which to increase the range of histogram compared to total bunch length. Large value eliminates binning problems in CSRDRIFTs."],
            "sg_halfwidth": ["SG HALFWIDTH", "RPNValue", 0, "Savitzky-Golay filter half-width for smoothing current histogram. If less than 1, no SG smoothing is performed."],
            "sg_order": ["SG ORDER", "RPNValue", 1, "Savitzky-Golay filter order for smoothing current histogram"],
            "sgderiv_halfwidth": ["SGDERIV HALFWIDTH", "RPNValue", 0, "Savitzky-Golay filter half-width for taking derivative of current histogram. Defaults to SG HALFWIDTH (if positive) or else 1."],
            "sgderiv_order": ["SGDERIV ORDER", "RPNValue", 1, "Savitzky-Golay filter order for taking derivative of current histogram"],
            "trapazoid_integration": ["TRAPAZOID INTEGRATION", "RPNValue", 1, "Select whether to use trapazoid-rule integration (default)or a simple sum."],
            "output_file": ["OUTPUT FILE", "OutputFile", "", "output file for CSR wakes"],
            "output_interval": ["OUTPUT INTERVAL", "RPNValue", 1, "interval (in kicks) of output to OUTPUT FILE"],
            "output_last_wake_only": ["OUTPUT LAST WAKE ONLY", "RPNBoolean", "0", "output final wake only?"],
            "steady_state": ["STEADY STATE", "RPNBoolean", "0", "use steady-state wake equations?"],
            "igf": ["IGF", "RPNBoolean", "0", "use integrated Greens function (requires STEADY STATE=1)?"],
            "use_bn": ["USE BN", "RPNBoolean", "0", "use b<n>instead of K<n>?"],
            "expansion_order": ["EXPANSION ORDER", "RPNValue", 0, "Order of field expansion. (0=auto)"],
            "b1": ["B1 [1/M]", "RPNValue", 0, "K1 = b1/rho, where rho is bend radius"],
            "b2": ["B2 [1/M²]", "RPNValue", 0, "K2 = B2/rho"],
            "b3": ["B3 [1/M³]", "RPNValue", 0, "K3 = B3/rho"],
            "b4": ["B4 [1/M⁴]", "RPNValue", 0, "K4 = B4/rho"],
            "b5": ["B5 [1/M⁵]", "RPNValue", 0, "K5 = B5/rho"],
            "b6": ["B6 [1/M⁶]", "RPNValue", 0, "K6 = B6/rho"],
            "b7": ["B7 [1/M⁷]", "RPNValue", 0, "K7 = B7/rho"],
            "b8": ["B8 [1/M⁸]", "RPNValue", 0, "K8 = B8/rho"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "isr1part": ["ISR1PART", "RPNValue", 1, "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "csr": ["CSR", "RPNBoolean", "1", "enable CSR computations?"],
            "block_csr": ["BLOCK CSR", "RPNBoolean", "0", "block CSR from entering CSR-DRIFT?"],
            "derbenev_criterion_mode": ["DERBENEV CRITERION MODE", "CsrcsbendDerbenevCriterionMode", "disable", ""],
            "particle_output_file": ["PARTICLE OUTPUT FILE", "OutputFile", "", "name of file for phase-space output"],
            "particle_output_interval": ["PARTICLE OUTPUT INTERVAL", "RPNValue", 0, "interval (in kicks) of output to PARTICLE OUTPUT FILE"],
            "slice_analysis_interval": ["SLICE ANALYSIS INTERVAL", "RPNValue", 0, "interval (in kicks) of output to slice analysis file (from slice analysis command)"],
            "low_frequency_cutoff0": ["LOW FREQUENCY CUTOFF0", "RPNValue", -1, "Highest spatial frequency at which low-frequency cutoff filter is zero. If not positive, no low-frequency cutoff filter is applied. Frequency is in units of Nyquist (0.5/binsize)."],
            "low_frequency_cutoff1": ["LOW FREQUENCY CUTOFF1", "RPNValue", -1, "Lowest spatial frequency at which low-frequency cutoff filter is 1. If not given, defaults to LOW FREQUENCY CUTOFF1."],
            "high_frequency_cutoff0": ["HIGH FREQUENCY CUTOFF0", "RPNValue", -1, "Spatial frequency at which smoothing (high-frequency cutoff) filter begins. If not positive, no frequency filter smoothing is done. Frequency is in units of Nyquist (0.5/binsize)."],
            "high_frequency_cutoff1": ["HIGH FREQUENCY CUTOFF1", "RPNValue", -1, "Spatial frequency at which smoothing (high-frequency cutoff) filter is 0. If not given, defaults to HIGH FREQUENCY CUTOFF0."],
            "clip_negative_bins": ["CLIP NEGATIVE BINS", "RPNBoolean", "1", "If non-zero, then any bins with negative counts after the filters are applied have the counts set to zero."],
            "wake_filter_file": ["WAKE FILTER FILE", "InputFile", "", "Name of file supplying wake-field filtering data."],
            "wff_freq_column": ["WFF FREQ COLUMN", "OptionalString", "", "Name of column supplying frequency values for wakefield filtering data."],
            "wff_real_column": ["WFF REAL COLUMN", "OptionalString", "", "Name of column supplying real values for wakefield filtering data."],
            "wff_imag_column": ["WFF IMAG COLUMN", "OptionalString", "", "Name of column supplying imaginary values for wakefield filtering data."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CSRDRIFT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "attenuation_length": ["ATTENUATION LENGTH [M]", "RPNValue", 0, "exponential attenuation length for wake"],
            "dz": ["DZ", "RPNValue", 0, "interval between kicks"],
            "n_kicks": ["N KICKS", "RPNValue", 1, "number of kicks (if DZ is zero)"],
            "spread": ["SPREAD", "RPNBoolean", "0", "use spreading function?"],
            "use_overtaking_length": ["USE OVERTAKING LENGTH", "RPNBoolean", "0", "use overtaking length for ATTENUATION LENGTH?"],
            "ol_multiplier": ["OL MULTIPLIER", "RPNValue", 1, "factor by which to multiply the overtaking length to get the attenuation length"],
            "use_saldin54": ["USE SALDIN54", "RPNBoolean", "0", "Use Saldin et al eq. 54 (NIM A398(1997)373-394 for decay vs z?"],
            "saldin54points": ["SALDIN54POINTS", "RPNValue", 1000, "Number of values of position inside bunch to average for Saldin eq 54."],
            "csr": ["CSR", "RPNBoolean", "1", "do CSR calculations"],
            "saldin54norm_mode": ["SALDIN54NORM MODE", "CsrdriftSaldin54normMode", "peak", ""],
            "spread_mode": ["SPREAD MODE", "CsrdriftSpreadMode", "full", ""],
            "wavelength_mode": ["WAVELENGTH MODE", "CsrdriftWavelengthMode", "sigmaz", ""],
            "bunchlength_mode": ["BUNCHLENGTH MODE", "CsrdriftBunchlengthMode", "68-percentile", ""],
            "saldin54_output": ["SALDIN54 OUTPUT", "OutputFile", "", "Filename for output of CSR intensity vs. z as computed using Saldin eq 54."],
            "use_stupakov": ["USE STUPAKOV", "RPNBoolean", "0", "Use treatment from G. Stupakov's note of 9/12/2001?"],
            "stupakov_output": ["STUPAKOV OUTPUT", "OutputFile", "", "Filename for output of CSR wake vs. s as computed using Stupakov's equations."],
            "stupakov_output_interval": ["STUPAKOV OUTPUT INTERVAL", "RPNValue", 1, "Interval (in kicks) between output of Stupakov wakes."],
            "slice_analysis_interval": ["SLICE ANALYSIS INTERVAL", "RPNValue", 0, "interval (in kicks) of output to slice analysis file (from slice analysis command)"],
            "linearize": ["LINEARIZE", "RPNBoolean", "0", "use linear optics for drift pieces?"],
            "lsc_bins": ["LSC BINS", "Integer", 0, "If non-zero, include LSC with given number of bins."],
            "lsc_interpolate": ["LSC INTERPOLATE", "RPNBoolean", "1", "Interpolate computed LSC wake?"],
            "lsc_low_frequency_cutoff0": ["LSC LOW FREQUENCY CUTOFF0", "RPNValue", -1, "Highest spatial frequency at which low-frequency cutoff filter is zero. If not positive, no low-frequency cutoff filter is applied. Frequency is in units of Nyquist (0.5/binsize)."],
            "lsc_low_frequency_cutoff1": ["LSC LOW FREQUENCY CUTOFF1", "RPNValue", -1, "Lowest spatial frequency at which low-frequency cutoff filter is 1. If not given, defaults to LOW FREQUENCY CUTOFF1."],
            "lsc_high_frequency_cutoff0": ["LSC HIGH FREQUENCY CUTOFF0", "RPNValue", -1, "Spatial frequency at which smoothing filter begins for LSC. If not positive, no frequency filter smoothing is done. Frequency is in units of Nyquist (0.5/binsize)."],
            "lsc_high_frequency_cutoff1": ["LSC HIGH FREQUENCY CUTOFF1", "RPNValue", -1, "Spatial frequency at which smoothing filter is 0 for LSC. If not given, defaults to HIGH FREQUENCY CUTOFF0."],
            "lsc_radius_factor": ["LSC RADIUS FACTOR", "RPNValue", 1.7, "Radius factor for LSC computation."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "CWIGGLER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "Total length"],
            "b_max": ["B MAX", "RPNValue", 0, "Maximum on-axis magnetic field."],
            "bx_max": ["BX MAX", "RPNValue", 0, "Maximum on-axis magnetic field. Ignored if B MAX is nonzero."],
            "by_max": ["BY MAX", "RPNValue", 0, "Maximum on-axis magnetic field. Ignored if B MAX is nonzero."],
            "tgu_gradient": ["TGU GRADIENT [1∕M]", "RPNValue", 0, "Transverse gradient divided by maximum on-axis field, used if TGU=1."],
            "tgu_comp_factor": ["TGU COMP FACTOR", "RPNValue", 1, "Use to adjust constant field component to reduce trajectory error."],
            "pole1_factor": ["POLE1 FACTOR", "RPNValue", 1, "Use to adjust first and last pole strength, e.g., to reduce trajectory error."],
            "pole2_factor": ["POLE2 FACTOR", "RPNValue", 1, "Use to adjust second and penultimate pole strength, e.g., to reduce trajectory error."],
            "pole3_factor": ["POLE3 FACTOR", "RPNValue", 1, "Use to adjust third and third-from=last pole strength, e.g., to reduce trajectory error."],
            "dx": ["DX", "RPNValue", 0, "Misalignment."],
            "dy": ["DY", "RPNValue", 0, "Misalignment."],
            "dz": ["DZ", "RPNValue", 0, "Misalignment."],
            "tilt": ["TILT", "RPNValue", 0, "Rotation about beam axis."],
            "periods": ["PERIODS", "RPNValue", 0, "Number of wiggler periods."],
            "steps_per_period": ["STEPS PER PERIOD", "RPNValue", 10, "Integration steps per period."],
            "integration_order": ["INTEGRATION ORDER", "RPNValue", 4, "Integration order (2 or 4)."],
            "by_file": ["BY FILE", "InputFile", "", "Name of SDDS file with By harmonic data."],
            "bx_file": ["BX FILE", "InputFile", "", "Name of SDDS file with Bx harmonic data."],
            "by_split_pole": ["BY SPLIT POLE", "RPNBoolean", "0", "Use \"split-pole\" expansion for By?"],
            "bx_split_pole": ["BX SPLIT POLE", "RPNBoolean", "0", "Use \"split-pole\" expansion for Bx?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "Include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "Include incoherent synchrotron radiation (scattering)?"],
            "isr1part": ["ISR1PART", "RPNValue", 1, "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "sinusoidal": ["SINUSOIDAL", "RPNBoolean", "0", "Ideal sinusoidal wiggler? If non-zero, BX FILE and BY FILE are not used."],
            "vertical": ["VERTICAL", "RPNBoolean", "0", "If SINUSOIDAL is non-zero, then setting this to non-zero gives a vertical wiggler. Default is horizontal."],
            "helical": ["HELICAL", "RPNBoolean", "0", "Ideal helical wiggler? If non-zero and SINUSOIDAL is also non-zero, BX FILE and BY FILE are not used."],
            "tgu": ["TGU", "RPNBoolean", "0", "Ideal transverse gradient undulator? If non-zero and SINUSOIDAL is also non-zero, BX_FILE and BY_FILE are not used. Give gradient in TGU_GRADIENT."],
            "force_matched": ["FORCE MATCHED", "RPNBoolean", "1", "Force matched dispersion for first harmonics? If non-zero, start and end of magnetic field will be inset from the ends of the device if phase is not 0 or π."],
            "field_output": ["FIELD OUTPUT", "OutputFile", "", "Name of file to which field samples will be written. Slow, so use only for debugging."],
            "verbosity": ["VERBOSITY", "Integer", 0, "A higher value requires more detailed printouts related to computations."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "DRIF": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "DSCATTER": {
            "name": ["Name", "ValidatedString"],
            "plane": ["PLANE", "DscatterPlane", "", "Plane to scatter, (dp is deltaP/P)"],
            "filename": ["FILENAME", "InputFile", "", "Name of SDDS file containing distribution function."],
            "valuename": ["VALUENAME", "OptionalString", "", "Name of column containing the independent variable for the distribution function data."],
            "cdfname": ["CDFNAME", "OptionalString", "", "Name of column containing the cumulative distribution function data."],
            "pdfname": ["PDFNAME", "OptionalString", "", "Name of column containing the probability distribution function data."],
            "onceperparticle": ["ONCEPERPARTICLE", "RPNBoolean", "0", "If nonzero, each particle can only get scattered once by this element."],
            "factor": ["FACTOR", "RPNValue", 1, "Factor by which to multiply the independent variable values."],
            "probability": ["PROBABILITY", "RPNValue", 1, "Probability that any particle will be selected for scattering."],
            "groupid": ["GROUPID", "RPNValue", -1, "Group ID number (nonnegative integer) for linking once per-particle behavior of multiple elements."],
            "randomsign": ["RANDOMSIGN", "RPNBoolean", "0", "If non-zero, then the scatter is given a random sign. Useful if distribution data is one-sided."],
            "limitperpass": ["LIMITPERPASS", "RPNValue", -1, "Maximum number of particles that will be scattered on each pass."],
            "limittotal": ["LIMITTOTAL", "RPNValue", -1, "Maximum number of particles that will be scatter for each step."],
            "startonpass": ["STARTONPASS", "RPNValue", 0, "Pass number to start on."],
            "endonpass": ["ENDONPASS", "RPNValue", -1, "Pass number to end on (inclusive). Ignored if negative."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "ECOL": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "x_max": ["X MAX [M]", "RPNValue", 0, "half-axis in x"],
            "y_max": ["Y MAX [M]", "RPNValue", 0, "half-axis in y"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "open_side": ["OPEN SIDE", "OpenSide", "", "which side, if any, is open"],
            "exponent": ["EXPONENT", "RPNValue", 2, "Exponent for boundary equation. 2 is ellipse."],
            "yexponent": ["YEXPONENT", "RPNValue", 0, "yexponent for boundary equation. 2 is ellipse. If 0, defaults to EXPONENT"],
            "invert": ["INVERT", "RPNBoolean", "0", "If non-zero, particles inside the aperture are lost while those outside are transmitted."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "EDRIFT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "EHKICK": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "kick": ["KICK [RAD]", "RPNValue", 0, "kick angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "calibration": ["CALIBRATION", "RPNValue", 1, "factor applied to obtain kick"],
            "steering": ["STEERING", "RPNBoolean", "1", "use for steering?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "lerad": ["LERAD", "RPNValue", 0, "if L=0, use this length for radiation computations"],
            "steering_multipoles": ["STEERING MULTIPOLES", "InputFile", "", "input file for systematic multipole content of steering kicks"],
            "random_multipoles": ["RANDOM MULTIPOLES", "InputFile", "", "input file for random multipoles content of steering kicks"],
            "random_multipole_factor": ["RANDOM MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply random multipoles"],
            "steering_multipole_factor": ["STEERING MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply steering multipoles"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "EKICKER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "hkick": ["HKICK [RAD]", "RPNValue", 0, "horizontal kick angle"],
            "vkick": ["VKICK [RAD]", "RPNValue", 0, "vertical kick angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "hcalibration": ["HCALIBRATION", "RPNValue", 1, "factor applied to obtain horizontal kick"],
            "vcalibration": ["VCALIBRATION", "RPNValue", 1, "factor applied to obtain vertical kick"],
            "steering": ["STEERING", "RPNBoolean", "1", "use for steering?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "lerad": ["LERAD", "RPNValue", 0, "if L=0, use this length for radiation computations"],
            "steering_multipoles": ["STEERING MULTIPOLES", "InputFile", "", "input file for systematic multipole content of steering kicks"],
            "random_multipoles": ["RANDOM MULTIPOLES", "InputFile", "", "input file for random multipoles content of steering kicks"],
            "random_multipole_factor": ["RANDOM MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply random multipoles"],
            "steering_multipole_factor": ["STEERING MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply steering multipoles"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "ELSE": {
            "name": ["Name", "ValidatedString"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "EMATRIX": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "Length (used only for position computation)"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "Angle (used only for position computation)"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "Tilt angle"],
            "yaw": ["YAW [RAD]", "RPNValue", 0, "Yaw angle"],
            "pitch": ["PITCH [RAD]", "RPNValue", 0, "Pitch angle"],
            "order": ["ORDER", "RPNValue", 0, ""],
            "c1": ["C1 [M]", "RPNValue", 0, ""],
            "c2": ["C2", "RPNValue", 0, ""],
            "c3": ["C3 [M]", "RPNValue", 0, ""],
            "c4": ["C4", "RPNValue", 0, ""],
            "c5": ["C5 [M]", "RPNValue", 0, ""],
            "c6": ["C6", "RPNValue", 0, "Change in momentum offset"],
            "deltap": ["DELTAP", "RPNValue", 0, "Change in central momentum (beta*gamma)"],
            "r11": ["R11", "RPNValue", 0, ""],
            "r12": ["R12 [M]", "RPNValue", 0, ""],
            "r13": ["R13", "RPNValue", 0, ""],
            "r14": ["R14 [M]", "RPNValue", 0, ""],
            "r15": ["R15", "RPNValue", 0, ""],
            "r16": ["R16 [M]", "RPNValue", 0, ""],
            "r21": ["R21 [1/M]", "RPNValue", 0, ""],
            "r22": ["R22", "RPNValue", 0, ""],
            "r23": ["R23 [1/M]", "RPNValue", 0, ""],
            "r24": ["R24", "RPNValue", 0, ""],
            "r25": ["R25 [1/M]", "RPNValue", 0, ""],
            "r26": ["R26", "RPNValue", 0, ""],
            "r31": ["R31", "RPNValue", 0, ""],
            "r32": ["R32 [M]", "RPNValue", 0, ""],
            "r33": ["R33", "RPNValue", 0, ""],
            "r34": ["R34 [M]", "RPNValue", 0, ""],
            "r35": ["R35", "RPNValue", 0, ""],
            "r36": ["R36 [M]", "RPNValue", 0, ""],
            "r41": ["R41 [1/M]", "RPNValue", 0, ""],
            "r42": ["R42", "RPNValue", 0, ""],
            "r43": ["R43 [1/M]", "RPNValue", 0, ""],
            "r44": ["R44", "RPNValue", 0, ""],
            "r45": ["R45 [1/M]", "RPNValue", 0, ""],
            "r46": ["R46", "RPNValue", 0, ""],
            "r51": ["R51", "RPNValue", 0, ""],
            "r52": ["R52 [M]", "RPNValue", 0, ""],
            "r53": ["R53", "RPNValue", 0, ""],
            "r54": ["R54 [M]", "RPNValue", 0, ""],
            "r55": ["R55", "RPNValue", 0, ""],
            "r56": ["R56 [M]", "RPNValue", 0, ""],
            "r61": ["R61 [1/M]", "RPNValue", 0, ""],
            "r62": ["R62", "RPNValue", 0, ""],
            "r63": ["R63 [1/M]", "RPNValue", 0, ""],
            "r64": ["R64", "RPNValue", 0, ""],
            "r65": ["R65 [1/M]", "RPNValue", 0, ""],
            "r66": ["R66", "RPNValue", 0, ""],
            "t111": ["T111 [1/M]", "RPNValue", 0, ""],
            "t121": ["T121", "RPNValue", 0, ""],
            "t122": ["T122 [M]", "RPNValue", 0, ""],
            "t131": ["T131 [1/M]", "RPNValue", 0, ""],
            "t132": ["T132", "RPNValue", 0, ""],
            "t133": ["T133 [1/M]", "RPNValue", 0, ""],
            "t141": ["T141", "RPNValue", 0, ""],
            "t142": ["T142 [M]", "RPNValue", 0, ""],
            "t143": ["T143", "RPNValue", 0, ""],
            "t144": ["T144 [M]", "RPNValue", 0, ""],
            "t151": ["T151 [1/M]", "RPNValue", 0, ""],
            "t152": ["T152", "RPNValue", 0, ""],
            "t153": ["T153 [1/M]", "RPNValue", 0, ""],
            "t154": ["T154", "RPNValue", 0, ""],
            "t155": ["T155 [1/M]", "RPNValue", 0, ""],
            "t161": ["T161", "RPNValue", 0, ""],
            "t162": ["T162 [M]", "RPNValue", 0, ""],
            "t163": ["T163", "RPNValue", 0, ""],
            "t164": ["T164 [M]", "RPNValue", 0, ""],
            "t165": ["T165", "RPNValue", 0, ""],
            "t166": ["T166 [M]", "RPNValue", 0, ""],
            "t211": ["T211 [1/M²]", "RPNValue", 0, ""],
            "t221": ["T221 [1/M]", "RPNValue", 0, ""],
            "t222": ["T222", "RPNValue", 0, ""],
            "t231": ["T231 [1/M²]", "RPNValue", 0, ""],
            "t232": ["T232 [1/M]", "RPNValue", 0, ""],
            "t233": ["T233 [1/M²]", "RPNValue", 0, ""],
            "t241": ["T241 [1/M]", "RPNValue", 0, ""],
            "t242": ["T242", "RPNValue", 0, ""],
            "t243": ["T243 [1/M]", "RPNValue", 0, ""],
            "t244": ["T244", "RPNValue", 0, ""],
            "t251": ["T251 [1/M²]", "RPNValue", 0, ""],
            "t252": ["T252 [1/M]", "RPNValue", 0, ""],
            "t253": ["T253 [1/M²]", "RPNValue", 0, ""],
            "t254": ["T254 [1/M]", "RPNValue", 0, ""],
            "t255": ["T255 [1/M²]", "RPNValue", 0, ""],
            "t261": ["T261 [1/M]", "RPNValue", 0, ""],
            "t262": ["T262", "RPNValue", 0, ""],
            "t263": ["T263 [1/M]", "RPNValue", 0, ""],
            "t264": ["T264 [1]", "RPNValue", 0, ""],
            "t265": ["T265 [1/M]", "RPNValue", 0, ""],
            "t266": ["T266", "RPNValue", 0, ""],
            "t311": ["T311 [1/M]", "RPNValue", 0, ""],
            "t321": ["T321", "RPNValue", 0, ""],
            "t322": ["T322 [M]", "RPNValue", 0, ""],
            "t331": ["T331 [1/M]", "RPNValue", 0, ""],
            "t332": ["T332", "RPNValue", 0, ""],
            "t333": ["T333 [1/M]", "RPNValue", 0, ""],
            "t341": ["T341", "RPNValue", 0, ""],
            "t342": ["T342 [M]", "RPNValue", 0, ""],
            "t343": ["T343", "RPNValue", 0, ""],
            "t344": ["T344 [M]", "RPNValue", 0, ""],
            "t351": ["T351 [1/M]", "RPNValue", 0, ""],
            "t352": ["T352", "RPNValue", 0, ""],
            "t353": ["T353 [1/M]", "RPNValue", 0, ""],
            "t354": ["T354", "RPNValue", 0, ""],
            "t355": ["T355 [1/M]", "RPNValue", 0, ""],
            "t361": ["T361", "RPNValue", 0, ""],
            "t362": ["T362 [M]", "RPNValue", 0, ""],
            "t363": ["T363", "RPNValue", 0, ""],
            "t364": ["T364 [M]", "RPNValue", 0, ""],
            "t365": ["T365", "RPNValue", 0, ""],
            "t366": ["T366 [M]", "RPNValue", 0, ""],
            "t411": ["T411 [1/M²]", "RPNValue", 0, ""],
            "t421": ["T421 [1/M]", "RPNValue", 0, ""],
            "t422": ["T422", "RPNValue", 0, ""],
            "t431": ["T431 [1/M²]", "RPNValue", 0, ""],
            "t432": ["T432 [1/M]", "RPNValue", 0, ""],
            "t433": ["T433 [1/M²]", "RPNValue", 0, ""],
            "t441": ["T441 [1/M]", "RPNValue", 0, ""],
            "t442": ["T442", "RPNValue", 0, ""],
            "t443": ["T443 [1/M]", "RPNValue", 0, ""],
            "t444": ["T444", "RPNValue", 0, ""],
            "t451": ["T451 [1/M²]", "RPNValue", 0, ""],
            "t452": ["T452 [1/M]", "RPNValue", 0, ""],
            "t453": ["T453 [1/M²]", "RPNValue", 0, ""],
            "t454": ["T454 [1/M]", "RPNValue", 0, ""],
            "t455": ["T455 [1/M²]", "RPNValue", 0, ""],
            "t461": ["T461 [1/M]", "RPNValue", 0, ""],
            "t462": ["T462", "RPNValue", 0, ""],
            "t463": ["T463 [1/M]", "RPNValue", 0, ""],
            "t464": ["T464 [1]", "RPNValue", 0, ""],
            "t465": ["T465 [1/M]", "RPNValue", 0, ""],
            "t466": ["T466", "RPNValue", 0, ""],
            "t511": ["T511 [1/M]", "RPNValue", 0, ""],
            "t521": ["T521", "RPNValue", 0, ""],
            "t522": ["T522 [M]", "RPNValue", 0, ""],
            "t531": ["T531 [1/M]", "RPNValue", 0, ""],
            "t532": ["T532", "RPNValue", 0, ""],
            "t533": ["T533 [1/M]", "RPNValue", 0, ""],
            "t541": ["T541", "RPNValue", 0, ""],
            "t542": ["T542 [M]", "RPNValue", 0, ""],
            "t543": ["T543", "RPNValue", 0, ""],
            "t544": ["T544 [M]", "RPNValue", 0, ""],
            "t551": ["T551 [1/M]", "RPNValue", 0, ""],
            "t552": ["T552", "RPNValue", 0, ""],
            "t553": ["T553 [1/M]", "RPNValue", 0, ""],
            "t554": ["T554", "RPNValue", 0, ""],
            "t555": ["T555 [1/M]", "RPNValue", 0, ""],
            "t561": ["T561", "RPNValue", 0, ""],
            "t562": ["T562 [M]", "RPNValue", 0, ""],
            "t563": ["T563", "RPNValue", 0, ""],
            "t564": ["T564 [M]", "RPNValue", 0, ""],
            "t565": ["T565", "RPNValue", 0, ""],
            "t566": ["T566 [M]", "RPNValue", 0, ""],
            "t611": ["T611 [1/M²]", "RPNValue", 0, ""],
            "t621": ["T621 [1/M]", "RPNValue", 0, ""],
            "t622": ["T622", "RPNValue", 0, ""],
            "t631": ["T631 [1/M²]", "RPNValue", 0, ""],
            "t632": ["T632 [1/M]", "RPNValue", 0, ""],
            "t633": ["T633 [1/M²]", "RPNValue", 0, ""],
            "t641": ["T641 [1/M]", "RPNValue", 0, ""],
            "t642": ["T642", "RPNValue", 0, ""],
            "t643": ["T643 [1/M]", "RPNValue", 0, ""],
            "t644": ["T644", "RPNValue", 0, ""],
            "t651": ["T651 [1/M²]", "RPNValue", 0, ""],
            "t652": ["T652 [1/M]", "RPNValue", 0, ""],
            "t653": ["T653 [1/M²]", "RPNValue", 0, ""],
            "t654": ["T654 [1/M]", "RPNValue", 0, ""],
            "t655": ["T655 [1/M²]", "RPNValue", 0, ""],
            "t661": ["T661 [1/M]", "RPNValue", 0, ""],
            "t662": ["T662", "RPNValue", 0, ""],
            "t663": ["T663 [1/M]", "RPNValue", 0, ""],
            "t664": ["T664 [1]", "RPNValue", 0, ""],
            "t665": ["T665 [1/M]", "RPNValue", 0, ""],
            "t666": ["T666", "RPNValue", 0, ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "EMITTANCE": {
            "name": ["Name", "ValidatedString"],
            "emitx": ["EMITX [M]", "RPNValue", -1, "horizontal emittance"],
            "emity": ["EMITY [M]", "RPNValue", -1, "vertical emittance"],
            "emitnx": ["EMITNX [M]", "RPNValue", -1, "horizontal normalized emittance"],
            "emitny": ["EMITNY [M]", "RPNValue", -1, "vertical normalized emittance"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "ENERGY": {
            "name": ["Name", "ValidatedString"],
            "central_energy": ["CENTRAL ENERGY [MC2]", "RPNValue", 0, "desired central gamma"],
            "central_momentum": ["CENTRAL MOMENTUM [MC]", "RPNValue", 0, "desired central beta*gamma"],
            "match_beamline": ["MATCH BEAMLINE", "RPNBoolean", "0", "if nonzero, beamline reference momentum is set to beam average momentum"],
            "match_particles": ["MATCH PARTICLES", "RPNBoolean", "0", "if nonzero, beam average momentum is set to beamline reference momentum"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "EVKICK": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "kick": ["KICK [RAD]", "RPNValue", 0, "kick angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "calibration": ["CALIBRATION", "RPNValue", 1, "factor applied to obtain kick"],
            "steering": ["STEERING", "RPNBoolean", "1", "use for steering?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "lerad": ["LERAD", "RPNValue", 0, "if L=0, use this length for radiation computations"],
            "steering_multipoles": ["STEERING MULTIPOLES", "InputFile", "", "input file for systematic multipole content of steering kicks"],
            "random_multipoles": ["RANDOM MULTIPOLES", "InputFile", "", "input file for random multipoles content of steering kicks"],
            "random_multipole_factor": ["RANDOM MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply random multipoles"],
            "steering_multipole_factor": ["STEERING MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply steering multipoles"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "FLOOR": {
            "name": ["Name", "ValidatedString"],
            "x": ["X", "RPNValue", 0, "X coordinate"],
            "y": ["Y", "RPNValue", 0, "Y coordinate"],
            "z": ["Z", "RPNValue", 0, "Z coordinate"],
            "theta": ["THETA", "RPNValue", 0, "theta value"],
            "phi": ["PHI", "RPNValue", 0, "phi value"],
            "psi": ["PSI", "RPNValue", 0, "psi value"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "FMULT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "n_kicks": ["N KICKS", "RPNValue", 1, "number of kicks"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "filename": ["FILENAME", "InputFile", "", "name of file containing multi-pole data"],
            "sqrt_order": ["SQRT ORDER", "RPNValue", 0, "Order of expansion of square-root in Hamiltonian. 0 means no expansion."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "FRFMODE": {
            "name": ["Name", "ValidatedString"],
            "filename": ["FILENAME", "InputFile", "", "input file"],
            "bin_size": ["BIN SIZE [S]", "RPNValue", 0, "bin size for current histogram (use 0 for autosize)"],
            "n_bins": ["N BINS", "RPNValue", 20, "number of bins for current histogram"],
            "rigid_until_pass": ["RIGID UNTIL PASS", "RPNValue", 0, "don't affect the beam until this pass"],
            "use_symm_data": ["USE SYMM DATA", "RPNBoolean", "0", "use \"Symm\" columns from URMEL output file?"],
            "factor": ["FACTOR", "RPNValue", 1, "factor by which to multiply shunt impedances"],
            "cutoff": ["CUTOFF [HZ]", "RPNValue", 0, "If >0, cutoff frequency. Modes above this frequency are ignored."],
            "output_file": ["OUTPUT FILE", "OutputFile", "", "Output file for voltage in each mode."],
            "flush_interval": ["FLUSH INTERVAL", "RPNValue", 1, "Interval in passes at which to flush output data."],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the impedance to full strength."],
            "reset_for_each_step": ["RESET FOR EACH STEP", "RPNBoolean", "1", "If nonzero, voltage and phase are reset for each simulation step."],
            "long_range_only": ["LONG RANGE ONLY", "RPNBoolean", "0", "If nonzero, induced voltage from present turn does not affect bunch. Short range wake should be included via WAKE or ZLONGIT element."],
            "n_cavities": ["N CAVITIES", "RPNValue", 1, "effect is multiplied by this number, simulating N identical cavities"],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, then do calculations bunch-by-bunch."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "FTABLE": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "The effective field length measured along a straight line."],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "The designed bending angle"],
            "l1": ["L1 [M]", "RPNValue", 0, "The left fringe field length."],
            "l2": ["L2 [M]", "RPNValue", 0, "The right fringe field length. L1+L+L2=Total z span in the input field table."],
            "e1": ["E1 [RAD]", "RPNValue", 0, "The designed entrance edge angle"],
            "e2": ["E2 [RAD]", "RPNValue", 0, "The designed exit edge angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "factor": ["FACTOR", "RPNValue", 1, "Factor by which to multiply field data."],
            "threshold": ["THRESHOLD", "RPNValue", 1e-08, "Fields smaller than this are considered 0."],
            "input_file": ["INPUT FILE", "InputFile", "", "Name of SDDS file which contains field data."],
            "n_kicks": ["N KICKS", "RPNValue", 1, "Number of kicks into which to split the element."],
            "verbose": ["VERBOSE", "RPNValue", 0, "Used for debugging code. Not applicable to Pelegant"],
            "simple_input": ["SIMPLE INPUT", "RPNBoolean", "0", "If non-zero, use simple input format."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "FTRFMODE": {
            "name": ["Name", "ValidatedString"],
            "filename": ["FILENAME", "InputFile", "", "input file"],
            "bin_size": ["BIN SIZE [S]", "RPNValue", 0, "bin size for current histogram (use 0 for autosize)"],
            "n_bins": ["N BINS", "RPNValue", 20, "number of bins for current histogram"],
            "rigid_until_pass": ["RIGID UNTIL PASS", "RPNValue", 0, "don't affect the beam until this pass"],
            "use_symm_data": ["USE SYMM DATA", "RPNBoolean", "0", "use \"Symm\" columns from URMEL output file?"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "xfactor": ["XFACTOR", "RPNValue", 1, "factor by which to multiply shunt impedances"],
            "yfactor": ["YFACTOR", "RPNValue", 1, "factor by which to multiply shunt impedances"],
            "cutoff": ["CUTOFF [HZ]", "RPNValue", 0, "If >0, cutoff frequency. Modes above this frequency are ignored."],
            "output_file": ["OUTPUT FILE", "OutputFile", "", "Output file for voltage in each mode."],
            "flush_interval": ["FLUSH INTERVAL", "RPNValue", 1, "Interval in passes at which to flush output data."],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the impedance to full strength."],
            "reset_for_each_step": ["RESET FOR EACH STEP", "RPNBoolean", "1", "If nonzero, voltage and phase are reset for each simulation step."],
            "long_range_only": ["LONG RANGE ONLY", "RPNBoolean", "0", "If nonzero, induced voltage from present turn does not affect bunch. Short range wake should be included via WAKE or ZLONGIT element."],
            "n_cavities": ["N CAVITIES", "RPNValue", 1, "effect is multiplied by this number, simulating N identical cavities"],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, then do calculations bunch-by-bunch."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "GFWIGGLER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "Total length"],
            "b_max": ["B MAX [T]", "RPNValue", 0, "Maximum on-axis magnetic field at gap=GAP0 and equal longitudinal phases of PHASE 1,2,3,4"],
            "shim_scale": ["SHIM SCALE", "RPNValue", 1, "Scaling factor of shim correction field."],
            "dx": ["DX [M]", "RPNValue", 0, "Misalignment."],
            "dy": ["DY [M]", "RPNValue", 0, "Misalignment."],
            "dz": ["DZ [M]", "RPNValue", 0, "Misalignment."],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "Rotation about beam axis."],
            "periods": ["PERIODS", "RPNValue", 0, "Total number of wiggler periods. Include end poles"],
            "step": ["STEP", "RPNValue", 1, "Number of normal periods to track for each step"],
            "order": ["ORDER", "RPNValue", 0, "Order=3 including the 3rd order terms. Otherwise using 2nd order formula."],
            "end_pole": ["END POLE", "RPNValue", 1, "The ending poles are treated as 2 half periods at each sides of the wiggler with reducing field strength, such as 0.25, 0.75, ..., 0.75, -0.25. Periods has to >2"],
            "shim_on": ["SHIM ON", "RPNValue", 0, "Include shim correction"],
            "input_file": ["INPUT FILE", "InputFile", "", "Name of SDDS file with By harmonic data given at GAP0 and equal longitudinal phases."],
            "shim_input": ["SHIM INPUT", "InputFile", "", "Name of SDDS file with shim field integral harmonic data given at GAP0."],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "Include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "Include incoherent synchrotron radiation (scattering)?"],
            "isr1part": ["ISR1PART", "RPNValue", 1, "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "x0": ["X0 [M]", "RPNValue", 0, "Offset of magnet row center in meter."],
            "gap0": ["GAP0 [M]", "RPNValue", 0, "Nominal magnetic gap."],
            "d_gap": ["D GAP [M]", "RPNValue", 0, "Delta gap: actual gap -nominal gap"],
            "phase_1": ["PHASE 1 [RAD]", "RPNValue", 0, "Longitudinal phase of the first row (top right)"],
            "phase_2": ["PHASE 2 [RAD]", "RPNValue", 0, "Longitudinal phase of the second row (top left)"],
            "phase_3": ["PHASE 3 [RAD]", "RPNValue", 0, "Longitudinal phase of the third row (bottom left)"],
            "phase_4": ["PHASE 4 [RAD]", "RPNValue", 0, "Longitudinal phase of the fourth row (bottom right)"],
            "verbosity": ["VERBOSITY", "Integer", 0, "A higher value requires more detailed printouts related to computations."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "HISTOGRAM": {
            "name": ["Name", "ValidatedString"],
            "filename": ["FILENAME", "OutputFile", "", "filename for histogram output, possibly incomplete (see below)"],
            "interval": ["INTERVAL", "RPNValue", 1, "interval in passes between output"],
            "start_pass": ["START PASS", "RPNValue", 0, "starting pass for output"],
            "bins": ["BINS", "RPNValue", 50, "number of bins"],
            "fixed_bin_size": ["FIXED BIN SIZE", "RPNBoolean", "0", "if nonzero, bin size is fixed after the first histogram is made"],
            "x_data": ["X DATA", "RPNBoolean", "1", "histogram x and x' ?"],
            "y_data": ["Y DATA", "RPNBoolean", "1", "histogram y and y' ?"],
            "longit_data": ["LONGIT DATA", "RPNBoolean", "1", "histogram t and p?"],
            "bin_size_factor": ["BIN SIZE FACTOR", "RPNValue", 1, "multiply computed bin size by this factor before histogram-ming"],
            "normalize": ["NORMALIZE", "RPNBoolean", "1", "normalize histogram with bin size and number of particles?"],
            "disable": ["DISABLE", "RPNBoolean", "0", "If nonzero, no output will be generated."],
            "sparse": ["SPARSE", "RPNBoolean", "0", "If nonzero, only bins with nonzero counts will be output."],
            "start_pid": ["START PID", "RPNValue", -1, "starting particleID for particles to include"],
            "end_pid": ["END PID", "RPNValue", -1, "ending particleID for particles to include"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "HKICK": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "kick": ["KICK [RAD]", "RPNValue", 0, "kick strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "b2": ["B2 [1/M²]", "RPNValue", 0, "normalized sextupole strength (kick = KICK*(1+B2*x^2) when y=0)"],
            "calibration": ["CALIBRATION", "RPNValue", 1, "strength multiplier"],
            "edge_effects": ["EDGE EFFECTS", "RPNBoolean", "0", "include edge effects?"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "steering": ["STEERING", "RPNBoolean", "1", "use for steering?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "lerad": ["LERAD", "RPNValue", 0, "if L=0, use this length for radiation computations"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "HMON": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "weight": ["WEIGHT", "RPNValue", 1, "weight in correction"],
            "tilt": ["TILT", "RPNValue", 0, "rotation about longitudinal axis"],
            "calibration": ["CALIBRATION", "RPNValue", 1, "calibration factor for readout"],
            "setpoint": ["SETPOINT [M]", "RPNValue", 0, "steering setpoint"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "readout": ["READOUT", "OptionalString", "", "rpn expression for readout (actual position supplied in variable x)"],
            "co_fitpoint": ["CO FITPOINT", "RPNBoolean", "0", "If nonzero, then closed orbit value is placed in variable <name>#<occurrence>.xco"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "IBSCATTER": {
            "name": ["Name", "ValidatedString"],
            "factor": ["FACTOR", "RPNValue", 1, "factor by which to multiply growth rates before using"],
            "do_x": ["DO X", "RPNBoolean", "1", "do x-plane scattering?"],
            "do_y": ["DO Y", "RPNBoolean", "1", "do y-plane scattering?"],
            "do_z": ["DO Z", "RPNBoolean", "1", "do z-plane scattering?"],
            "nslice": ["NSLICE", "RPNValue", 1, "The number of slices per bunch"],
            "smooth": ["SMOOTH", "RPNBoolean", "1", "Use smooth method instead of random numbers?"],
            "force_matched_twiss": ["FORCE MATCHED TWISS", "RPNValue", 0, "Force computations to be done with twiss parameters of the beamline, not the beam."],
            "isring": ["ISRING", "RPNBoolean", "1", "Is it storage ring?"],
            "interval": ["INTERVAL", "RPNValue", 1, "Interval in passes at which to update output file."],
            "filename": ["FILENAME", "OutputFile", "", "Output filename."],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, then do calculations bunch-by-bunch."],
            "verbose": ["VERBOSE", "RPNBoolean", "0", "If non-zero, then print updates during calculations."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "ILMATRIX": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "Length (used for position and time-of-flight computation)"],
            "nux": ["NUX", "RPNValue", 0, "Horizontal tune"],
            "nuy": ["NUY", "RPNValue", 0, "Vertical tune"],
            "nux1m": ["NUX1M", "RPNValue", 0, "First chromatic derivative of the horizontal tune"],
            "nuy1m": ["NUY1M", "RPNValue", 0, "First chromatic derivative of the vertical tune"],
            "nux2m": ["NUX2M", "RPNValue", 0, "Second chromatic derivative of the horizontal tune"],
            "nuy2m": ["NUY2M", "RPNValue", 0, "Second chromatic derivative of the vertical tune"],
            "nux3m": ["NUX3M", "RPNValue", 0, "Third chromatic derivative of the horizontal tune"],
            "nuy3m": ["NUY3M", "RPNValue", 0, "Third chromatic derivative of the vertical tune"],
            "nux1ax": ["NUX1AX", "RPNValue", 0, "First amplitude derivative of the horizontal tune wrt Ax"],
            "nuy1ax": ["NUY1AX", "RPNValue", 0, "First amplitude derivative of the vertical tune wrt Ax"],
            "nux1ay": ["NUX1AY", "RPNValue", 0, "First amplitude derivative of the horizontal tune wrt Ay"],
            "nuy1ay": ["NUY1AY", "RPNValue", 0, "First amplitude derivative of the vertical tune wrt Ay"],
            "nux2ax": ["NUX2AX [1∕M²]", "RPNValue", 0, "Second amplitude derivative of the horizontal tune wrt Ax"],
            "nuy2ax": ["NUY2AX [1∕M²]", "RPNValue", 0, "Second amplitude derivative of the vertical tune wrt Ax"],
            "nux2ay": ["NUX2AY [1∕M²]", "RPNValue", 0, "Second amplitude derivative of the horizontal tune wrt Ay"],
            "nuy2ay": ["NUY2AY [1∕M²]", "RPNValue", 0, "Second amplitude derivative of the vertical tune wrt Ay"],
            "nux1ax1ay": ["NUX1AX1AY 1∕M²", "RPNValue", 0, "Amplitude derivative of the horizontal tune wrt Ax and Ay"],
            "nuy1ax1ay": ["NUY1AX1AY 1∕M²", "RPNValue", 0, "Amplitude derivative of the vertical tune wrt Ax and Ay"],
            "betax": ["BETAX [M]", "RPNValue", 0, "On-momentum horizontal beta function"],
            "betay": ["BETAY [M]", "RPNValue", 0, "On-momentum vertical beta function"],
            "betax1m": ["BETAX1M [M]", "RPNValue", 0, "First chromatic derivative of horizontal beta function"],
            "betay1m": ["BETAY1M [M]", "RPNValue", 0, "First chromatic derivative of vertical beta function"],
            "alphax": ["ALPHAX", "RPNValue", 0, "On-momentum horizontal alpha function"],
            "alphay": ["ALPHAY", "RPNValue", 0, "On-momentum vertical alpha function"],
            "alphax1m": ["ALPHAX1M", "RPNValue", 0, "First chromatic derivative of horizontal alpha function"],
            "alphay1m": ["ALPHAY1M", "RPNValue", 0, "First chromatic derivative of vertical alpha function"],
            "etax": ["ETAX [M]", "RPNValue", 0, "On-momentum horizontal eta function"],
            "etapx": ["ETAPX [M]", "RPNValue", 0, "On-momentum horizontal eta' function"],
            "etay": ["ETAY [M]", "RPNValue", 0, "On-momentum vertical eta function"],
            "etapy": ["ETAPY [M]", "RPNValue", 0, "On-momentum vertical eta' function"],
            "etax1": ["ETAX1 [M]", "RPNValue", 0, "First chromatic derivative of horizontal eta function"],
            "etapx1": ["ETAPX1 [M]", "RPNValue", 0, "First chromatic derivative of horizontal eta' function"],
            "etay1": ["ETAY1 [M]", "RPNValue", 0, "First chromatic derivative of vertical eta function"],
            "etapy1": ["ETAPY1 [M]", "RPNValue", 0, "First chromatic derivative of vertical eta' function"],
            "alphac": ["ALPHAC", "RPNValue", 0, "First-order momentum compaction factor"],
            "alphac2": ["ALPHAC2", "RPNValue", 0, "Second-order momentum compaction factor"],
            "alphac3": ["ALPHAC3", "RPNValue", 0, "Third-order momentum compaction factor"],
            "ds1ax": ["DS1AX", "RPNValue", 0, "First amplitude derivative of the path length wrt Ax"],
            "ds1ay": ["DS1AY", "RPNValue", 0, "First amplitude derivative of the path length wrt Ay"],
            "ds2ax": ["DS2AX [1∕M]", "RPNValue", 0, "Second amplitude derivative of the path length wrt Ax"],
            "ds2ay": ["DS2AY [1∕M]", "RPNValue", 0, "Second amplitude derivative of the path length wrt Ay"],
            "ds1ax1ay": ["DS1AX1AY [1∕M]", "RPNValue", 0, "Amplitude derivative of the path length wrt Ax and Ay"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "Rotation angle about the longitudinal axis."],
            "cross_resonance": ["CROSS RESONANCE", "RPNValue", 0, "If zero, then particles that cross an integer or half-integer resonance are considered lost."],
            "verbosity": ["VERBOSITY", "RPNBoolean", "0", "If nonzero, then information about particle losses is printed out."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "IONEFFECTS": {
            "name": ["Name", "ValidatedString"],
            "disable": ["DISABLE", "RPNBoolean", "0", "If non-zero, turn off ion effects in the region covered by this element."],
            "macro_ions": ["MACRO IONS", "Integer", 0, "If positive, overrides the default value set in the ion_effects command, giving the number of macro ions generated per bunch passage."],
            "generation_interval": ["GENERATION INTERVAL", "Integer", 0, "If positive, overrides the default value set in the ion_effects command, giving the number of macro ions generated per bunch passage."],
            "x_span": ["X SPAN", "RPNValue", 0, "If positive, gives the region over which ions are kept."],
            "y_span": ["Y SPAN", "RPNValue", 0, "If positive, gives the region over which ions are kept."],
            "x_bin_divisor": ["X BIN DIVISOR", "RPNValue", 0, "If positive, gives the ratio of electron beam sigma to bin size for ion field calculation."],
            "y_bin_divisor": ["Y BIN DIVISOR", "RPNValue", 0, "If positive, gives the ratio of electron beam sigma to bin size for ion field calculation."],
            "x_range_multiplier": ["X RANGE MULTIPLIER", "RPNValue", 0, "If positive, gives the ratio of ion binning region size to ion 80% x range."],
            "y_range_multiplier": ["Y RANGE MULTIPLIER", "RPNValue", 0, "If positive, gives the ratio of ion binning region size to ion 80% y range."],
            "x_sigma_limit_multiplier": ["X SIGMA LIMIT MULTIPLIER", "RPNValue", 0, "If positive, gives lower limit on bi-gaussian fit sigma values in units of the ion bin size."],
            "y_sigma_limit_multiplier": ["Y SIGMA LIMIT MULTIPLIER", "RPNValue", 0, "If positive, gives lower limit on bi-gaussian fit sigma values in units of the ion bin size."],
            "startpass": ["STARTPASS", "Integer", 0, "If positive, gives the pass on which ion effects start."],
            "endpass": ["ENDPASS", "Integer", -1, "If positive, gives the pass on which ion effects end."],
            "passinterval": ["PASSINTERVAL", "Integer", 1, "Interval between ion effects modeling."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "KICKER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "hkick": ["HKICK [RAD]", "RPNValue", 0, "x kick angle"],
            "vkick": ["VKICK [RAD]", "RPNValue", 0, "y kick angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "b2": ["B2 [1/M²]", "RPNValue", 0, "normalized sextupole strength (e.g., kick = KICK*(1+B2*x^2))"],
            "hcalibration": ["HCALIBRATION", "RPNValue", 1, "factor applied to obtain x kick"],
            "vcalibration": ["VCALIBRATION", "RPNValue", 1, "factor applied to obtain y kick"],
            "edge_effects": ["EDGE EFFECTS", "RPNBoolean", "0", "include edge effects?"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "steering": ["STEERING", "RPNBoolean", "1", "use for steering?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "lerad": ["LERAD", "RPNValue", 0, "if L=0, use this length for radiation computations"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "KOCT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "k3": ["K3 [1/M⁴]", "RPNValue", 0, "geometric strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "bore": ["BORE [M]", "RPNValue", 0, "bore radius"],
            "b": ["B [T]", "RPNValue", 0, "field at pole tip (used if bore nonzero)"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "n_kicks": ["N KICKS", "RPNValue", 4, "number of kicks"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "systematic_multipoles": ["SYSTEMATIC MULTIPOLES", "InputFile", "", "input file for systematic multi-poles"],
            "random_multipoles": ["RANDOM MULTIPOLES", "InputFile", "", "input file for random multi-poles"],
            "integration_order": ["INTEGRATION ORDER", "RPNValue", 4, "integration order (2 or 4)"],
            "sqrt_order": ["SQRT ORDER", "RPNValue", 0, "Order of expansion of square-root in Hamiltonian. 0 means no expansion."],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "isr1part": ["ISR1PART", "RPNValue", 1, "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "expand_hamiltonian": ["EXPAND HAMILTONIAN", "RPNBoolean", "0", "If 1, Hamiltonian is expanded to leading order."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "KPOLY": {
            "name": ["Name", "ValidatedString"],
            "coefficient": ["COEFFICIENT [M-ORDER]", "RPNValue", 0, "coefficient of polynomial"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "factor": ["FACTOR", "RPNValue", 1, "additional factor to apply"],
            "order": ["ORDER", "RPNValue", 0, "order of polynomial"],
            "plane": ["PLANE", "OptionalString", "x", "plane to kick (x, y)"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "KQUAD": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "bore": ["BORE [M]", "RPNValue", 0, "bore radius"],
            "b": ["B [T]", "RPNValue", 0, "pole tip field (used if bore nonzero)"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "hkick": ["HKICK [RAD]", "RPNValue", 0, "horizontal correction kick"],
            "vkick": ["VKICK [RAD]", "RPNValue", 0, "vertical correction kick"],
            "hcalibration": ["HCALIBRATION", "RPNValue", 1, "calibration factor for horizontal correction kick"],
            "vcalibration": ["VCALIBRATION", "RPNValue", 1, "calibration factor for vertical correction kick"],
            "hsteering": ["HSTEERING", "RPNBoolean", "0", "use for horizontal correction?"],
            "vsteering": ["VSTEERING", "RPNBoolean", "0", "use for vertical correction?"],
            "n_kicks": ["N KICKS", "RPNValue", 4, "number of kicks"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "systematic_multipoles": ["SYSTEMATIC MULTIPOLES", "InputFile", "", "input file for systematic multi-poles"],
            "edge_multipoles": ["EDGE MULTIPOLES", "InputFile", "", "input file for systematic edge multipoles"],
            "random_multipoles": ["RANDOM MULTIPOLES", "InputFile", "", "input file for random multi-poles"],
            "steering_multipoles": ["STEERING MULTIPOLES", "InputFile", "", "input file for multipole content of steering kicks"],
            "systematic_multipole_factor": ["SYSTEMATIC MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply systematic and edge multipoles"],
            "random_multipole_factor": ["RANDOM MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply random multipoles"],
            "steering_multipole_factor": ["STEERING MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply steering multipoles"],
            "min_normal_order": ["MIN NORMAL ORDER", "Integer", -1, "If nonnegative, minimum order of systematic and random normal multipoles to use from data files."],
            "min_skew_order": ["MIN SKEW ORDER", "Integer", -1, "If nonnegative, minimum order of systematic and random skew multipoles to use from data files."],
            "max_normal_order": ["MAX NORMAL ORDER", "Integer", -1, "If nonnegative, maximum order of systematic and random normal multipoles to use from data files."],
            "max_skew_order": ["MAX SKEW ORDER", "Integer", -1, "If nonnegative, maximum order of systematic and random skew multipoles to use from data files."],
            "integration_order": ["INTEGRATION ORDER", "RPNValue", 4, "integration order (2 or 4)"],
            "sqrt_order": ["SQRT ORDER", "RPNValue", 0, "Order of expansion of square-root in Hamiltonian. 0 means no expansion."],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "isr1part": ["ISR1PART", "RPNValue", 1, "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "edge1_effects": ["EDGE1 EFFECTS", "RPNBoolean", "0", "include entrance edge effects?"],
            "edge2_effects": ["EDGE2 EFFECTS", "RPNBoolean", "0", "include exit edge effects?"],
            "leffective": ["LEFFECTIVE [M]", "RPNValue", 0, "Effective length. Ignored if non-positive."],
            "i0p": ["I0P [M]", "RPNValue", 0, "i0+ fringe integral"],
            "i1p": ["I1P [M²]", "RPNValue", 0, "i1+ fringe integral"],
            "i2p": ["I2P [M³]", "RPNValue", 0, "i2+ fringe integral"],
            "i3p": ["I3P [M⁴]", "RPNValue", 0, "i3+ fringe integral"],
            "lambda2p": ["LAMBDA2P [M³]", "RPNValue", 0, "lambda2+ fringe integral"],
            "i0m": ["I0M [M]", "RPNValue", 0, "i0-fringe integral"],
            "i1m": ["I1M [M²]", "RPNValue", 0, "i1-fringe integral"],
            "i2m": ["I2M [M³]", "RPNValue", 0, "i2-fringe integral"],
            "i3m": ["I3M [M⁴]", "RPNValue", 0, "i3-fringe integral"],
            "lambda2m": ["LAMBDA2M [M³]", "RPNValue", 0, "lambda2-fringe integral"],
            "edge1_linear": ["EDGE1 LINEAR", "RPNBoolean", "1", "Use to selectively turn off linear part if EDGE1_EFFECTS nonzero."],
            "edge2_linear": ["EDGE2 LINEAR", "RPNBoolean", "1", "Use to selectively turn off linear part if EDGE2_EFFECTS nonzero."],
            "edge1_nonlinear_factor": ["EDGE1 NONLINEAR FACTOR", "RPNBoolean", "1", "Use to selectively scale nonlinear entrance edge effects if EDGE1_EFFECTS>1"],
            "edge2_nonlinear_factor": ["EDGE2 NONLINEAR FACTOR", "RPNBoolean", "1", "Use to selectively scale nonlinear exit edge effects if EDGE2_EFFECTS>1"],
            "radial": ["RADIAL", "RPNBoolean", "0", "If non-zero, converts the quadrupole into a radially-focusing lens"],
            "expand_hamiltonian": ["EXPAND HAMILTONIAN", "RPNBoolean", "0", "If 1, Hamiltonian is expanded to leading order."],
            "tracking_matrix": ["TRACKING MATRIX", "Integer", 0, "If nonzero, gives order of tracking-based matrix up to third order to be used for twiss parameters etc. If zero, 2nd-order analytical matrix is used."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "KQUSE": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric quadrupole strength"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric sextupole strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse1": ["FSE1 [M]", "RPNValue", 0, "fractional strength error for K1"],
            "fse2": ["FSE2 [M]", "RPNValue", 0, "fractional strength error for K2"],
            "n_kicks": ["N KICKS", "RPNValue", 4, "number of kicks"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "integration_order": ["INTEGRATION ORDER", "RPNValue", 4, "integration order (2 or 4)"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "isr1part": ["ISR1PART", "RPNValue", 1, "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "matrix_tracking": ["MATRIX TRACKING", "RPNValue", 0, "For testing only."],
            "expand_hamiltonian": ["EXPAND HAMILTONIAN", "RPNBoolean", "0", "If 1, Hamiltonian is expanded to leading order."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "KSBEND": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "arc length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bend angle"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric quadrupole strength"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric sextupole strength"],
            "k3": ["K3 [1/M⁴]", "RPNValue", 0, "geometric octupole strength"],
            "k4": ["K4 [1/M⁵]", "RPNValue", 0, "geometric decapole strength"],
            "e1": ["E1 [RAD]", "RPNValue", 0, "entrance edge angle"],
            "e2": ["E2 [RAD]", "RPNValue", 0, "exit edge angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "h1": ["H1 [1/M]", "RPNValue", 0, "entrance pole-face curvature"],
            "h2": ["H2 [1/M]", "RPNValue", 0, "exit pole-face curvature"],
            "hgap": ["HGAP [M]", "RPNValue", 0, "half-gap between poles"],
            "fint": ["FINT", "RPNValue", 0.5, "edge-field integral"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "error rotation about incoming longitudinal axis"],
            "n_kicks": ["N KICKS", "RPNValue", 4, "number of kicks"],
            "nonlinear": ["NONLINEAR", "RPNBoolean", "1", "include nonlinear field components?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "edge1_effects": ["EDGE1 EFFECTS", "RPNBoolean", "1", "include entrance edge effects?"],
            "edge2_effects": ["EDGE2 EFFECTS", "RPNBoolean", "1", "include exit edge effects?"],
            "edge_order": ["EDGE ORDER", "RPNValue", 1, "edge matrix order"],
            "paraxial": ["PARAXIAL", "RPNBoolean", "0", "use paraxial approximation?"],
            "transport": ["TRANSPORT", "RPNBoolean", "0", "use (incorrect) TRANSPORT equations for T436 of edge?"],
            "method": ["METHOD", "KsbendMethod", "modified-midpoint", "integration method"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "KSEXT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric strength"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric quadrupole strength error."],
            "j1": ["J1 [1∕M²]", "RPNValue", 0, "geometric skew quadrupole strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "bore": ["BORE [M]", "RPNValue", 0, "bore radius"],
            "b": ["B [T]", "RPNValue", 0, "field at pole tip (used if bore nonzero)"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "hkick": ["HKICK [RAD]", "RPNValue", 0, "horizontal correction kick"],
            "vkick": ["VKICK [RAD]", "RPNValue", 0, "vertical correction kick"],
            "hcalibration": ["HCALIBRATION", "RPNValue", 1, "calibration factor for horizontal correction kick"],
            "vcalibration": ["VCALIBRATION", "RPNValue", 1, "calibration factor for vertical correction kick"],
            "hsteering": ["HSTEERING", "RPNBoolean", "0", "use for horizontal correction?"],
            "vsteering": ["VSTEERING", "RPNBoolean", "0", "use for vertical correction?"],
            "n_kicks": ["N KICKS", "RPNValue", 4, "number of kicks"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "systematic_multipoles": ["SYSTEMATIC MULTIPOLES", "InputFile", "", "input file for systematic multi-poles"],
            "edge_multipoles": ["EDGE MULTIPOLES", "InputFile", "", "input file for systematic edge multipoles"],
            "random_multipoles": ["RANDOM MULTIPOLES", "InputFile", "", "input file for random multi-poles"],
            "steering_multipoles": ["STEERING MULTIPOLES", "InputFile", "", "input file for multipole content of steering kicks"],
            "systematic_multipole_factor": ["SYSTEMATIC MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply systematic and edge multipoles"],
            "random_multipole_factor": ["RANDOM MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply random multipoles"],
            "steering_multipole_factor": ["STEERING MULTIPOLE FACTOR", "RPNValue", 1, "Factor by which to multiply steering multipoles"],
            "min_normal_order": ["MIN NORMAL ORDER", "Integer", -1, "If nonnegative, minimum order of systematic and random normal multipoles to use from data files."],
            "min_skew_order": ["MIN SKEW ORDER", "Integer", -1, "If nonnegative, minimum order of systematic and random skew multipoles to use from data files."],
            "max_normal_order": ["MAX NORMAL ORDER", "Integer", -1, "If nonnegative, maximum order of systematic and random normal multipoles to use from data files."],
            "max_skew_order": ["MAX SKEW ORDER", "Integer", -1, "If nonnegative, maximum order of systematic and random skew multipoles to use from data files."],
            "integration_order": ["INTEGRATION ORDER", "RPNValue", 4, "integration order (2 or 4)"],
            "sqrt_order": ["SQRT ORDER", "RPNValue", 0, "Order of expansion of square-root in Hamiltonian. 0 means no expansion."],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "isr1part": ["ISR1PART", "RPNValue", 1, "Include ISR for single-particle beam only if ISR=1 and ISR1PART=1"],
            "expand_hamiltonian": ["EXPAND HAMILTONIAN", "RPNBoolean", "0", "If 1, Hamiltonian is expanded to leading order."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "LMIRROR": {
            "name": ["Name", "ValidatedString"],
            "rx": ["RX [M]", "RPNValue", 0, "radius in horizontal plane"],
            "ry": ["RY [M]", "RPNValue", 0, "radius in vertical plane"],
            "theta": ["THETA [RAD]", "RPNValue", 0, "angle of incidence (in horizontal plane)"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "misalignment rotation about longitudinal axis"],
            "yaw": ["YAW [RAD]", "RPNValue", 0, "misalignment rotation about vertical axis"],
            "pitch": ["PITCH [RAD]", "RPNValue", 0, "misalignment rotation about transverse horizontal axis"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "LRWAKE": {
            "name": ["Name", "ValidatedString"],
            "inputfile": ["INPUTFILE", "InputFile", "", "name of file giving Green function"],
            "tcolumn": ["TCOLUMN", "OptionalString", "", "column in INPUTFILE containing time data"],
            "wxcolumn": ["WXCOLUMN", "OptionalString", "", "column in INPUTFILE containing longitudinal Green function"],
            "wycolumn": ["WYCOLUMN", "OptionalString", "", "column in INPUTFILE containing horizontal Green function"],
            "wzcolumn": ["WZCOLUMN", "OptionalString", "", "column in INPUTFILE containing vertical Green function"],
            "qxcolumn": ["QXCOLUMN", "OptionalString", "", "column in INPUTFILE containing horizontal quadrupole Green function"],
            "qycolumn": ["QYCOLUMN", "OptionalString", "", "column in INPUTFILE containing vertical quadrupole Green function"],
            "factor": ["FACTOR", "RPNValue", 1, "factor to multiply wakes by"],
            "xfactor": ["XFACTOR", "RPNValue", 1, "factor by which to multiply longitudinal"],
            "yfactor": ["YFACTOR", "RPNValue", 1, "factor by which to multiply horizontal"],
            "zfactor": ["ZFACTOR", "RPNValue", 1, "factor by which to multiply vertical"],
            "qxfactor": ["QXFACTOR", "RPNValue", 1, "factor by which to multiply horizontal quadrupole wake"],
            "qyfactor": ["QYFACTOR", "RPNValue", 1, "factor by which to multiply vertical quadrupole wake"],
            "turns_to_keep": ["TURNS TO KEEP", "RPNValue", 128, "number of turns of data to retain"],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the wake to full strength."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "LSCDRIFT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "leffective": ["LEFFECTIVE [M]", "RPNValue", 0, "effective length (used if L=0)"],
            "bins": ["BINS", "RPNValue", 0, "number of bins for current histogram"],
            "smoothing": ["SMOOTHING", "RPNBoolean", "0", "Use Savitzky-Golay filter to smooth current histogram?"],
            "sg_halfwidth": ["SG HALFWIDTH", "RPNValue", 1, "Savitzky-Golay filter half-width for smoothing current histogram"],
            "sg_order": ["SG ORDER", "RPNValue", 1, "Savitzky-Golay filter order for smoothing current histogram"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "1", "Interpolate wake?"],
            "low_frequency_cutoff0": ["LOW FREQUENCY CUTOFF0", "RPNValue", -1, "Highest spatial frequency at which low-frequency cutoff filter is zero. If not positive, no low-frequency cutoff filter is applied. Frequency is in units of Nyquist (0.5/binsize)."],
            "low_frequency_cutoff1": ["LOW FREQUENCY CUTOFF1", "RPNValue", -1, "Lowest spatial frequency at which low-frequency cutoff filter is 1. If not given, defaults to LOW FREQUENCY CUTOFF1."],
            "high_frequency_cutoff0": ["HIGH FREQUENCY CUTOFF0", "RPNValue", -1, "Spatial frequency at which smoothing filter begins. If not positive, no frequency filter smoothing is done. Frequency is in units of Nyquist (0.5/binsize)."],
            "high_frequency_cutoff1": ["HIGH FREQUENCY CUTOFF1", "RPNValue", -1, "Spatial frequency at which smoothing filter is 0. If not given, defaults to HIGH FREQUENCY CUTOFF0."],
            "radius_factor": ["RADIUS FACTOR", "RPNValue", 1.7, "LSC radius is (Sx+Sy)/2*RADIUS FACTOR"],
            "lsc": ["LSC", "RPNValue", 1, "Include longitudinal space-charge impedance? If zero, acts like ordinary drift."],
            "auto_leffective": ["AUTO LEFFECTIVE", "RPNBoolean", "0", "In nonzero and if L=0, the LEFFECTIVE parameter is set to the length of the previous element."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "LSRMDLTR": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "bu": ["BU [T]", "RPNValue", 0, "Undulator peak field"],
            "tgu_gradient": ["TGU GRADIENT [1∕M]", "RPNValue", 0, "Transverse gradient divided by maximum on-axis field."],
            "tgu_comp_factor": ["TGU COMP FACTOR", "RPNValue", 1, "Use to adjust constant field component to reduce trajectory error."],
            "periods": ["PERIODS", "RPNValue", 0, "Number of undulator periods."],
            "method": ["METHOD", "LsmdltrMethod", "non-adaptive runge-kutta", "integration method"],
            "field_expansion": ["FIELD EXPANSION", "LsrmdltrFieldExpansion", "leading terms", ""],
            "accuracy": ["ACCURACY", "RPNValue", 0, "Integration accuracy for adaptive integration. (Not recommended)"],
            "n_steps": ["N STEPS", "RPNValue", 0, "Number of integration steps for non-adaptive integration."],
            "pole_factor1": ["POLE FACTOR1", "RPNValue", 0.1557150345504, "Strength factor for the first and last pole."],
            "pole_factor2": ["POLE FACTOR2", "RPNValue", 0.380687012288581, "Strength factor for the second and second-to-last pole."],
            "pole_factor3": ["POLE FACTOR3", "RPNValue", 0.802829337348179, "Strength factor for the third and third-to-last pole."],
            "laser_wavelength": ["LASER WAVELENGTH [M]", "RPNValue", 0, "Laser wavelength. If zero, the wavelength is calculated from the resonance condition."],
            "laser_peak_power": ["LASER PEAK POWER [W]", "RPNValue", 0, "laser peak power"],
            "laser_w0": ["LASER W0 [M]", "RPNValue", 1, "laser spot size at waist, w0 = √2σx = √2σy"],
            "laser_phase": ["LASER PHASE [RAD]", "RPNValue", 0, "laser phase"],
            "laser_x0": ["LASER X0 [M]", "RPNValue", 0, "laser horizontal offset at center of wiggler"],
            "laser_y0": ["LASER Y0 [M]", "RPNValue", 0, "laser vertical offset at center of wiggler"],
            "laser_z0": ["LASER Z0 [M]", "RPNValue", 0, "offset of waist position from center of wiggler"],
            "laser_tilt": ["LASER TILT [RAD]", "RPNValue", 0, "laser tilt"],
            "laser_m": ["LASER M", "RPNValue", 0, "laser horizontal mode number (<5)"],
            "laser_n": ["LASER N", "RPNValue", 0, "laser vertical mode number (<5)"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "Include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "Include quantum excitation?"],
            "helical": ["HELICAL", "RPNBoolean", "0", "If non-zero, simulate helical undulator."],
            "time_profile": ["TIME PROFILE", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving time-dependent modulation of the laser electric and magnetic fields."],
            "time_profileX": ["X", "String", ""],
            "time_profileY": ["Y", "String", ""],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "Time offset of the laser profile."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "LTHINLENS": {
            "name": ["Name", "ValidatedString"],
            "fx": ["FX [M]", "RPNValue", 0, "focal length in horizontal plane"],
            "fy": ["FY [M]", "RPNValue", 0, "focal length in vertical plane"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "misalignment rotation about longitudinal axis"],
            "yaw": ["YAW [RAD]", "RPNValue", 0, "misalignment rotation about vertical axis"],
            "pitch": ["PITCH [RAD]", "RPNValue", 0, "misalignment rotation about transverse horizontal axis"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MAGNIFY": {
            "name": ["Name", "ValidatedString"],
            "mx": ["MX", "RPNValue", 1, "factor for x coordinates"],
            "mxp": ["MXP", "RPNValue", 1, "factor for x' coordinates"],
            "my": ["MY", "RPNValue", 1, "factor for y coordinates"],
            "myp": ["MYP", "RPNValue", 1, "factor for y' coordinates"],
            "ms": ["MS", "RPNValue", 1, "factor for s coordinates"],
            "mdp": ["MDP", "RPNValue", 1, "factor for (ppCentral)/pCentral"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MALIGN": {
            "name": ["Name", "ValidatedString"],
            "dxp": ["DXP", "RPNValue", 0, "delta x'"],
            "dyp": ["DYP", "RPNValue", 0, "delta y'"],
            "dx": ["DX [M]", "RPNValue", 0, "delta x"],
            "dy": ["DY [M]", "RPNValue", 0, "delta y"],
            "dz": ["DZ [M]", "RPNValue", 0, "delta z"],
            "dt": ["DT [S]", "RPNValue", 0, "delta t"],
            "dp": ["DP", "RPNValue", 0, "delta p/pCentral"],
            "de": ["DE", "RPNValue", 0, "delta gamma/gammaCentral"],
            "on_pass": ["ON PASS", "RPNValue", -1, "pass on which to apply"],
            "force_modify_matrix": ["FORCE MODIFY MATRIX", "RPNValue", 0, "modify the matrix even if on pass>=0"],
            "start_pid": ["START PID", "RPNValue", -1, "starting particleID for particles to affect. By default, all particles are affected."],
            "end_pid": ["END PID", "RPNValue", -1, "ending particleID for particles to affect. By default, all particles are affected."],
            "floor": ["FLOOR", "RPNBoolean", "0", "if non-zero, floor coordinates are changed, which is probably a bad idea"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MAPSOLENOID": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "misalignment"],
            "eyaw": ["EYAW [RAD]", "RPNValue", 0, "misalignment"],
            "epitch": ["EPITCH [RAD]", "RPNValue", 0, "misalignment"],
            "n_steps": ["N STEPS", "RPNValue", 100, "number of steps (for nonadaptive integration)"],
            "inputfile": ["INPUTFILE", "InputFile", "", "SDDS file containing (Br, Bz) vs (r, z). Each page should have values for a fixed r."],
            "rcolumn": ["RCOLUMN", "OptionalString", "", "column containing r values"],
            "zcolumn": ["ZCOLUMN", "OptionalString", "", "column containing z values"],
            "brcolumn": ["BRCOLUMN", "OptionalString", "", "column containing Br values"],
            "bzcolumn": ["BZCOLUMN", "OptionalString", "", "column containing Bz values"],
            "factor": ["FACTOR", "RPNValue", 0.0001, "factor by which to multiply fields in file"],
            "bxuniform": ["BXUNIFORM", "RPNValue", 0, "uniform horizontal field to superimpose on solenoid field"],
            "byuniform": ["BYUNIFORM", "RPNValue", 0, "uniform vertical field to superimpose on solenoid field"],
            "luniform": ["LUNIFORM", "RPNValue", 0, "length of uniform field superimposed on solenoid field"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy"],
            "method": ["METHOD", "MapsolenoidMethod", "runge-kutta", "integration method"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MARK": {
            "name": ["Name", "ValidatedString"],
            "dx": ["DX [M]", "RPNValue", 0, "non-functional misalignment (e.g., for girder)"],
            "dy": ["DY [M]", "RPNValue", 0, "non-functional misalignment (e.g., for girder)"],
            "fitpoint": ["FITPOINT", "RPNBoolean", "0", "Supply local values of Twiss parameters, moments, floor coordinates, matrices, etc. for optimization?"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MATR": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "fraction": ["FRACTION", "RPNValue", 1, "The provided matrix M is interpolated with the identity matrix I according to f*M+(1-f)*I."],
            "filename": ["FILENAME", "InputFile", "", "input file"],
            "order": ["ORDER", "RPNValue", 1, "matrix order"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MATTER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "leffective": ["LEFFECTIVE [M]", "RPNValue", 0, "effective length (used if L=0)"],
            "xo": ["XO [M]", "RPNValue", 0, "radiation length"],
            "energy_decay": ["ENERGY DECAY", "RPNBoolean", "0", "If nonzero, then particles will lose energy due to material using a simple exponential model."],
            "energy_straggle": ["ENERGY STRAGGLE", "RPNBoolean", "0", "Use simple-minded energy straggling model coupled with ENERGY DECAY=1?"],
            "nuclear_bremsstrahlung": ["NUCLEAR BREMSSTRAHLUNG", "RPNValue", 0, "Model energy loss to nuclear bremsstrahlung? If enabled, set ENERGY DECAY=0 to disable simpler model."],
            "electron_recoil": ["ELECTRON RECOIL", "RPNBoolean", "0", "If non-zero, electron recoil during Coulomb scattering is included (results in energy change)."],
            "z": ["Z", "RPNValue", 0, "Atomic number"],
            "a": ["A [AMU]", "RPNValue", 0, "Atomic mass"],
            "rho": ["RHO [KG/M³]", "RPNValue", 0, "Density"],
            "pressure": ["PRESSURE [PASCAL]", "RPNValue", 0, "Pressure. Used with temperature and atomic mass to compute density for ideal gas."],
            "temperature": ["TEMPERATURE [K]", "RPNValue", 0, "Temperature. Used with pressure and atomic mass to compute density for ideal gas."],
            "multiplicity": ["MULTIPLICITY", "Integer", 1, "Atoms per gas molecule."],
            "plimit": ["PLIMIT", "RPNValue", 0.05, "Probability cutoff for each slice"],
            "width": ["WIDTH [M]", "RPNValue", 0, "Full width of slots. If 0, no slots are present."],
            "spacing": ["SPACING [M]", "RPNValue", 0, "Center-to-center spacing of slots. If 0, no slots are present."],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "Tilt of slot array about the longitudinal axis."],
            "center": ["CENTER [M]", "RPNValue", 0, "Position of center of slot array in rotated frame."],
            "n_slots": ["N SLOTS", "RPNValue", 0, "Number of empty slots in material. If <=0, an infinite array is assumed."],
            "start_pass": ["START PASS", "Integer", -1, "If non-negative, pass on which to start interaction with beam."],
            "end_pass": ["END PASS", "Integer", -1, "If non-negative, pass on which to end interaction with beam."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MAXAMP": {
            "name": ["Name", "ValidatedString"],
            "x_max": ["X MAX [M]", "RPNValue", 0, "x half-aperture"],
            "y_max": ["Y MAX [M]", "RPNValue", 0, "y half-aperture"],
            "elliptical": ["ELLIPTICAL", "RPNBoolean", "0", "is aperture elliptical?"],
            "exponent": ["EXPONENT", "RPNValue", 2, "exponent for boundary equation in elliptical mode. 2 is a true ellipse."],
            "yexponent": ["YEXPONENT", "RPNValue", 0, "yexponent for boundary equation in elliptical mode. If zero, defaults to EXPONENT."],
            "open_side": ["OPEN SIDE", "OpenSide", "", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MBUMPER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "strength": ["STRENGTH", "RPNValue", 0, "geometric strength in 1/m^order"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "time offset of waveform"],
            "order": ["ORDER", "RPNValue", 0, "multipole order, where 1 is quadrupole, 2 is sextupole, etc."],
            "periodic": ["PERIODIC", "RPNBoolean", "0", "is waveform periodic?"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "fire_on_pass": ["FIRE ON PASS", "RPNValue", 0, "pass number to fire on"],
            "n_kicks": ["N KICKS", "RPNValue", 0, "Number of kicks to use for simulation."],
            "waveform": ["WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving kick factor vs time"],
            "waveformX": ["X", "String", ""],
            "waveformY": ["Y", "String", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MHISTOGRAM": {
            "name": ["Name", "ValidatedString"],
            "file1d": ["FILE1D", "OutputFile", "", "filename for 1d histogram output, possibly incomplete (see below)"],
            "file2dh": ["FILE2DH", "OutputFile", "", "filename for 2d x-x' histogram output, possibly incomplete (see below)"],
            "file2dv": ["FILE2DV", "OutputFile", "", "filename for 2d y-y' histogram output, possibly incomplete (see below)"],
            "file2dl": ["FILE2DL", "OutputFile", "", "filename for 2d dt-deltaP histogram output, possibly incomplete (see below)"],
            "file4d": ["FILE4D", "OutputFile", "", "filename for 4d x-x'-y-y' histogram output, possibly incomplete (see below)"],
            "file6d": ["FILE6D", "OutputFile", "", "filename for 6d x-x'-y-y'-dtdeltaP histogram output, possibly incomplete (see below)"],
            "input_bins": ["INPUT BINS", "InputFile", "", "Name ofSDDSfile contains input bin number."],
            "interval": ["INTERVAL", "RPNValue", 1, "interval in passes between output."],
            "start_pass": ["START PASS", "RPNValue", 0, "starting pass for output"],
            "normalize": ["NORMALIZE", "RPNBoolean", "1", "normalize histogram with number of particles?"],
            "disable": ["DISABLE", "RPNBoolean", "0", "If nonzero, no output will be generated."],
            "lumped": ["LUMPED", "RPNBoolean", "0", "If nonzero, then results at elements with same name will be output to a single multipage SDDS file."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MODRF": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "volt": ["VOLT [V]", "RPNValue", 0, "nominal voltage"],
            "phase": ["PHASE [DEG]", "RPNValue", 0, "nominal phase"],
            "freq": ["FREQ [Hz]", "RPNValue", 500000000, "nominal frequency"],
            "q": ["Q", "RPNValue", 0, "cavity Q"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "ammag": ["AMMAG", "RPNValue", 0, "magnitude of amplitude modulation (fraction value)"],
            "amphase": ["AMPHASE [DEG]", "RPNValue", 0, "phase of amplitude modulation"],
            "amfreq": ["AMFREQ [Hz]", "RPNValue", 0, "frequency of amplitude modulation"],
            "amdecay": ["AMDECAY [1/s]", "RPNValue", 0, "exponential decay rate of amplitude modulation"],
            "pmmag": ["PMMAG [DEG]", "RPNValue", 0, "magnitude of phase modulation"],
            "pmphase": ["PMPHASE [DEG]", "RPNValue", 0, "phase of phase modulation"],
            "pmfreq": ["PMFREQ [Hz]", "RPNValue", 0, "frequency of phase modulation"],
            "pmdecay": ["PMDECAY [1/s]", "RPNValue", 0, "exponential decay rate of phase modulation"],
            "fiducial": ["FIDUCIAL", "Fiducial", "", "mode for determining fiducial arrival time"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MONI": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "weight": ["WEIGHT", "RPNValue", 1, "weight in correction"],
            "tilt": ["TILT", "RPNValue", 0, "rotation about longitudinal axis"],
            "xcalibration": ["XCALIBRATION", "RPNValue", 1, "calibration factor for x readout"],
            "ycalibration": ["YCALIBRATION", "RPNValue", 1, "calibration factor for y readout"],
            "xsetpoint": ["XSETPOINT [M]", "RPNValue", 0, "x steering setpoint"],
            "ysetpoint": ["YSETPOINT [M]", "RPNValue", 0, "y steering setpoint"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "xreadout": ["XREADOUT", "OptionalString", "", "rpn expression for x readout (actual position supplied in variables x, y"],
            "yreadout": ["YREADOUT", "OptionalString", "", "rpn expression for y readout (actual position supplied in variables x, y"],
            "co_fitpoint": ["CO FITPOINT", "RPNBoolean", "0", "If nonzero, then closed orbit values are placed in variables <name>#<occurrence>.xco and <name>#<occurence>.yco"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MRFDF": {
            "name": ["Name", "ValidatedString"],
            "factor": ["FACTOR", "RPNValue", 1, "A factor to multiple all components with."],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "a1": ["A1 [V/m]", "RPNValue", 0, "Vertically-deflecting dipole"],
            "a2": ["A2 [V/m2]", "RPNValue", 0, "Skew quadrupole"],
            "a3": ["A3 [V/m3]", "RPNValue", 0, "Skew sextupole"],
            "a4": ["A4 [V/m4]", "RPNValue", 0, "Skew octupole"],
            "a5": ["A5 [V/m5]", "RPNValue", 0, "Skew decapole"],
            "b1": ["B1 [V/m]", "RPNValue", 0, "Horizontally-deflecting dipole"],
            "b2": ["B2 [V/m2]", "RPNValue", 0, "Normal quadrupole"],
            "b3": ["B3 [V/m3]", "RPNValue", 0, "Normal sextupole"],
            "b4": ["B4 [V/m4]", "RPNValue", 0, "Normal octupole"],
            "b5": ["B5 [V/m5]", "RPNValue", 0, "Normal decapole"],
            "frequency1": ["FREQUENCY1 [HZ]", "RPNValue", 2856000000, "Dipole frequency"],
            "frequency2": ["FREQUENCY2 [HZ]", "RPNValue", 2856000000, "Quadrupole frequency"],
            "frequency3": ["FREQUENCY3 [HZ]", "RPNValue", 2856000000, "Sextupole frequency"],
            "frequency4": ["FREQUENCY4 [HZ]", "RPNValue", 2856000000, "Octupole frequency"],
            "frequency5": ["FREQUENCY5 [HZ]", "RPNValue", 2856000000, "Decapole frequency"],
            "phase1": ["PHASE1 [HZ]", "RPNValue", 0, "Dipole phase"],
            "phase2": ["PHASE2 [HZ]", "RPNValue", 0, "Quadrupole phase"],
            "phase3": ["PHASE3 [HZ]", "RPNValue", 0, "Sextupole phase"],
            "phase4": ["PHASE4 [HZ]", "RPNValue", 0, "Octupole phase"],
            "phase5": ["PHASE5 [HZ]", "RPNValue", 0, "Decapole phase"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "MULT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "knl": ["KNL [M-ORDER]", "RPNValue", 0, "integrated geometric strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "bore": ["BORE [M]", "RPNValue", 0, "bore radius"],
            "btipl": ["BTIPL [TM]", "RPNValue", 0, "integrated field at pole tip, used if BORE nonzero"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "factor": ["FACTOR", "RPNValue", 1, "factor by which to multiply strength"],
            "order": ["ORDER", "RPNValue", 1, "multipole order"],
            "n_kicks": ["N KICKS", "RPNValue", 4, "number of kicks"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "expand_hamiltonian": ["EXPAND HAMILTONIAN", "RPNBoolean", "0", "If 1, Hamiltonian is expanded to leading order."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "NIBEND": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "arc length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bending angle"],
            "e1": ["E1 [RAD]", "RPNValue", 0, "entrance edge angle"],
            "e2": ["E2 [RAD]", "RPNValue", 0, "exit edge angle"],
            "tilt": ["TILT", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fint": ["FINT", "RPNValue", 0.5, "edge-field integral"],
            "hgap": ["HGAP [M]", "RPNValue", 0, "half-gap between poles"],
            "fp1": ["FP1 [M]", "RPNValue", 10, "fringe parameter (tanh model)"],
            "fp2": ["FP2 [M]", "RPNValue", 0, "not used"],
            "fp3": ["FP3 [M]", "RPNValue", 0, "not used"],
            "fp4": ["FP4 [M]", "RPNValue", 0, "not used"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "error rotation about incoming longitudinal axis"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy (for nonadaptive integration, used as the step-size)"],
            "model": ["MODEL", "NibendModel", "linear", "fringe model"],
            "method": ["METHOD", "NibendMethod", "runge-kutta", "integration method"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "adjust_boundary": ["ADJUST BOUNDARY", "RPNValue", 1, "adjust fringe boundary position to make symmetric trajectory? (Not done if ADJUST FIELD is nonzero.)"],
            "adjust_field": ["ADJUST FIELD", "RPNBoolean", "0", "adjust central field strength to make symmetric trajectory?"],
            "fudge_path_length": ["FUDGE PATH LENGTH", "RPNBoolean", "1", "fudge central path length to force it to equal the nominal length L?"],
            "fringe_position": ["FRINGE POSITION", "NibendFringePosition", "0", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "NISEPT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "arc length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bend angle"],
            "e1": ["E1 [RAD]", "RPNValue", 0, "entrance edge angle"],
            "b1": ["B1 [1/M]", "RPNValue", 0, "normalized gradient (K1=B1*L/ANGLE)"],
            "q1ref": ["Q1REF [M]", "RPNValue", 0, "distance from septum at which bending radius is L/ANGLE"],
            "flen": ["FLEN [M]", "RPNValue", 0, "fringe field length"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy"],
            "method": ["METHOD", "NiseptMethod", "runge-kutta", "integration method"],
            "model": ["MODEL", "NiseptModel", "linear", "fringe model"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "OCTU": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "k3": ["K3 [1/M³]", "RPNValue", 0, "geometric strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "PEPPOT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "radii": ["RADII [M]", "RPNValue", 0, "hole radius"],
            "transmission": ["TRANSMISSION", "RPNValue", 0, "transmission of material"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "theta_rms": ["THETA RMS [RAD]", "RPNValue", 0, "rms scattering from material"],
            "n_holes": ["N HOLES", "RPNValue", 0, "number of holes"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "PFILTER": {
            "name": ["Name", "ValidatedString"],
            "deltalimit": ["DELTALIMIT", "RPNValue", -1, "maximum fractional momentum deviation"],
            "lowerfraction": ["LOWERFRACTION", "RPNValue", 0, "fraction of lowest-momentum particles to remove"],
            "upperfraction": ["UPPERFRACTION", "RPNValue", 0, "fraction of highest-momentum particles to remove"],
            "fixplimits": ["FIXPLIMITS", "RPNValue", 0, "fix the limits in p from LOWERFRACTION and UPPERFRACTION applied to first beam"],
            "beamcentered": ["BEAMCENTERED", "RPNBoolean", "0", "if nonzero, center for DELTALIMIT is average beam momentum"],
            "bins": ["BINS", "RPNValue", 1024, "number of bins"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "POLYSERIES": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "filename": ["FILENAME", "InputFile", "", "name of file containing talor series map data"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "QUAD": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "hkick": ["HKICK [RAD]", "RPNValue", 0, "horizontal correction kick"],
            "vkick": ["VKICK [RAD]", "RPNValue", 0, "vertical correction kick"],
            "hcalibration": ["HCALIBRATION", "RPNValue", 1, "calibration factor for horizontal correction kick"],
            "vcalibration": ["VCALIBRATION", "RPNValue", 1, "calibration factor for vertical correction kick"],
            "hsteering": ["HSTEERING", "RPNBoolean", "0", "use for horizontal steering?"],
            "vsteering": ["VSTEERING", "RPNBoolean", "0", "use for vertical steering?"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "edge1_effects": ["EDGE1 EFFECTS", "RPNBoolean", "1", "include entrance edge effects?"],
            "edge2_effects": ["EDGE2 EFFECTS", "RPNBoolean", "1", "include exit edge effects?"],
            "fringe_type": ["FRINGE TYPE", "QuadFringeType", "fixed-strength", "type of fringe"],
            "ffringe": ["FFRINGE", "RPNValue", 0, "For non-integrals mode, fraction of length occupied by linear fringe region"],
            "leffective": ["LEFFECTIVE [M]", "RPNValue", -1, "Effective length. Ignored if non-positive. Cannot be used with non-zero FFRINGE."],
            "i0p": ["I0P [M]", "RPNValue", 0, "i0+ fringe integral"],
            "i1p": ["I1P [M²]", "RPNValue", 0, "i1+ fringe integral"],
            "i2p": ["I2P [M³]", "RPNValue", 0, "i2+ fringe integral"],
            "i3p": ["I3P [M⁴]", "RPNValue", 0, "i3+ fringe integral"],
            "lambda2p": ["LAMBDA2P [M³]", "RPNValue", 0, "lambda2+ fringe integral"],
            "i0m": ["I0M [M]", "RPNValue", 0, "i0-fringe integral"],
            "i1m": ["I1M [M²]", "RPNValue", 0, "i1-fringe integral"],
            "i2m": ["I2M [M³]", "RPNValue", 0, "i2-fringe integral"],
            "i3m": ["I3M [M⁴]", "RPNValue", 0, "i3-fringe integral"],
            "lambda2m": ["LAMBDA2M [M³]", "RPNValue", 0, "lambda2-fringe integral"],
            "radial": ["RADIAL", "RPNBoolean", "0", "If non-zero, converts the quadrupole into a radially-focusing lens"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "QUFRINGE": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "peak geometric strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "direction": ["DIRECTION", "QufringeDirection", "0", ""],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RAMPP": {
            "name": ["Name", "ValidatedString"],
            "waveform": ["WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving momentum factor vs time"],
            "waveformX": ["X", "String", ""],
            "waveformY": ["Y", "String", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RAMPRF": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "volt": ["VOLT [V]", "RPNValue", 0, "nominal voltage"],
            "phase": ["PHASE [DEG]", "RPNValue", 0, "nominal phase"],
            "freq": ["FREQ [Hz]", "RPNValue", 500000000, "nominal frequency"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "volt_waveform": ["VOLT WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving voltage waveform factor vs time"],
            "volt_waveformX": ["X", "String", ""],
            "volt_waveformY": ["Y", "String", ""],
            "phase_waveform": ["PHASE WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving phase offset vs time (requires FREQ WAVEFORM)"],
            "phase_waveformX": ["X", "String", ""],
            "phase_waveformY": ["Y", "String", ""],
            "freq_waveform": ["FREQ WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving frequency factor vs time (requires PHASE WAVEFORM)"],
            "freq_waveformX": ["X", "String", ""],
            "freq_waveformY": ["Y", "String", ""],
            "fiducial": ["FIDUCIAL", "Fiducial", "", "mode for determining fiducial arrival time"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RBEN": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "magnet (straight) length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bend angle"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric focusing strength"],
            "e1": ["E1 [RAD]", "RPNValue", 0, "entrance edge angle"],
            "e2": ["E2 [RAD]", "RPNValue", 0, "exit edge angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric sextupole strength"],
            "h1": ["H1 [1/M]", "RPNValue", 0, "entrance pole-face curvature"],
            "h2": ["H2 [1/M]", "RPNValue", 0, "exit pole-face curvature"],
            "hgap": ["HGAP [M]", "RPNValue", 0, "half-gap between poles"],
            "fint": ["FINT", "RPNValue", 0.5, "edge-field integral"],
            "dx": ["DX [M]", "RPNValue", 0, "misaligment of entrance"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment of entrance"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment of entrance"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "fse_dipole": ["FSE DIPOLE", "RPNValue", 0, "fractional strength error of dipole component"],
            "fse_quadrupole": ["FSE QUADRUPOLE", "RPNValue", 0, "fractional strength error of quadrupole component"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "error rotation about incoming longitudinal axis"],
            "etilt_sign": ["ETILT SIGN", "RPNBoolean", "1", "Sign of ETILT relative to TILT. -1 is the old convention prior to 2020.5"],
            "edge1_effects": ["EDGE1 EFFECTS", "RPNBoolean", "1", "include entrance edge effects?"],
            "edge2_effects": ["EDGE2 EFFECTS", "RPNBoolean", "1", "include exit edge effects?"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "edge_order": ["EDGE ORDER", "RPNValue", 0, "edge matrix order"],
            "transport": ["TRANSPORT", "RPNBoolean", "0", "use (incorrect) TRANSPORT equations for T436 of edge?"],
            "use_bn": ["USE BN", "RPNBoolean", "0", "use B1 and B2 instead of K1 and K2 values?"],
            "b1": ["B1 [1/M]", "RPNValue", 0, "K1 = B1/rho, where rho is bend radius"],
            "b2": ["B2 [1/M²]", "RPNValue", 0, "K2 = B2/rho"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RCOL": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "x_max": ["X MAX [M]", "RPNValue", 0, "half-width in x"],
            "y_max": ["Y MAX [M]", "RPNValue", 0, "half-width in y"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "open_side": ["OPEN SIDE", "OpenSide", "", ""],
            "invert": ["INVERT", "RPNBoolean", "0", "If non-zero, particles inside the aperture are lost while those outside are transmitted."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RECIRC": {
            "name": ["Name", "ValidatedString"],
            "i_recirc_element": ["I RECIRC ELEMENT", "RPNValue", 0, ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "REFLECT": {
            "name": ["Name", "ValidatedString"],
            "dummy": ["DUMMY", "RPNValue", 0, ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "REMCOR": {
            "name": ["Name", "ValidatedString"],
            "x": ["X", "RPNBoolean", "1", "remove correlations in x?"],
            "xp": ["XP", "RPNBoolean", "1", "remove correlations in x' ?"],
            "y": ["Y", "RPNBoolean", "1", "remove correlations in y?"],
            "yp": ["YP", "RPNBoolean", "1", "remove correlations in y' ?"],
            "with": ["WITH", "RPNValue", 6, "coordinate to remove correlations with (1,2,3,4,5,6)=(x,x',y,y',s,dP/Po)"],
            "once_only": ["ONCE ONLY", "RPNBoolean", "0", "compute correction only for first beam, apply to all?"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RFCA": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "volt": ["VOLT [V]", "RPNValue", 0, "peak voltage"],
            "phase": ["PHASE [DEG]", "RPNValue", 0, "phase"],
            "freq": ["FREQ [Hz]", "RPNValue", 500000000, "frequency"],
            "q": ["Q", "RPNValue", 0, "cavity Q (for cavity that charges up to given voltage from 0)"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "change_p0": ["CHANGE P0", "RPNBoolean", "0", "does cavity change central momentum?"],
            "change_t": ["CHANGE T", "RPNValue", 0, "set to 1 for long runs to avoid rounding error in phase"],
            "fiducial": ["FIDUCIAL", "Fiducial", "", "mode for determining fiducial arrival time"],
            "end1_focus": ["END1 FOCUS", "RPNBoolean", "0", "include focusing at entrance?"],
            "end2_focus": ["END2 FOCUS", "RPNBoolean", "0", "include focusing at exit?"],
            "body_focus_model": ["BODY FOCUS MODEL", "BodyFocusModel", "", "None or SRS (simplified Rosenzweig/Serafini for standing wave)"],
            "n_kicks": ["N KICKS", "RPNValue", 0, "Number of kicks to use for kick method. Set to zero for matrix method."],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "t_reference": ["T REFERENCE [S]", "RPNValue", -1, "arrival time of reference particle"],
            "linearize": ["LINEARIZE", "RPNBoolean", "0", "Linearize phase dependence?"],
            "lock_phase": ["LOCK PHASE", "RPNBoolean", "0", "Lock phase to given value regardless of bunch centroid motion?"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RFCW": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "cell_length": ["CELL LENGTH [M]", "RPNValue", 0, "cell length (used to scale wakes, which are assumed to be given for a cell, according to L/CELL LENGTH)"],
            "volt": ["VOLT [V]", "RPNValue", 0, "voltage"],
            "phase": ["PHASE [DEG]", "RPNValue", 0, "phase"],
            "freq": ["FREQ [Hz]", "RPNValue", 500000000, "frequency"],
            "q": ["Q", "RPNValue", 0, "cavity Q (for cavity that charges up to voltage from 0)"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "change_p0": ["CHANGE P0", "RPNBoolean", "0", "does element change central momentum?"],
            "change_t": ["CHANGE T", "RPNValue", 0, "see RFCA documentation"],
            "fiducial": ["FIDUCIAL", "Fiducial", "", "mode for determining fiducial arrival time"],
            "end1_focus": ["END1 FOCUS", "RPNBoolean", "0", "include focusing at entrance?"],
            "end2_focus": ["END2 FOCUS", "RPNBoolean", "0", "include focusing at exit?"],
            "body_focus_model": ["BODY FOCUS MODEL", "BodyFocusModel", "", "None or SRS (simplified Rosenzweig/Serafini for standing wave)"],
            "n_kicks": ["N KICKS", "RPNValue", 0, "Number of kicks to use for kick method. Set to zero for matrix method."],
            "zwake": ["ZWAKE", "RPNValue", 1, "If zero, longitudinal wake is turned off."],
            "trwake": ["TRWAKE", "RPNValue", 1, "If zero, transverse wakes are turned off."],
            "wakefile": ["WAKEFILE", "InputFile", "", "name of file containing Green functions"],
            "zwakefile": ["ZWAKEFILE", "InputFile", "", "if WAKEFILE=NULL, optional name of file containing longitudinal Green function"],
            "trwakefile": ["TRWAKEFILE", "InputFile", "", "if WAKEFILE=NULL, optional name of file containing transverse Green functions"],
            "tcolumn": ["TCOLUMN", "OptionalString", "", "column containing time data"],
            "wxcolumn": ["WXCOLUMN", "OptionalString", "", "column containing x Green function"],
            "wycolumn": ["WYCOLUMN", "OptionalString", "", "column containing y Green function"],
            "wzcolumn": ["WZCOLUMN", "OptionalString", "", "column containing longitudinal Green function"],
            "n_bins": ["N BINS", "RPNValue", 0, "number of bins for current histogram"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "0", "interpolate wake?"],
            "smoothing": ["SMOOTHING", "RPNBoolean", "0", "Use Savitzky-Golay filter to smooth current histogram?"],
            "sg_halfwidth": ["SG HALFWIDTH", "RPNValue", 4, "Savitzky-Golay filter half-width for smoothing"],
            "sg_order": ["SG ORDER", "RPNValue", 1, "Savitzky-Golay filter order for smoothing"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "t_reference": ["T REFERENCE [S]", "RPNValue", -1, "arrival time of reference particle"],
            "linearize": ["LINEARIZE", "RPNBoolean", "0", "Linearize phase dependence?"],
            "lsc": ["LSC", "RPNBoolean", "0", "Include longitudinal space-charge impedance?"],
            "lsc_bins": ["LSC BINS", "RPNValue", 1024, "Number of bins for LSC calculations"],
            "lsc_interpolate": ["LSC INTERPOLATE", "RPNBoolean", "1", "Interpolate computed LSC wake?"],
            "lsc_low_frequency_cutoff0": ["LSC LOW FREQUENCY CUTOFF0", "RPNValue", -1, "Highest spatial frequency at which low-frequency cutoff filter is zero. If not positive, no low-frequency cutoff filter is applied. Frequency is in units of Nyquist (0.5/binsize)."],
            "lsc_low_frequency_cutoff1": ["LSC LOW FREQUENCY CUTOFF1", "RPNValue", -1, "Lowest spatial frequency at which low-frequency cutoff filter is 1. If not given, defaults to LOW FREQUENCY CUTOFF1."],
            "lsc_high_frequency_cutoff0": ["LSC HIGH FREQUENCY CUTOFF0", "RPNValue", -1, "Spatial frequency at which smoothing filter begins for LSC. If not positive, no frequency filter smoothing is done. Frequency is in units of Nyquist (0.5/binsize)."],
            "lsc_high_frequency_cutoff1": ["LSC HIGH FREQUENCY CUTOFF1", "RPNValue", -1, "Spatial frequency at which smoothing filter is 0 for LSC. If not given, defaults to HIGH FREQUENCY CUTOFF0."],
            "lsc_radius_factor": ["LSC RADIUS FACTOR", "RPNValue", 1.7, "LSC radius is (Sx+Sy)/2*RADIUS FACTOR"],
            "wakes_at_end": ["WAKES AT END", "RPNBoolean", "0", "Do wake kicks at end of segment (for backward compatibility)?"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RFDF": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "phase": ["PHASE [DEG]", "RPNValue", 0, "phase"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "frequency": ["FREQUENCY [HZ]", "RPNValue", 2856000000, "frequency"],
            "voltage": ["VOLTAGE [V]", "RPNValue", 0, "voltage"],
            "fse": ["FSE", "RPNValue", 0, "Fractional Strength Error"],
            "b2": ["B2", "RPNValue", 0, "Normalized sextupole strength, kick=(1+b2*(x^2y^2)/2)..."],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "time offset (adds to phase)"],
            "n_kicks": ["N KICKS", "RPNValue", 0, "number of kicks (0=autoscale)"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "standing_wave": ["STANDING WAVE", "RPNBoolean", "0", "If nonzero, then cavity is standing wave."],
            "voltage_waveform": ["VOLTAGE WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving voltage waveform factor vs time"],
            "voltage_waveformX": ["X", "String", ""],
            "voltage_waveformY": ["Y", "String", ""],
            "voltage_periodic": ["VOLTAGE PERIODIC", "RPNBoolean", "0", "If non-zero, voltage waveform is periodic with period given by time span."],
            "align_waveforms": ["ALIGN WAVEFORMS", "RPNBoolean", "0", "If non-zero, waveforms' t=0 is aligned with first bunch arrival time."],
            "voltage_noise": ["VOLTAGE NOISE", "RPNValue", 0, "Rms fractional noise level for voltage."],
            "phase_noise": ["PHASE NOISE [DEG]", "RPNValue", 0, "Rms noise level for phase."],
            "group_voltage_noise": ["GROUP VOLTAGE NOISE", "RPNValue", 0, "Rms fractional noise level for voltage linked to group."],
            "group_phase_noise": ["GROUP PHASE NOISE [DEG]", "RPNValue", 0, "Rms noise level for phase linked to group."],
            "voltage_noise_group": ["VOLTAGE NOISE GROUP", "RPNValue", 0, "Group number for voltage noise."],
            "phase_noise_group": ["PHASE NOISE GROUP", "RPNValue", 0, "Group number for phase noise."],
            "start_pass": ["START PASS", "RPNValue", -1, "If non-negative, pass on which to start modeling cavity."],
            "end_pass": ["END PASS", "RPNValue", -1, "If non-negative, pass on which to end modeling cavity."],
            "drift_matrix": ["DRIFT MATRIX", "RPNBoolean", "0", "If non-zero, calculations involving matrices assume this element is a drift space."],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "magnetic_deflection": ["MAGNETIC DEFLECTION", "RPNBoolean", "0", "If non-zero, deflection is assumed to be performed by a magnetic field, rather than electric field (default)."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RFMODE": {
            "name": ["Name", "ValidatedString"],
            "ra": ["RA [Ohm]", "RPNValue", 0, "shunt impedance, Ra=V^2/P"],
            "rs": ["RS [Ohm]", "RPNValue", 0, "shunt impedance (Rs=Ra/2)"],
            "q": ["Q", "RPNValue", 0, "cavity Q"],
            "freq": ["FREQ [Hz]", "RPNValue", 0, "Resonant frequency of the cavity mode"],
            "charge": ["CHARGE [C]", "RPNValue", 0, "beam charge (or use CHARGE element)"],
            "initial_v": ["INITIAL V [V]", "RPNValue", 0, "initial beam-loading voltage"],
            "initial_phase": ["INITIAL PHASE [RAD]", "RPNValue", 0, "initial beam-loading phase"],
            "initial_t": ["INITIAL T [S]", "RPNValue", 0, "time at which INITIAL V and INITIAL PHASE held"],
            "beta": ["BETA", "RPNValue", 0, "normalized load impedance"],
            "bin_size": ["BIN SIZE [S]", "RPNValue", 0, "bin size for current histogram (use 0 for autosize)"],
            "n_bins": ["N BINS", "RPNValue", 20, "number of bins for current histogram"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "0", "if non-zero, interpolate voltage within bins"],
            "preload": ["PRELOAD", "RPNValue", 0, "preload cavity with steady-state field"],
            "preload_charge": ["PRELOAD CHARGE [C]", "RPNValue", 0, "beam charge used for preloading calculations"],
            "preload_factor": ["PRELOAD FACTOR", "RPNValue", 1, "multiply preloaded field by this value"],
            "preload_harmonic": ["PRELOAD HARMONIC", "RPNValue", 0, "If detuning from harmonic is greater than half the revolution frequency, automatic determination of the rf harmonic will fail. Give the harmonic explicitly with this parameter."],
            "rigid_until_pass": ["RIGID UNTIL PASS", "RPNValue", 0, "don't affect the beam until this pass"],
            "detuned_until_pass": ["DETUNED UNTIL PASS", "RPNValue", 0, "cavity is completely detuned until this pass"],
            "sample_interval": ["SAMPLE INTERVAL", "RPNValue", 1, "passes between samples to RECORD file"],
            "flush_interval": ["FLUSH INTERVAL", "RPNValue", 1000, "samples between flushing output to RECORD file"],
            "record": ["RECORD", "OutputFile", "", "output file for cavity fields"],
            "single_pass": ["SINGLE PASS", "RPNBoolean", "0", "if nonzero, don't accumulate field from pass to pass"],
            "pass_interval": ["PASS INTERVAL", "RPNValue", 1, "interval in passes at which to apply PASS INTERVAL times the field (may increase speed)"],
            "freq_waveform": ["FREQ WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving frequency/f0 vs time, where f0 is the frequency given with the FREQ parameter"],
            "freq_waveformX": ["X", "String", ""],
            "freq_waveformY": ["Y", "String", ""],
            "q_waveform": ["Q WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving qualityFactor/Q0 vs time, where Q0 is the quality factor given the the Q parameter."],
            "q_waveformX": ["X", "String", ""],
            "q_waveformY": ["Y", "String", ""],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the impedance to full strength."],
            "binless": ["BINLESS", "RPNBoolean", "0", "If nonzero, use algorithm that doesn't requiring binning. Best for few particles, widely spaced."],
            "reset_for_each_step": ["RESET FOR EACH STEP", "RPNBoolean", "1", "If nonzero, voltage and phase are reset for each simulation step."],
            "long_range_only": ["LONG RANGE ONLY", "RPNBoolean", "0", "If nonzero, induced voltage from present turn does not affect bunch. Results are not self-consistent!"],
            "allow_unbinned_particles": ["ALLOW UNBINNED PARTICLES", "RPNBoolean", "0", "If nonzero, will keep running even if some particles fall outside the binning region. Use with caution!"],
            "n_cavities": ["N CAVITIES", "RPNValue", 1, "effect is multiplied by this number, simulating N identical cavities"],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNValue", 1, "If 1, then do calculations bunch-by-bunch. If >1, use pseudo bunches."],
            "bunch_interval": ["BUNCH INTERVAL [S]", "RPNValue", 0, "For pseudo-bunch mode, time between bunches."],
            "drive_frequency": ["DRIVE FREQUENCY [Hz]", "RPNValue", 0, "drive frequency from generator. If zero, no generator voltage is applied."],
            "v_setpoint": ["V SETPOINT [V]", "RPNValue", 0, "setpoint for total cavity voltage"],
            "phase_setpoint": ["PHASE SETPOINT [DEG]", "RPNValue", 0, "setpoint for total cavity phase"],
            "update_interval": ["UPDATE INTERVAL", "RPNValue", 1, "update interval of feedback in units of rf period"],
            "read_offset": ["READ OFFSET", "Integer", 0, "Offset in buckets of point at which voltage and phase are read for feedback relative to the first bunch passage. A positive value corresponds to reading before bunch passage."],
            "adjustment_start": ["ADJUSTMENT START", "Integer", 0, "Pass on which to begin adjustment of the effective voltage setpoint."],
            "adjustment_end": ["ADJUSTMENT END", "Integer", 0, "Pass on which to stop adjustment of the effective voltage setpoint."],
            "adjustment_interval": ["ADJUSTMENT INTERVAL", "Integer", 100, "Interval in passes between adjustment of the effective voltage setpoint."],
            "adjustment_fraction": ["ADJUSTMENT FRACTION", "RPNValue", 0, "Fraction of voltage setpoint error taken out on each adjustment step"],
            "amplitude_filter": ["AMPLITUDE FILTER", "OptionalString", "", "IIR filter specification for amplitude feedback"],
            "phase_filter": ["PHASE FILTER", "OptionalString", "", "IIR filter specification for phase feedback"],
            "in_phase_filter": ["IN PHASEFILTER", "OptionalString", "", "IIR filter specification for in-phase component feedback"],
            "quadrature_filter": ["QUADRATURE FILTER", "OptionalString", "", "IIR filter specification for quadrature component feedback"],
            "feedback_record": ["FEEDBACK RECORD", "OptionalString", "", "output file for feedback data"],
            "mute_generator": ["MUTE GENERATOR", "RPNValue", -1, "If nonnegative, gives the pass on which to mute the generator. This simulates an rf trip."],
            "noise_alpha_gen": ["NOISE ALPHA GEN", "InputFileXY", "", "<filename>=<x>+<y> specifying alpha(t) for generator noise."],
            "noise_alpha_genX": ["X", "String", ""],
            "noise_alpha_genY": ["Y", "String", ""],
            "noise_phi_gen": ["NOISE PHI GEN", "InputFileXY", "", "<filename>=<x>+<y> specifying dphi(t) for generator noise, in radians."],
            "noise_phi_genX": ["X", "String", ""],
            "noise_phi_genY": ["Y", "String", ""],
            "noise_alpha_v": ["NOISE ALPHA V", "InputFileXY", "", "<filename>=<x>+<y> specifying alpha(t) for voltage noise."],
            "noise_alpha_vX": ["X", "String", ""],
            "noise_alpha_vY": ["Y", "String", ""],
            "noise_phi_v": ["NOISE PHI V", "InputFileXY", "", "<filename>=<x>+<y> specifying dphi(t) for voltage noise, in radians."],
            "noise_phi_vX": ["X", "String", ""],
            "noise_phi_vY": ["Y", "String", ""],
            "noise_i_gen": ["NOISE I GEN", "InputFileXY", "", "<filename>=<x>+<y> specifying ni(t) for in-phase generator noise."],
            "noise_i_genX": ["X", "String", ""],
            "noise_i_genY": ["Y", "String", ""],
            "noise_q_gen": ["NOISE Q GEN", "InputFileXY", "", "<filename>=<x>+<y> specifying nq(t) for quadrature generator noise."],
            "noise_q_genX": ["X", "String", ""],
            "noise_q_genY": ["Y", "String", ""],
            "noise_i_v": ["NOISE I V", "InputFileXY", "", "<filename>=<x>+<y> specifying ei(t) for in-phase voltage noise."],
            "noise_i_vX": ["X", "String", ""],
            "noise_i_vY": ["Y", "String", ""],
            "noise_q_v": ["NOISE Q V", "InputFileXY", "", "<filename>=<x>+<y> specifying eq(t) for quadrature voltage noise."],
            "noise_q_vX": ["X", "String", ""],
            "noise_q_vY": ["Y", "String", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RFTM110": {
            "name": ["Name", "ValidatedString"],
            "phase": ["PHASE [DEG]", "RPNValue", 0, "phase"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "frequency": ["FREQUENCY [HZ]", "RPNValue", 2856000000, "frequency"],
            "voltage": ["VOLTAGE [V]", "RPNValue", 0, "peak deflecting voltage"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "voltage_waveform": ["VOLTAGE WAVEFORM", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving voltage waveform factor vs time"],
            "voltage_waveformX": ["X", "String", ""],
            "voltage_waveformY": ["Y", "String", ""],
            "voltage_periodic": ["VOLTAGE PERIODIC", "RPNBoolean", "0", "If non-zero, voltage waveform is periodic with period given by time span."],
            "align_waveforms": ["ALIGN WAVEFORMS", "RPNBoolean", "0", "If non-zero, waveforms' t=0 is aligned with first bunch arrival time."],
            "voltage_noise": ["VOLTAGE NOISE", "RPNValue", 0, "Rms fractional noise level for voltage."],
            "phase_noise": ["PHASE NOISE [DEG]", "RPNValue", 0, "Rms noise level for phase."],
            "group_voltage_noise": ["GROUP VOLTAGE NOISE", "RPNValue", 0, "Rms fractional noise level for voltage linked to group."],
            "group_phase_noise": ["GROUP PHASE NOISE [DEG]", "RPNValue", 0, "Rms noise level for phase linked to group."],
            "voltage_noise_group": ["VOLTAGE NOISE GROUP", "RPNValue", 0, "Group number for voltage noise."],
            "phase_noise_group": ["PHASE NOISE GROUP", "RPNValue", 0, "Group number for phase noise."],
            "start_pass": ["START PASS", "RPNValue", -1, "If non-negative, pass on which to start modeling cavity."],
            "end_pass": ["END PASS", "RPNValue", -1, "If non-negative, pass on which to end modeling cavity."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RFTMEZ0": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "frequency": ["FREQUENCY [HZ]", "RPNValue", 2856000000, "frequency"],
            "phase": ["PHASE [RAD]", "RPNValue", 0, "phase"],
            "ez_peak": ["EZ PEAK [V]", "RPNValue", 0, "Peak on-axis longitudinal electric field"],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "time offset (adds to phase)"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link to other time-dependent elements)"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "misalignment"],
            "eyaw": ["EYAW [RAD]", "RPNValue", 0, "misalignment"],
            "epitch": ["EPITCH [RAD]", "RPNValue", 0, "misalignment"],
            "n_steps": ["N STEPS", "RPNValue", 100, "number of steps (for nonadaptive integration)"],
            "radial_order": ["RADIAL ORDER", "RPNValue", 1, "highest order in off-axis expansion"],
            "change_p0": ["CHANGE P0", "RPNBoolean", "0", "does element change central momentum?"],
            "inputfile": ["INPUTFILE", "InputFile", "", "file containing Ez vs z at r=0"],
            "zcolumn": ["ZCOLUMN", "OptionalString", "", "column containing z values"],
            "ezcolumn": ["EZCOLUMN", "OptionalString", "", "column containing Ez values"],
            "solenoid_file": ["SOLENOID FILE", "InputFile", "", "file containing map of Bz and Br vs z and r. Each page contains values for a single r."],
            "solenoid_zcolumn": ["SOLENOID ZCOLUMN", "OptionalString", "", "column containing z values for solenoid map."],
            "solenoid_rcolumn": ["SOLENOID RCOLUMN", "OptionalString", "", "column containing r values for solenoid map. If omitted, data is assumed to be for r=0 and an on-axis expansion is performed."],
            "solenoid_bzcolumn": ["SOLENOID BZCOLUMN", "OptionalString", "", "column containing Bz values for solenoid map."],
            "solenoid_brcolumn": ["SOLENOID BRCOLUMN", "OptionalString", "", "column containing Br values for solenoid map. If omitted, data is assumed to be for r=0 and an on-axis expansion is performed."],
            "solenoid_factor": ["SOLENOID FACTOR", "RPNValue", 1, "factor by which to multiply solenoid fields."],
            "solenoid_dx": ["SOLENOID DX [M]", "RPNValue", 0, "misalignment"],
            "solenoid_dy": ["SOLENOID DY [M]", "RPNValue", 0, "misalignment"],
            "solenoid_dz": ["SOLENOID DZ [M]", "RPNValue", 0, "misalignment"],
            "solenoid_etilt": ["SOLENOID ETILT [RAD]", "RPNValue", 0, "misalignment"],
            "solenoid_eyaw": ["SOLENOID EYAW [RAD]", "RPNValue", 0, "misalignment"],
            "solenoid_epitch": ["SOLENOID EPITCH [RAD]", "RPNValue", 0, "misalignment"],
            "bx_stray": ["BX STRAY", "RPNValue", 0, "Uniform stray horizontal field"],
            "by_stray": ["BY STRAY", "RPNValue", 0, "Uniform stray vertical field"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy"],
            "method": ["METHOD", "Rftmez0Method", "runge-kutta", "integration method"],
            "fiducial": ["FIDUCIAL", "TPFiducial", "t,median", ""],
            "field_test_file": ["FIELD TEST FILE", "OutputFile", "", "filename for output of test fields (r=0)"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RIMULT": {
            "name": ["Name", "ValidatedString"],
            "factor": ["FACTOR", "RPNValue", 1, "factor"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "RMDF": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "ramp_time": ["RAMP TIME [S]", "RPNValue", 1e-09, "length of ramp"],
            "voltage": ["VOLTAGE [V]", "RPNValue", 0, "full voltage"],
            "gap": ["GAP [M]", "RPNValue", 0.01, "gap between plates"],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "time offset of ramp start"],
            "n_sections": ["N SECTIONS", "RPNValue", 10, "number of sections"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "ROTATE": {
            "name": ["Name", "ValidatedString"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "exclude_floor": ["EXCLUDE FLOOR", "RPNBoolean", "0", "if non-zero, does not affect the floor coordinates"],
            "exclude_optics": ["EXCLUDE OPTICS", "RPNBoolean", "0", "if non-zero, does not affect the optics (i.e., transfer matrix is unit matrix)"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SAMPLE": {
            "name": ["Name", "ValidatedString"],
            "fraction": ["FRACTION", "RPNValue", 1, "fraction to keep"],
            "interval": ["INTERVAL", "RPNValue", 1, "interval between sampled particles"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SBEN": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "arc length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bend angle"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric focusing strength"],
            "e1": ["E1 [RAD]", "RPNValue", 0, "entrance edge angle"],
            "e2": ["E2 [RAD]", "RPNValue", 0, "exit edge angle"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about incoming longitudinal axis"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric sextupole strength"],
            "h1": ["H1 [1/M]", "RPNValue", 0, "entrance pole-face curvature"],
            "h2": ["H2 [1/M]", "RPNValue", 0, "exit pole-face curvature"],
            "hgap": ["HGAP [M]", "RPNValue", 0, "half-gap between poles"],
            "fint": ["FINT", "RPNValue", 0.5, "edge-field integral"],
            "dx": ["DX [M]", "RPNValue", 0, "misaligment of entrance"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment of entrance"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment of entrance"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "fse_dipole": ["FSE DIPOLE", "RPNValue", 0, "fractional strength error of dipole component"],
            "fse_quadrupole": ["FSE QUADRUPOLE", "RPNValue", 0, "fractional strength error of quadrupole component"],
            "etilt": ["ETILT [RAD]", "RPNValue", 0, "error rotation about incoming longitudinal axis"],
            "etilt_sign": ["ETILT SIGN", "RPNBoolean", "1", "Sign of ETILT relative to TILT. -1 is the old convention prior to 2020.5"],
            "edge1_effects": ["EDGE1 EFFECTS", "RPNBoolean", "1", "include entrance edge effects?"],
            "edge2_effects": ["EDGE2 EFFECTS", "RPNBoolean", "1", "include exit edge effects?"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "edge_order": ["EDGE ORDER", "RPNValue", 0, "edge matrix order"],
            "transport": ["TRANSPORT", "RPNBoolean", "0", "use (incorrect) TRANSPORT equations for T436 of edge?"],
            "use_bn": ["USE BN", "RPNBoolean", "0", "use B1 and B2 instead of K1 and K2 values?"],
            "b1": ["B1 [1/M]", "RPNValue", 0, "K1 = B1/rho, where rho is bend radius"],
            "b2": ["B2 [1/M²]", "RPNValue", 0, "K2 = B2/rho"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SCATTER": {
            "name": ["Name", "ValidatedString"],
            "x": ["X [M]", "RPNValue", 0, "rms scattering level for x"],
            "xp": ["XP", "RPNValue", 0, "rms scattering level for x'"],
            "y": ["Y [M]", "RPNValue", 0, "rms scattering level for y"],
            "yp": ["YP", "RPNValue", 0, "rms scattering level for y'"],
            "dp": ["DP", "RPNValue", 0, "rms scattering level for (ppCentral)/pCentral"],
            "probability": ["PROBABILITY", "RPNValue", 1, "Probability that any particle will be selected for scattering."],
            "startonpass": ["STARTONPASS", "RPNValue", 0, "Pass number to start on."],
            "endonpass": ["ENDONPASS", "RPNValue", -1, "Pass number to end on (inclusive). Ignored if negative."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SCMULT": {
            "name": ["Name", "ValidatedString"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SCRAPER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "xo": ["XO [M]", "RPNValue", 0, "radiation length"],
            "energy_decay": ["ENERGY DECAY", "RPNBoolean", "0", "If nonzero, then particles will lose energy due to material using a simple exponential model."],
            "energy_straggle": ["ENERGY STRAGGLE", "RPNBoolean", "0", "Use simple-minded energy straggling model coupled with ENERGY DECAY=1?"],
            "nuclear_bremsstrahlung": ["NUCLEAR BREMSSTRAHLUNG", "RPNValue", 0, "Model energy loss to nuclear bremsstrahlung? If enabled, set ENERGY DECAY=0 to disable simpler model."],
            "electron_recoil": ["ELECTRON RECOIL", "RPNBoolean", "0", "If non-zero, electron recoil during Coulomb scattering is included (results in energy change)."],
            "z": ["Z", "RPNValue", 0, "Atomic number"],
            "a": ["A [AMU]", "RPNValue", 0, "Atomic mass"],
            "rho": ["RHO [KG/M³]", "RPNValue", 0, "Density"],
            "plimit": ["PLIMIT", "RPNValue", 0.05, "Probability cutoff for each slice"],
            "position": ["POSITION [M]", "RPNValue", 0, "position of edge"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "insert_from": ["INSERT FROM", "OpenSide", "", "direction from which inserted"],
            "direction": ["DIRECTION", "RPNValue", -1, "obsolete, use insert from instead"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SCRIPT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "Length to be used for matrix-based operations such as twiss parameter computation."],
            "command": ["COMMAND", "OptionalString", "", "SDDS-compliant command to apply to the beam. Use the sequence %i to represent the input filename and %o to represent the output filename."],
            "commandFile": ["COMMAND FILE", "InputFile", "", "Optional script source."],
            "commandInputFile": ["COMMAND INPUT FILE", "InputFile", "", "Optional input data for script."],
            "use_csh": ["USE CSH", "RPNBoolean", "1", "Use C-shell for execution (may be slower)?"],
            "verbosity": ["VERBOSITY", "Integer", 0, "Set the verbosity level."],
            "start_pass": ["START PASS", "RPNValue", -1, "Start script action on this pass. Before that, behaves like a drift space."],
            "end_pass": ["END PASS", "RPNValue", -1, "End script action after this pass. Before that, behaves like a drift space."],
            "pass_interval": ["PASS INTERVAL", "RPNValue", -1, "Execute script only even Nth pass following START PASS, including START PASS. Otherwise, behaves like a drift space."],
            "on_pass": ["ON PASS", "RPNValue", -1, "Perform script action only on this pass, overriding other pass controls. Other than that, behaves like a drift space."],
            "directory": ["DIRECTORY", "OptionalString", "", "Directory in which to place input and output files. If blank, the present working directory is used."],
            "rootname": ["ROOTNAME", "OptionalString", "", "Rootname for use in naming inputand output files. %s may be used to represent the run rootname."],
            "input_extension": ["INPUT EXTENSION", "OptionalString", "in", "Extension for the script input file."],
            "output_extension": ["OUTPUT EXTENSION", "OptionalString", "out", "Extension for the scriptoutput file."],
            "keep_files": ["KEEP FILES", "RPNBoolean", "0", "If nonzero, then script input and output files are not deleted after use. By default, they are deleted."],
            "drift_matrix": ["DRIFT MATRIX", "RPNBoolean", "0", "If nonzero, then for non-tracking calculations the element is treated as a drift space."],
            "use_particle_id": ["USE PARTICLE ID", "RPNBoolean", "1", "If nonzero, then the output file will supply particle IDs. Otherwise, particles are renumbered."],
            "no_new_particles": ["NO NEW PARTICLES", "RPNBoolean", "1", "If nonzero, then no new particles will be added in the script output file."],
            "determine_losses_from_pid": ["DETERMINE LOSSES FROM PID", "RPNBoolean", "1", "If nonzero and if USE_PARTICLE_ID is nonzero, then particleID data from script output is used to determine which particles were lost."],
            "np0": ["NP0", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np0"],
            "np1": ["NP1", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np1"],
            "np2": ["NP2", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np2"],
            "np3": ["NP3", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np3"],
            "np4": ["NP4", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np4"],
            "np5": ["NP5", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np5"],
            "np6": ["NP6", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np6"],
            "np7": ["NP7", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np7"],
            "np8": ["NP8", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np8"],
            "np9": ["NP9", "RPNValue", 0, "User-defined numerical parameter for command substitution for sequence %np9"],
            "sp0": ["SP0", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp0"],
            "sp1": ["SP1", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp1"],
            "sp2": ["SP2", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp2"],
            "sp3": ["SP3", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp3"],
            "sp4": ["SP4", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp4"],
            "sp5": ["SP5", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp5"],
            "sp6": ["SP6", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp6"],
            "sp7": ["SP7", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp7"],
            "sp8": ["SP8", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp8"],
            "sp9": ["SP9", "OptionalString", "", "User-defined string parameter for command substitution for sequence %sp9"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SEXT": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "k2": ["K2 [1/M³]", "RPNValue", 0, "geometric strength"],
            "k1": ["K1 [1/M²]", "RPNValue", 0, "geometric quadrupole strength error."],
            "j1": ["J1 [1∕M²]", "RPNValue", 0, "geometric skew quadrupole strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "ffringe": ["FFRINGE", "RPNValue", 0, "Length occupied by linear fringe regions as fraction hard-edge length L."],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SHRFDF": {
            "name": ["Name", "ValidatedString"],
            "factor": ["FACTOR", "RPNValue", 1, "A factor by which to multiply all components."],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "period_length": ["PERIOD LENGTH [M]", "RPNValue", 0, "cavity period length, or cell length"],
            "period_phase": ["PERIOD PHASE [RAD]", "RPNValue", 0, "cavity period phase advance, or so-called working mode"],
            "v0": ["V0 [V]", "RPNValue", 0, "effective voltage of space harmonic n=0"],
            "v1": ["V1 [V]", "RPNValue", 0, "effective voltage of space harmonic n=1"],
            "v2": ["V2 [V]", "RPNValue", 0, "effective voltage of space harmonic n=2"],
            "v3": ["V3 [V]", "RPNValue", 0, "effective voltage of space harmonic n=3"],
            "v4": ["V4 [V]", "RPNValue", 0, "effective voltage of space harmonic n=4"],
            "v5": ["V5 [V]", "RPNValue", 0, "effective voltage of space harmonic n=5"],
            "v6": ["V6 [V]", "RPNValue", 0, "effective voltage of space harmonic n=6"],
            "v7": ["V7 [V]", "RPNValue", 0, "effective voltage of space harmonic n=7"],
            "v8": ["V8 [V]", "RPNValue", 0, "effective voltage of space harmonic n=8"],
            "v9": ["V9 [V]", "RPNValue", 0, "effective voltage of space harmonic n=9"],
            "phase0": ["PHASE0 [HZ]", "RPNValue", 0, "Phase of space harmonic n=0"],
            "phase1": ["PHASE1 [HZ]", "RPNValue", 0, "Phase of space harmonic n=1"],
            "phase2": ["PHASE2 [HZ]", "RPNValue", 0, "Phase of space harmonic n=2"],
            "phase3": ["PHASE3 [HZ]", "RPNValue", 0, "Phase of space harmonic n=3"],
            "phase4": ["PHASE4 [HZ]", "RPNValue", 0, "Phase of space harmonic n=4"],
            "phase5": ["PHASE5 [HZ]", "RPNValue", 0, "Phase of space harmonic n=5"],
            "phase6": ["PHASE6 [HZ]", "RPNValue", 0, "Phase of space harmonic n=6"],
            "phase7": ["PHASE7 [HZ]", "RPNValue", 0, "Phase of space harmonic n=7"],
            "phase8": ["PHASE8 [HZ]", "RPNValue", 0, "Phase of space harmonic n=8"],
            "phase9": ["PHASE9 [HZ]", "RPNValue", 0, "Phase of space harmonic n=9"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SLICE": {
            "name": ["Name", "ValidatedString"],
            "n_slices": ["N SLICES", "Integer", 10, "number of slices"],
            "start_pid": ["START PID", "Integer", -1, "starting particleID for particles to dump"],
            "end_pid": ["END PID", "Integer", -1, "ending particleID for particles to dump"],
            "interval": ["INTERVAL", "Integer", 1, "interval for data output (in turns)"],
            "start_pass": ["START PASS", "Integer", 0, "pass on which to start"],
            "end_pass": ["END PASS", "Integer", -1, "pass on which to end (inclusive). Ignored if negative."],
            "filename": ["FILENAME", "OutputFile", "", "output filename, possibly incomplete (see below)"],
            "label": ["LABEL", "String", "", "output label"],
            "index_offset": ["INDEX OFFSET", "Integer", 0, "Offset for file indices for sequential file naming."],
            "reference_frequency": ["REFERENCE FREQUENCY", "RPNValue", -1, "If non-zero, the indicated frequency is used to define the bucket center for purposes of computing time offsets."],
            "disable": ["DISABLE", "RPNBoolean", "0", "If nonzero, no output will be generated."],
            "use_disconnect": ["USE DISCONNECT", "RPNBoolean", "0", "If nonzero, files are disconnected between each write operation. May be useful for parallel operation. Ignored otherwise."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SOLE": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "ks": ["KS [RAD/M]", "RPNValue", 0, "geometric strength, -Bs/(B*Rho)"],
            "b": ["B [T]", "RPNValue", 0, "field strength (used if KS is zero)"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SPEEDBUMP": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "insertion length"],
            "chord": ["CHORD [M]", "RPNValue", 0, "z length of speed bump"],
            "dzcenter": ["DZCENTER [M]", "RPNValue", 0, "z center displacement of speed bump relative to middle of object"],
            "height": ["HEIGHT [M]", "RPNValue", 0, "height above the surrounding chamber"],
            "position": ["POSITION [M]", "RPNValue", 0, "position of peak relative to ideal trajectory"],
            "dx": ["DX [M]", "RPNValue", 0, "horizontal misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "vertical misalignment"],
            "insert_from": ["INSERT FROM", "SpeedbumpInsertFrom", "", "direction from which inserted"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "SREFFECTS": {
            "name": ["Name", "ValidatedString"],
            "jx": ["JX", "RPNValue", 1, "x damping partition number"],
            "jy": ["JY", "RPNValue", 1, "y damping partition number"],
            "jdelta": ["JDELTA", "RPNValue", 2, "momentum damping partition number"],
            "exref": ["EXREF [m]", "RPNValue", 0, "reference equilibrium x emittance"],
            "eyref": ["EYREF [m]", "RPNValue", 0, "reference equilibrium y emittance"],
            "sdeltaref": ["SDELTAREF", "RPNValue", 0, "reference equilibrium fractional momentum spread"],
            "ddeltaref": ["DDELTAREF", "RPNValue", 0, "reference fractional momentum change per turn due to SR (negative value)"],
            "pref": ["PREF [mec]", "RPNValue", 0, "reference momentum (to which other reference values pertain)"],
            "coupling": ["COUPLING", "RPNValue", 0, "x-y coupling"],
            "fraction": ["FRACTION", "RPNValue", 1, "fraction of implied SReffect to simulate with each instance"],
            "damping": ["DAMPING", "RPNBoolean", "1", "include damping, less rf effects?"],
            "qexcitation": ["QEXCITATION", "RPNBoolean", "1", "include quantum excitation?"],
            "losses": ["LOSSES", "RPNBoolean", "1", "include average losses?"],
            "cutoff": ["CUTOFF", "RPNValue", 100, "cutoff (in sigmas) for gaussian random numbers"],
            "include_offsets": ["INCLUDE OFFSETS", "RPNBoolean", "1", "include orbit offsets in tracking (see below)?"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "STRAY": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "lbx": ["LBX [T]", "RPNValue", 0, "local Bx"],
            "lby": ["LBY [T]", "RPNValue", 0, "local By"],
            "gbx": ["GBX [T]", "RPNValue", 0, "global Bx"],
            "gby": ["GBY [T]", "RPNValue", 0, "global By"],
            "gbz": ["GBZ [T]", "RPNValue", 0, "global Bz"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TAPERAPC": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "rstart": ["RSTART [M]", "RPNValue", 0, "radius at the start"],
            "rend": ["REND [M]", "RPNValue", 0, "radius at the end"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "sticky": ["STICKY", "RPNBoolean", "0", "final aperture holds downstream until next TAPERAPC, TAPERAPE, TAPERAPR, or MAXAMP"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TAPERAPE": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "astart": ["RSTART [M]", "RPNValue", 0, "horizontal semi-axis at the start"],
            "aend": ["REND [M]", "RPNValue", 0, "horizontal semi-axis at the end"],
            "bstart": ["RSTART [M]", "RPNValue", 0, "vertical semi-axis at the start"],
            "bend": ["REND [M]", "RPNValue", 0, "vertical semi-axis at the end"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "misalignment"],
            "resolution": ["RESOLUTION [M]", "RPNValue", 1e-06, "z resolution of finding intersection"],
            "xexponent": ["XEXPONENT", "Integer", 2, "super-elliptical exponent (even number)"],
            "yexponent": ["YEXPONENT", "Integer", 2, "super-elliptical exponent (even number)"],
            "sticky": ["STICKY", "RPNBoolean", "0", "final aperture holds downstream until next TAPERAPC, TAPERAPE, TAPERAPR, or MAXAMP"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TAPERAPR": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "xstart": ["RSTART [M]", "RPNValue", 0, "horizontal semi-axis at the start"],
            "xend": ["REND [M]", "RPNValue", 0, "horizontal semi-axis at the end"],
            "ystart": ["RSTART [M]", "RPNValue", 0, "vertical semi-axis at the start"],
            "yend": ["REND [M]", "RPNValue", 0, "vertical semi-axis at the end"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "misalignment"],
            "sticky": ["STICKY", "RPNBoolean", "0", "final aperture holds downstream until next TAPERAPC, TAPERAPE, TAPERAPR, or MAXAMP"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TFBDRIVER": {
            "name": ["Name", "ValidatedString"],
            "id": ["ID", "OptionalString", "", "System identifier"],
            "strength": ["STRENGTH", "RPNValue", 0, "Strength factor"],
            "kick_limit": ["KICK LIMIT", "RPNValue", 0, "Limit on applied kick, nominally in radians."],
            "frequency": ["FREQUENCY [Hz]", "RPNValue", 0, "Frequency of the kicker cavity."],
            "drive_frequency": ["DRIVE FREQUENCY [Hz]", "RPNValue", 0, "Drive frequency. If zero, defaults to resonant frequency of the loaded cavity."],
            "clock_frequency": ["CLOCK FREQUENCY [Hz]", "RPNValue", 0, "Clock frequency used for timing of the changes to generator current. Typically the rf or bunch frequency is used."],
            "clock_offset": ["CLOCK OFFSET [s]", "RPNValue", 0, "Offset of the generator current change relative to clock tick. Clock tick is nominally aligned to the bunch center."],
            "phase": ["PHASE [Deg]", "RPNValue", 0, "Phase of the applied voltage relative to the bunch center."],
            "raoverq": ["RAOVERQ [Ohm]", "RPNValue", 0, "Shunt impedance, Ra/Q=Vˆ2/(P*Q)."],
            "qloaded": ["QLOADED", "RPNValue", 0, "Loaded Q of the cavity."],
            "delay": ["DELAY", "RPNValue", 0, "Delay (in turns)"],
            "longitudinal": ["LONGITUDINAL", "RPNBoolean", "0", "If non-zero, kick is in the longitudinal plane. KICK LIMIT is in fractional momentum deviation."],
            "output_file": ["OUTPUT FILE", "OutputFile", "", "File for logging filter output and driver output"],
            "gain_factor_file": ["GAIN FACTOR FILE", "InputFile", "", "File providing gain factors for individual bunches."],
            "gain_factor_column": ["GAIN FACTOR COLUMN", "OptionalString", "", "Column from GAIN_FACTOR_FILE containing gain factors."],
            "a0": ["A0", "RPNValue", 1, "Filter coefficient"],
            "a1": ["A1", "RPNValue", 0, "Filter coefficient"],
            "a2": ["A2", "RPNValue", 0, "Filter coefficient"],
            "a3": ["A3", "RPNValue", 0, "Filter coefficient"],
            "a4": ["A4", "RPNValue", 0, "Filter coefficient"],
            "a5": ["A5", "RPNValue", 0, "Filter coefficient"],
            "a6": ["A6", "RPNValue", 0, "Filter coefficient"],
            "a7": ["A7", "RPNValue", 0, "Filter coefficient"],
            "a8": ["A8", "RPNValue", 0, "Filter coefficient"],
            "a9": ["A9", "RPNValue", 0, "Filter coefficient"],
            "a10": ["A10", "RPNValue", 0, "Filter coefficient"],
            "a11": ["A11", "RPNValue", 0, "Filter coefficient"],
            "a12": ["A12", "RPNValue", 0, "Filter coefficient"],
            "a13": ["A13", "RPNValue", 0, "Filter coefficient"],
            "a14": ["A14", "RPNValue", 0, "Filter coefficient"],
            "a15": ["A15", "RPNValue", 0, "Filter coefficient"],
            "a16": ["A16", "RPNValue", 0, "Filter coefficient"],
            "a17": ["A17", "RPNValue", 0, "Filter coefficient"],
            "a18": ["A18", "RPNValue", 0, "Filter coefficient"],
            "a19": ["A19", "RPNValue", 0, "Filter coefficient"],
            "a20": ["A20", "RPNValue", 0, "Filter coefficient"],
            "a21": ["A21", "RPNValue", 0, "Filter coefficient"],
            "a22": ["A22", "RPNValue", 0, "Filter coefficient"],
            "a23": ["A23", "RPNValue", 0, "Filter coefficient"],
            "a24": ["A24", "RPNValue", 0, "Filter coefficient"],
            "a25": ["A25", "RPNValue", 0, "Filter coefficient"],
            "a26": ["A26", "RPNValue", 0, "Filter coefficient"],
            "a27": ["A27", "RPNValue", 0, "Filter coefficient"],
            "a28": ["A28", "RPNValue", 0, "Filter coefficient"],
            "a29": ["A29", "RPNValue", 0, "Filter coefficient"],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, run in bunched beam mode."],
            "start_pass": ["START PASS", "Integer", -1, "If positive, first pass on which to drive beam."],
            "end_pass": ["END PASS", "Integer", -1, "If positive, last pass on which to drive beam."],
            "update_interval": ["UPDATE INTERVAL", "RPNValue", 0, "Interval in units of pickup update interval for sampling pickup data and updating filter output."],
            "output_interval": ["OUTPUT INTERVAL", "RPNValue", 1024, "Number of samples to buffer between writing output file updates."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TFBPICKUP": {
            "name": ["Name", "ValidatedString"],
            "id": ["ID", "OptionalString", "", "System identifier"],
            "plane": ["PLANE", "TfbpickupPlane", "x", ""],
            "rms_noise": ["RMS NOISE [M]", "RPNValue", 0, "RMS noise to add to position readings."],
            "a0": ["A0", "RPNValue", 0, "Filter coefficient"],
            "a1": ["A1", "RPNValue", 0, "Filter coefficient"],
            "a2": ["A2", "RPNValue", 0, "Filter coefficient"],
            "a3": ["A3", "RPNValue", 0, "Filter coefficient"],
            "a4": ["A4", "RPNValue", 0, "Filter coefficient"],
            "a5": ["A5", "RPNValue", 0, "Filter coefficient"],
            "a6": ["A6", "RPNValue", 0, "Filter coefficient"],
            "a7": ["A7", "RPNValue", 0, "Filter coefficient"],
            "a8": ["A8", "RPNValue", 0, "Filter coefficient"],
            "a9": ["A9", "RPNValue", 0, "Filter coefficient"],
            "a10": ["A10", "RPNValue", 0, "Filter coefficient"],
            "a11": ["A11", "RPNValue", 0, "Filter coefficient"],
            "a12": ["A12", "RPNValue", 0, "Filter coefficient"],
            "a13": ["A13", "RPNValue", 0, "Filter coefficient"],
            "a14": ["A14", "RPNValue", 0, "Filter coefficient"],
            "a15": ["A15", "RPNValue", 0, "Filter coefficient"],
            "a16": ["A16", "RPNValue", 0, "Filter coefficient"],
            "a17": ["A17", "RPNValue", 0, "Filter coefficient"],
            "a18": ["A18", "RPNValue", 0, "Filter coefficient"],
            "a19": ["A19", "RPNValue", 0, "Filter coefficient"],
            "a20": ["A20", "RPNValue", 0, "Filter coefficient"],
            "a21": ["A21", "RPNValue", 0, "Filter coefficient"],
            "a22": ["A22", "RPNValue", 0, "Filter coefficient"],
            "a23": ["A23", "RPNValue", 0, "Filter coefficient"],
            "a24": ["A24", "RPNValue", 0, "Filter coefficient"],
            "a25": ["A25", "RPNValue", 0, "Filter coefficient"],
            "a26": ["A26", "RPNValue", 0, "Filter coefficient"],
            "a27": ["A27", "RPNValue", 0, "Filter coefficient"],
            "a28": ["A28", "RPNValue", 0, "Filter coefficient"],
            "a29": ["A29", "RPNValue", 0, "Filter coefficient"],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, run in bunched beam mode."],
            "start_pass": ["START PASS", "Integer", -1, "If positive, first pass on which to perform computations."],
            "end_pass": ["END PASS", "Integer", -1, "If positive, last pass on which to perform computations."],
            "update_interval": ["UPDATE INTERVAL", "RPNValue", 0, "Interval in turns for sampling data and updating filter output."],
            "reference_frequency": ["REFERENCE FREQUENCY", "RPNValue", 0, "Reference frequency for computing phase offsets."],
            "dx": ["DX [M]", "RPNValue", 0, "Horizontal offset (subtracted from pickup signal)."],
            "dy": ["DY [M]", "RPNValue", 0, "Vertical offset (subtracted from pickup signal)"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TMCF": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "frequency": ["FREQUENCY [HZ]", "RPNValue", 2856000000, "frequency"],
            "phase": ["PHASE [S]", "RPNValue", 0, "phase"],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "time offset (adds to phase)"],
            "radial_offset": ["RADIAL OFFSET [M]", "RPNValue", 1, "not recommended"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "er": ["ER [V]", "RPNValue", 0, "radial electric field"],
            "bphi": ["BPHI [T]", "RPNValue", 0, "azimuthal magnetic field"],
            "ez": ["EZ [V]", "RPNValue", 0, "longitudinal electric field"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy"],
            "x_max": ["X MAX [M]", "RPNValue", 0, "x half-aperture"],
            "y_max": ["Y MAX [M]", "RPNValue", 0, "y half-aperture"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "n_steps": ["N STEPS", "RPNValue", 100, "number of steps (for nonadaptive integration)"],
            "method": ["METHOD", "TmcfMethod", "runge-kutta", "integration method"],
            "fiducial": ["FIDUCIAL", "TPFiducial", "t,median", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TRCOUNT": {
            "name": ["Name", "ValidatedString"],
            "dummy": ["DUMMY", "RPNValue", 0, ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TRFMODE": {
            "name": ["Name", "ValidatedString"],
            "ra": ["RA [Ohm/m]", "RPNValue", 0, "shunt impedance, Ra=V^2/P"],
            "rs": ["RS [Ohm/m]", "RPNValue", 0, "shunt impedance (Rs=Ra/2)"],
            "q": ["Q", "RPNValue", 0, "cavity Q"],
            "freq": ["FREQ [Hz]", "RPNValue", 0, "frequency"],
            "charge": ["CHARGE [C]", "RPNValue", 0, "beam charge (or use CHARGE element)"],
            "beta": ["BETA", "RPNValue", 0, "normalized load impedance"],
            "bin_size": ["BIN SIZE [S]", "RPNValue", 0, "bin size for current histogram (use 0 for autosize)"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "0", "if non-zero, interpolate voltage within bins"],
            "n_bins": ["N BINS", "RPNValue", 20, "number of bins for current histogram"],
            "plane": ["PLANE", "TrfmodePlane", "both", ""],
            "sample_interval": ["SAMPLE INTERVAL", "RPNValue", 1, "passes between output to RECORD file"],
            "per_particle_output": ["PER PARTICLE OUTPUT", "RPNBoolean", "0", "If non-zero, then in BINLESS mode, provides per-particle output of RECORD data."],
            "record": ["RECORD", "OutputFile", "", "output file for cavity data"],
            "single_pass": ["SINGLE PASS", "RPNBoolean", "0", "if nonzero, don't accumulate field from pass to pass"],
            "rigid_until_pass": ["RIGID UNTIL PASS", "RPNValue", 0, "don't affect the beam until this pass"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "xfactor": ["XFACTOR", "RPNValue", 1, "factor by which to multiply shunt impedances"],
            "yfactor": ["YFACTOR", "RPNValue", 1, "factor by which to multiply shunt impedances"],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the impedance to full strength."],
            "binless": ["BINLESS", "RPNBoolean", "0", "If nonzero, use algorithm that doesn't requiring binning. Best for few particles, widely spaced."],
            "reset_for_each_step": ["RESET FOR EACH STEP", "RPNBoolean", "1", "If nonzero, voltage and phase are reset for each simulation step."],
            "long_range_only": ["LONG RANGE ONLY", "RPNBoolean", "0", "If nonzero, induced voltage from present turn does not affect bunch. Short range wake should be included via TRWAKE or ZTRANSVERSE element."],
            "n_cavities": ["N CAVITIES", "RPNValue", 1, "effect is multiplied by this number, simulating N identical cavities"],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, then do calculations bunch-by-bunch."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TRWAKE": {
            "name": ["Name", "ValidatedString"],
            "inputfile": ["INPUTFILE", "InputFile", "", "name of file giving Green functions"],
            "tcolumn": ["TCOLUMN", "OptionalString", "", "column in INPUTFILE containing time data"],
            "wxcolumn": ["WXCOLUMN", "OptionalString", "", "column in INPUTFILE containing x Green function"],
            "wycolumn": ["WYCOLUMN", "OptionalString", "", "column in INPUTFILE containing y Green function"],
            "charge": ["CHARGE [C]", "RPNValue", 0, "beam charge (or use CHARGE element)"],
            "factor": ["FACTOR", "RPNValue", 1, "factor by which to multiply both wakes"],
            "xfactor": ["XFACTOR", "RPNValue", 1, "factor by which to multiply x wake"],
            "yfactor": ["YFACTOR", "RPNValue", 1, "factor by which to multiply y wake"],
            "n_bins": ["N BINS", "RPNValue", 128, "number of bins for current histogram"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "0", "interpolate wake?"],
            "smoothing": ["SMOOTHING", "RPNBoolean", "0", "Use Savitzky-Golay filter to smooth current histogram?"],
            "sg_halfwidth": ["SG HALFWIDTH", "RPNValue", 4, "Savitzky-Golay filter half-width for smoothing"],
            "sg_order": ["SG ORDER", "RPNValue", 1, "Savitzky-Golay filter order for smoothing"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "x_drive_exponent": ["X DRIVE EXPONENT", "RPNValue", 1, "Exponent applied to x coordinates of drive particles"],
            "y_drive_exponent": ["Y DRIVE EXPONENT", "RPNValue", 1, "Exponent applied to y coordinates of drive particles"],
            "x_probe_exponent": ["X PROBE EXPONENT", "RPNValue", 0, "Exponent applied to x coordinates of probe particles"],
            "y_probe_exponent": ["Y PROBE EXPONENT", "RPNValue", 0, "Exponent applied to y coordinates of probe particles"],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the wake to full strength."],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, then do calculations bunch-by-bunch."],
            "acausal_allowed": ["ACAUSAL ALLOWED", "RPNValue", 0, "If non-zero, then an acausal wake is allowed."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TSCATTER": {
            "name": ["Name", "ValidatedString"],
            "dummy": ["DUMMY", "RPNValue", 0, ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TUBEND": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "arc length"],
            "angle": ["ANGLE [RAD]", "RPNValue", 0, "bend angle"],
            "fse": ["FSE", "RPNValue", 0, "fractional strength error"],
            "offset": ["OFFSET", "RPNValue", 0, "horizontal offset of magnet center from arc center"],
            "magnet_width": ["MAGNET WIDTH", "RPNValue", 0, "horizontal width of the magnet pole"],
            "magnet_angle": ["MAGNET ANGLE", "RPNValue", 0, "angle that the magnet was designed for"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TWISS": {
            "name": ["Name", "ValidatedString"],
            "betax": ["BETAX [M]", "RPNValue", 1, "horizontal beta function"],
            "alphax": ["ALPHAX", "RPNValue", 0, "horizontal alpha function"],
            "etax": ["ETAX [M]", "RPNValue", 0, "horizontal eta function"],
            "etaxp": ["ETAXP", "RPNValue", 0, "slope of horizontal eta function"],
            "betay": ["BETAY [M]", "RPNValue", 1, "vertical beta function"],
            "alphay": ["ALPHAY", "RPNValue", 0, "vertical alpha function"],
            "etay": ["ETAY [M]", "RPNValue", 0, "vertical eta function"],
            "etayp": ["ETAYP", "RPNValue", 0, "slope of vertical eta function"],
            "from_beam": ["FROM BEAM", "RPNBoolean", "0", "compute transformation from tracked beam properties instead of Twiss parameters?"],
            "from_0values": ["FROM 0VALUES", "RPNBoolean", "0", "if non-zero, transformation is from the \"0\" values provided in the element definition"],
            "compute_once": ["COMPUTE ONCE", "RPNBoolean", "0", "compute transformation only for first beam or lattice functions?"],
            "apply_once": ["APPLY ONCE", "RPNBoolean", "1", "apply correction only on first pass through for each beam?"],
            "verbose": ["VERBOSE", "RPNBoolean", "0", "if non-zero, print extra information about transformations"],
            "disable": ["DISABLE", "RPNBoolean", "0", "if non-zero, element is ignored"],
            "betax0": ["BETAX0 [M]", "RPNValue", 1, "initial horizontal beta function (if FROM 0VALUES nonzero)"],
            "alphax0": ["ALPHAX0", "RPNValue", 0, "initial horizontal alpha function (if FROM 0VALUES nonzero)"],
            "etax0": ["ETAX0 [M]", "RPNValue", 0, "initial horizontal eta function (if FROM 0VALUES nonzero)"],
            "etaxp0": ["ETAXP0", "RPNValue", 0, "initial slope of horizontal eta function (if FROM 0VALUES nonzero)"],
            "betay0": ["BETAY0 [M]", "RPNValue", 1, "initial vertical beta function (if FROM 0VALUES nonzero)"],
            "alphay0": ["ALPHAY0", "RPNValue", 0, "initial vertical alpha function (if FROM 0VALUES nonzero)"],
            "etay0": ["ETAY0 [M]", "RPNValue", 0, "initial vertical eta function (if FROM 0VALUES nonzero)"],
            "etayp0": ["ETAYP0", "RPNValue", 0, "initial slope of vertical eta function (if FROM 0VALUES nonzero)"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TWLA": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "frequency": ["FREQUENCY [HZ]", "RPNValue", 2856000000, "frequency"],
            "phase": ["PHASE [RAD]", "RPNValue", 0, "phase"],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "time offset (adds to phase)"],
            "ez": ["EZ [V/M]", "RPNValue", 0, "electric field"],
            "b_solenoid": ["B SOLENOID [T]", "RPNValue", 0, "solenoid field"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy"],
            "x_max": ["X MAX [M]", "RPNValue", 0, "x half-aperture"],
            "y_max": ["Y MAX [M]", "RPNValue", 0, "y half-aperture"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "beta_wave": ["BETA WAVE", "RPNValue", 1, "(phase velocity)/c"],
            "alpha": ["ALPHA [1/M]", "RPNValue", 0, "field attenuation factor"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "n_steps": ["N STEPS", "RPNValue", 100, "number of steps (for nonadaptive integration)"],
            "focussing": ["FOCUSSING", "RPNBoolean", "1", "include focusing effects?"],
            "method": ["METHOD", "TwlaMethod", "runge-kutta", "integration method"],
            "fiducial": ["FIDUCIAL", "TPFiducial", "t,median", ""],
            "change_p0": ["CHANGE P0", "RPNBoolean", "0", "does element change central momentum?"],
            "sum_bn2": ["SUM BN2", "RPNValue", 0, "sum of squares of amplitudes of n!=0 space harmonics"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TWMTA": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "frequency": ["FREQUENCY [HZ]", "RPNValue", 2856000000, "frequency"],
            "phase": ["PHASE [RAD]", "RPNValue", 0, "phase"],
            "ez": ["EZ [V/M]", "RPNValue", 0, "electric field"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy"],
            "x_max": ["X MAX [M]", "RPNValue", 0, "x half-aperture"],
            "y_max": ["Y MAX [M]", "RPNValue", 0, "y half-aperture"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "kx": ["KX [1/M]", "RPNValue", 0, "horizontal wave number"],
            "beta_wave": ["BETA WAVE", "RPNValue", 1, "(phase velocity)/c"],
            "bsol": ["BSOL", "RPNValue", 0, "solenoid field"],
            "alpha": ["ALPHA [1/M]", "RPNValue", 0, "field attenuation factor"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "n_steps": ["N STEPS", "RPNValue", 100, "number of kicks"],
            "method": ["METHOD", "TwmtaMethod", "runge-kutta", "integration method"],
            "fiducial": ["FIDUCIAL", "TPFiducial", "t,median", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "TWPL": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "ramp_time": ["RAMP TIME [S]", "RPNValue", 1e-09, "time to ramp to full strength"],
            "time_offset": ["TIME OFFSET [S]", "RPNValue", 0, "offset of ramp-start time"],
            "voltage": ["VOLTAGE [V]", "RPNValue", 0, "maximum voltage between plates due to ramp"],
            "gap": ["GAP [M]", "RPNValue", 0.01, "gap between plates"],
            "static_voltage": ["STATIC VOLTAGE [V]", "RPNValue", 0, "static component of voltage"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "accuracy": ["ACCURACY", "RPNValue", 0.0001, "integration accuracy"],
            "x_max": ["X MAX [M]", "RPNValue", 0, "x half-aperture"],
            "y_max": ["Y MAX [M]", "RPNValue", 0, "y half-aperture"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "phase_reference": ["PHASE REFERENCE", "RPNValue", 0, "phase reference number (to link with other time-dependent elements)"],
            "n_steps": ["N STEPS", "RPNValue", 100, "number of steps (for nonadaptive integration)"],
            "method": ["METHOD", "TwplMethod", "runge-kutta", "integration method"],
            "fiducial": ["FIDUCIAL", "TPFiducial", "t,median", ""],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "UKICKMAP": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "dz": ["DZ [M]", "RPNValue", 0, "misalignment"],
            "field_factor": ["FIELD FACTOR", "RPNValue", 1, "Factor by which to multiply the magnetic fields."],
            "xy_factor": ["XY FACTOR", "RPNValue", 1, "Factor by which to multiply the x and y values in the input file."],
            "yaw": ["YAW", "RPNValue", 0, "Yaw angle of the device. Meaningful only if N_KICKS is not 1."],
            "input_file": ["INPUT FILE", "InputFile", "", "Name of SDDS file with undulator kickmap data."],
            "n_kicks": ["N KICKS", "RPNValue", 1, "Number of kicks into which to split the element."],
            "periods": ["PERIODS", "RPNValue", 0, "Number of periods (for radiation integral computations only)."],
            "kref": ["KREF", "RPNValue", 0, "Reference value of undulator parameter. K=KREF*FIELD FACTOR is used for radiation integral calculations only assuming period=L/PERIODS."],
            "kactual": ["KACTUAL", "RPNValue", 0, "Value of undulator parameter, used for radiation integral calculations only assuming period=L/PERIODS."],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "yaw_end": ["YAW END", "UkickmapYawEnd", "0", ""],
            "single_period_map": ["SINGLE_PERIOD_MAP", "RPNValue", 0, "if non-zero, the map file is for a single period. L still pertains to the full device. Set N_KICKS to the number of periods."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "VKICK": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "kick": ["KICK [RAD]", "RPNValue", 0, "kick strength"],
            "tilt": ["TILT [RAD]", "RPNValue", 0, "rotation about longitudinal axis"],
            "b2": ["B2 [1/M²]", "RPNValue", 0, "normalized sextupole strength (kick= KICK*(1+B2*y^2))"],
            "calibration": ["CALIBRATION", "RPNValue", 1, "strength multiplier"],
            "edge_effects": ["EDGE EFFECTS", "RPNBoolean", "0", "include edge effects?"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "steering": ["STEERING", "RPNBoolean", "1", "use for steering?"],
            "synch_rad": ["SYNCH RAD", "RPNBoolean", "0", "include classical synchrotron radiation?"],
            "isr": ["ISR", "RPNBoolean", "0", "include incoherent synchrotron radiation (scattering)?"],
            "lerad": ["LERAD", "RPNValue", 0, "if L=0, use this length for radiation computations"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "VMON": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "weight": ["WEIGHT", "RPNValue", 1, "weight in correction"],
            "tilt": ["TILT", "RPNValue", 0, "rotation about longitudinal axis"],
            "calibration": ["CALIBRATION", "RPNValue", 1, "calibration factor for readout"],
            "setpoint": ["SETPOINT [M]", "RPNValue", 0, "steering setpoint"],
            "order": ["ORDER", "RPNValue", 0, "matrix order"],
            "readout": ["READOUT", "OptionalString", "", "rpn expression for readout (actual position supplied in variable y)"],
            "co_fitpoint": ["CO FITPOINT", "RPNBoolean", "0", "If nonzero, then closed orbit value is placed in variable <name>#<occurence>.yco"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "WAKE": {
            "name": ["Name", "ValidatedString"],
            "inputfile": ["INPUTFILE", "InputFile", "", "name of file giving Green function"],
            "tcolumn": ["TCOLUMN", "OptionalString", "", "column in INPUTFILE containing time data"],
            "wcolumn": ["WCOLUMN", "OptionalString", "", "column in INPUTFILE containing Green function"],
            "charge": ["CHARGE [C]", "RPNValue", 0, "beam charge (or use CHARGE element)"],
            "factor": ["FACTOR [C]", "RPNValue", 1, "factor to multiply wake by"],
            "n_bins": ["N BINS", "RPNValue", 128, "number of bins for current histogram"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "0", "interpolate wake?"],
            "smoothing": ["SMOOTHING", "RPNBoolean", "0", "Use Savitzky-Golay filter to smooth current histogram?"],
            "sg_halfwidth": ["SG HALFWIDTH", "RPNValue", 4, "Savitzky-Golay filter half-width for smoothing"],
            "sg_order": ["SG ORDER", "RPNValue", 1, "Savitzky-Golay filter order for smoothing"],
            "change_p0": ["CHANGE P0", "RPNBoolean", "0", "change central momentum?"],
            "allow_long_beam": ["ALLOW LONG BEAM", "RPNBoolean", "0", "allow beam longer than wake data?"],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the wake to full strength."],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, then do calculations bunch-by-bunch."],
            "acausal_allowed": ["ACAUSAL ALLOWED", "RPNBoolean", "0", "If non-zero, then an acausal wake is allowed."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "WATCH": {
            "name": ["Name", "ValidatedString"],
            "fraction": ["FRACTION", "RPNValue", 1, "fraction of particles to dump (coordinate mode)"],
            "start_pid": ["START PID", "RPNValue", -1, "starting particleID for particles to dump"],
            "end_pid": ["END PID", "RPNValue", -1, "ending particleID for particles to dump"],
            "interval": ["INTERVAL", "RPNValue", 1, "interval for data output (in turns)"],
            "start_pass": ["START PASS", "RPNValue", 0, "pass on which to start"],
            "end_pass": ["END PASS", "RPNValue", -1, "pass on which to end (inclusive). Ignored if negative."],
            "filename": ["FILENAME", "OutputFile", "", "output filename, possibly incomplete (see below)"],
            "label": ["LABEL", "OptionalString", "", "output label"],
            "mode": ["MODE", "WatchMode", "coordinate", ""],
            "x_data": ["X DATA", "RPNBoolean", "1", "include x data in coordinate mode?"],
            "y_data": ["Y DATA", "RPNBoolean", "1", "include y data in coordinate mode?"],
            "longit_data": ["LONGIT DATA", "RPNBoolean", "1", "include longitudinal data in coordinate mode?"],
            "exclude_slopes": ["EXCLUDE SLOPES", "RPNBoolean", "0", "exclude slopes in coordinate mode?"],
            "flush_interval": ["FLUSH INTERVAL", "RPNValue", 100, "file flushing interval (parameter or centroid mode)"],
            "sparse_interval": ["SPARSE INTERVAL", "Integer", 1, "interval for particle output (coordinate mode)"],
            "disable": ["DISABLE", "RPNBoolean", "0", "If nonzero, no output will be generated."],
            "use_disconnect": ["USE DISCONNECT", "RPNBoolean", "0", "If nonzero, files are disconnected between each write operation. Maybe useful for parallel operation. Ignored otherwise."],
            "index_offset": ["INDEX OFFSET", "RPNValue", 0, "Offset for file indices for sequential file naming."],
            "reference_frequency": ["REFERENCE FREQUENCY", "RPNValue", -1, "If non-zero, the indicated frequency is used to define the bucket center for purposes of computing time offsets."],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "WIGGLER": {
            "name": ["Name", "ValidatedString"],
            "l": ["L [M]", "RPNValue", 0, "length"],
            "radius": ["RADIUS [M]", "RPNValue", 0, "Peak bending radius. Ignored if K or B is non-negative."],
            "k": ["K", "RPNValue", 0, "Dimensionless strength parameter."],
            "b": ["B [T]", "RPNValue", 0, "Peak vertical magnetic field. Ignored if K is non-negative"],
            "dx": ["DX", "RPNValue", 0, "Misalignment."],
            "dy": ["DY", "RPNValue", 0, "Misalignment."],
            "dz": ["DZ", "RPNValue", 0, "Misalignment."],
            "tilt": ["TILT", "RPNValue", 0, "Rotation about beam axis."],
            "poles": ["POLES", "RPNValue", 0, "Number of wiggler poles"],
            "focusing": ["FOCUSING", "RPNValue", 1, "If 0, turn off vertical focusing (this is unphysical!)"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "ZLONGIT": {
            "name": ["Name", "ValidatedString"],
            "charge": ["CHARGE [C]", "RPNValue", 0, "beam charge (or use CHARGE element)"],
            "broad_band": ["BROAD BAND", "RPNBoolean", "0", "broad-band impedance?"],
            "ra": ["RA [Ohm]", "RPNValue", 0, "shunt impedance, Ra=V^2/P"],
            "rs": ["RS [Ohm]", "RPNValue", 0, "shunt impedance (Rs=Ra/2)"],
            "q": ["Q", "RPNValue", 0, "cavity Q"],
            "freq": ["FREQ [Hz]", "RPNValue", 0, "frequency (BROAD BAND=1)"],
            "zreal": ["ZREAL", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving real part of impedance vs f (BROAD BAND=0)"],
            "zrealX": ["X", "String", ""],
            "zrealY": ["Y", "String", ""],
            "zimag": ["ZIMAG", "InputFileXY", "", "<filename>=<x>+<y>form specification of input file giving imaginary part of impedance vs f (BROAD BAND=0)"],
            "zimagX": ["X", "String", ""],
            "zimagY": ["Y", "String", ""],
            "bin_size": ["BIN SIZE [S]", "RPNValue", 0, "bin size for current histogram (use 0 for autosize)"],
            "n_bins": ["N BINS", "RPNValue", 128, "number of bins for current histogram"],
            "max_n_bins": ["MAX N BINS", "RPNValue", 0, "Maximum number of bins for current histogram"],
            "wakes": ["WAKES", "OutputFile", "", "filename for output of wake"],
            "wake_interval": ["WAKE INTERVAL", "RPNValue", 1, "interval in passes at which to output wake"],
            "wake_start": ["WAKE START", "RPNValue", 0, "pass at which to start to output wake"],
            "wake_end": ["WAKE END", "RPNValue", 9223372036854775807, "pass at which to stop to output wake"],
            "area_weight": ["AREA WEIGHT", "RPNBoolean", "0", "use area-weighting in assigning charge to histogram?"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "0", "interpolate wake?"],
            "smoothing": ["SMOOTHING", "RPNBoolean", "0", "Use Savitzky-Golay filter to smooth current histogram?"],
            "sg_order": ["SG ORDER", "RPNValue", 1, "Savitzky-Golay filter order for smoothing"],
            "sg_halfwidth": ["SG HALFWIDTH", "RPNValue", 4, "Savitzky-Golay filter halfwidth for smoothing"],
            "reverse_time_order": ["REVERSE TIME ORDER", "RPNBoolean", "0", "Reverse time-order of particles for wake computation?"],
            "factor": ["FACTOR", "RPNValue", 1, "Factor by which to multiply impedance."],
            "start_on_pass": ["START ON PASS", "RPNValue", 0, "The pass on which the impedance effects start."],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the impedance to full strength."],
            "high_frequency_cutoff0": ["HIGH FREQUENCY CUTOFF0", "RPNValue", -1, "Frequency at which smoothing filter begins. If not positive, no frequency filter smoothing is done. Frequency is in units of Nyquist (0.5/binsize)."],
            "high_frequency_cutoff1": ["HIGH FREQUENCY CUTOFF1", "RPNValue", -1, "Frequency at which smoothing filter is 0. If not given, defaults to HIGH FREQUENCY CUTOFF0."],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, then do calculations bunch-by-bunch."],
            "allow_long_beam": ["ALLOW LONG BEAM", "RPNBoolean", "0", "Allow beam longer than covered by impedance data?"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        },
        "ZTRANSVERSE": {
            "name": ["Name", "ValidatedString"],
            "charge": ["CHARGE [C]", "RPNValue", 0, "beam charge (or use CHARGE element)"],
            "broad_band": ["BROAD BAND", "RPNBoolean", "0", "broad-band impedance?"],
            "rs": ["RS [Ohm]", "RPNValue", 0, "shunt impedance (Rs=Ra/2=V^2/(2*P))"],
            "q": ["Q", "RPNValue", 0, "cavity Q"],
            "freq": ["FREQ [Hz]", "RPNValue", 0, "frequency (BROAD BAND=1)"],
            "inputfile": ["INPUTFILE", "InputFile", "", "name of file giving impedance (BROAD BAND=0)"],
            "freqcolumn": ["FREQCOLUMN", "OptionalString", "", "column in INPUTFILE containing frequency"],
            "zxreal": ["ZXREAL", "OptionalString", "", "column in INPUTFILE containing real impedance for x plane"],
            "zximag": ["ZXIMAG", "OptionalString", "", "column in INPUTFILE containing imaginary impedance for x plane"],
            "zyreal": ["ZYREAL", "OptionalString", "", "column in INPUTFILE containing real impedance for y plane"],
            "zyimag": ["ZYIMAG", "OptionalString", "", "column in INPUTFILE containing imaginary impedance for y plane"],
            "bin_size": ["BIN SIZE [S]", "RPNValue", 0, "bin size for current histogram (use 0 for autosize)"],
            "interpolate": ["INTERPOLATE", "RPNBoolean", "0", "interpolate wake?"],
            "n_bins": ["N BINS", "RPNValue", 128, "number of bins for current histogram"],
            "max_n_bins": ["MAX N BINS", "RPNValue", 0, "Maximum number of bins for current histogram"],
            "smoothing": ["SMOOTHING", "RPNBoolean", "0", "Use Savitzky-Golay filter to smooth current histogram?"],
            "sg_order": ["SG ORDER", "RPNValue", 1, "Savitzky-Golay filter order for smoothing"],
            "sg_halfwidth": ["SG HALFWIDTH", "RPNValue", 4, "Savitzky-Golay filter halfwidth for smoothing"],
            "dx": ["DX [M]", "RPNValue", 0, "misalignment"],
            "dy": ["DY [M]", "RPNValue", 0, "misalignment"],
            "factor": ["FACTOR", "RPNValue", 1, "Factor by which to multiply x and y impedances."],
            "xfactor": ["XFACTOR", "RPNValue", 1, "Factor by which to multiply x impedance."],
            "yfactor": ["YFACTOR", "RPNValue", 1, "Factor by which to multiply y impedance."],
            "wakes": ["WAKES", "OutputFile", "", "filename for output of wake"],
            "wake_interval": ["WAKE INTERVAL", "RPNValue", 1, "interval in passes at which to output wake"],
            "wake_start": ["WAKE START", "RPNValue", 0, "pass at which to start to output wake"],
            "wake_end": ["WAKE END", "RPNValue", 9223372036854775807, "pass at which to stop to output wake"],
            "start_on_pass": ["START ON PASS", "RPNValue", 0, "The pass on which the impedance effects start."],
            "ramp_passes": ["RAMP PASSES", "RPNValue", 0, "Number of passes over which to linearly ramp up the impedance to full strength."],
            "high_frequency_cutoff0": ["HIGH FREQUENCY CUTOFF0", "RPNValue", -1, "Frequency at which smoothing filter begins. If not positive, no frequency filter smoothing is done. Frequency is in units of Nyquist (0.5/binsize)."],
            "high_frequency_cutoff1": ["HIGH FREQUENCY CUTOFF1", "RPNValue", -1, "Frequency at which smoothing filter is 0. If not given, defaults to HIGH FREQUENCY CUTOFF"],
            "x_drive_exponent": ["X DRIVE EXPONENT", "RPNValue", 1, "Exponent applied to x coordinates of drive particles"],
            "y_drive_exponent": ["Y DRIVE EXPONENT", "RPNValue", 1, "Exponent applied to y coordinates of drive particles"],
            "x_probe_exponent": ["X PROBE EXPONENT", "RPNValue", 0, "Exponent applied to x coordinates of probe particles"],
            "y_probe_exponent": ["Y PROBE EXPONENT", "RPNValue", 0, "Exponent applied to y coordinates of probe particles"],
            "bunched_beam_mode": ["BUNCHED BEAM MODE", "RPNBoolean", "1", "If non-zero, then do calculations bunch-by-bunch."],
            "allow_long_beam": ["ALLOW LONG BEAM", "RPNBoolean", "0", "Allow beam longer than covered by impedance data?"],
            "group": ["GROUP", "OptionalString", "", "Optionally used to assign an element to a group, with a user-defined name. Group names will appear in the parameter output file in the column ElementGroup"]
        }
    },
    "strings": {
        "completionState": ""
    },
    "view": {
        "beamlineReport": {
            "title": "Lattice",
            "hasDataFile": false,
            "advanced": ["notes"]
        },
        "bunch": {
            "title": "Bunch",
            "basic": [
                "bunchSource.inputSource",
                "n_particles_per_bunch",
                "p_central_mev"
            ],
            "advanced": [
                ["Main", [
                    "p_central_mev",
                    "n_particles_per_bunch",
                    "momentum_chirp"
                ]],
                ["Distribution", [
                    "distribution_type",
                    "distribution_cutoff",
                    "enforce_rms_values",
                    "limit_invariants",
                    "limit_in_4d"
                ]],
                ["Emittance", [
                    [
                        ["Horizontal", [
                            "emit_x",
                            "emit_nx",
                            "beta_x",
                            "alpha_x",
                            "eta_x",
                            "etap_x"
                        ]],
                        ["Vertical", [
                            "emit_y",
                            "emit_ny",
                            "beta_y",
                            "alpha_y",
                            "eta_y",
                            "etap_y"
                        ]]
                    ],
                    "longitudinalMethod",
                    "sigma_s",
                    "sigma_dp",
                    "dp_s_coupling",
                    "emit_z",
                    "beta_z",
                    "alpha_z"
                ]],
                ["Halton Sequence", [
                    "halton_sequence",
                    "optimized_halton",
                    "halton_radix",
                    "randomize_order"
                ]],
                ["Position", [
                    "symmetrize",
                    "centroid",
                    "time_start"
                ]]
            ]
        },
        "bunchFile": {
            "title": "Bunch",
            "basic": [
                "bunchSource.inputSource",
                "sourceFile",
                "bunch.p_central_mev"
            ],
            "advanced": []
        },
        "bunchReport": {
            "title": "Bunch Report",
            "advanced": [
                [
                    ["Horizontal", [
                        "x"
                    ]],
                    ["Vertical", [
                        "y"
                    ]]
                ],
                "histogramBins",
                "colorMap",
                "notes"
            ]
        },
        "beamline": {
            "title": "Beamline",
            "advanced": [
                "name"
            ]
        },
        "heatmapFrameAnimation": {
            "model": "elementAnimation",
            "title": "Output Report",
            "advanced": [
                ["Main", [
                    [
                        ["Horizontal", [
                            "x"
                        ]],
                        ["Vertical", [
                            "y1"
                        ]]
                    ],
                    "framesPerSecond",
                    "histogramBins",
                    "aspectRatio",
                    "colorMap",
                    "notes"
                ]],
                ["Plot Range", [
                    "plotRangeType",
                    [
                        ["Horizontal", [
                            "horizontalSize",
                            "horizontalOffset"
                        ]],
                        ["Vertical", [
                            "verticalSize",
                            "verticalOffset"
                        ]]
                    ]
                ]]
            ]
        },
        "parameterTable": {
            "title": "Output Parameters",
            "basic": [
                "file",
                "page"
            ],
            "advanced": []
        },
        "plotFrameAnimation": {
            "model": "elementAnimation",
            "title": "Output Report",
            "advanced": [
                ["Main", [
                    [
                        ["Horizontal", [
                            "x"
                        ]],
                        ["Vertical", [
                            "y1",
                            "y2",
                            "y3"
                        ]]
                    ],
                    "framesPerSecond",
                    "includeLattice",
                    "notes"
                ]],
                ["Plot Range", [
                    "plotRangeType",
                    [
                        ["Horizontal", [
                            "horizontalSize",
                            "horizontalOffset"
                        ]],
                        ["Vertical", [
                            "verticalSize",
                            "verticalOffset"
                        ]]
                    ]
                ]]
            ]
        },
        "simulation": {
            "title": "Simulation",
            "advanced": [
                "name"
            ]
        },
        "simulationStatus": {
            "title": "Simulation Status",
            "basic": [
                "simulation.visualizationBeamlineId"
            ],
            "advanced": [
                "simulation.simulationMode",
                "simulation.visualizationBeamlineId"
            ]
        },
        "twissReport": {
            "title": "Twiss Parameters",
            "advanced": [
                "y1",
                "y2",
                "y3",
                "includeLattice"
            ]
        },
        "command_alter_elements": {
            "title": "alter_elements",
            "description": "modify the value of a parameter for one or more elements",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "item",
                "type",
                "exclude",
                "value",
                "string_value",
                "differential",
                "multiplicative",
                "alter_at_each_step",
                "alter_before_load_parameters",
                "verbose",
                "allow_missing_elements",
                "allow_missing_parameters",
                "start_occurence",
                "end_occurence",
                "s_start",
                "s_end",
                "before",
                "after"
            ]
        },
        "command_amplification_factors": {
            "title": "amplification_factors",
            "description": "compute corrected and uncorrected orbit amplification factors and functions.",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "uncorrected_orbit_function",
                "corrected_orbit_function",
                "kick_function",
                "name",
                "type",
                "item",
                "plane",
                "change",
                "number_to_do",
                "maximum_z"
            ]
        },
        "command_analyze_map": {
            "title": "analyze_map",
            "description": "find the transport matrix up to third order based on particle tracking, based on method described",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "output_order",
                "printout",
                "delta_x",
                "delta_xp",
                "delta_y",
                "delta_yp",
                "delta_s",
                "delta_dp",
                "accuracy_factor",
                "center_on_orbit",
                "verbosity",
                "canonical_variables",
                "printout_order",
                "periodic",
                "beta_x",
                "alpha_x",
                "eta_x",
                "etap_x",
                "beta_y",
                "alpha_y",
                "eta_y",
                "etap_y",
                "n_points",
                "max_fit_order"
            ]
        },
        "command_aperture_data": {
            "title": "aperture_data",
            "description": "specify a file from which to take x and y aperture data vs s.",
            "fieldsPerTab": 8,
            "advanced": [
                "input",
                "periodic",
                "persistent",
                "disable"
            ]
        },
        "command_bunched_beam": {
            "title": "bunched_beam",
            "description": "set up for tracking of particle coordinates with various distributions.",
            "fieldsPerTab": 8,
            "advanced": [
                "bunch",
                "n_particles_per_bunch",
                "time_start",
                "matched_to_cell",
                "emit_x",
                "emit_nx",
                "beta_x",
                "alpha_x",
                "eta_x",
                "etap_x",
                "emit_y",
                "emit_ny",
                "beta_y",
                "alpha_y",
                "eta_y",
                "etap_y",
                "use_twiss_command_values",
                "use_moments_output_values",
                "Po",
                "sigma_dp",
                "sigma_s",
                "dp_s_coupling",
                "emit_z",
                "beta_z",
                "alpha_z",
                "momentum_chirp",
                "one_random_bunch",
                "symmetrize",
                "halton_sequence",
                "halton_radix",
                "optimized_halton",
                "randomize_order",
                "limit_invariants",
                "limit_in_4d",
                "enforce_rms_values",
                "distribution_cutoff",
                "distribution_type",
                "centroid",
                "first_is_fiducial",
                "save_initial_coordinates"
            ]
        },
        "command_change_particle": {
            "title": "change_particle",
            "description": "change the particle type from the default value of \"electron.\"",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "mass_ratio",
                "charge_ratio"
            ]
        },
        "command_change_start": {
            "title": "change_start",
            "description": "change the starting point in a lattice",
            "fieldsPerTab": 8,
            "advanced": [
                "element_name",
                "ring_mode"
            ]
        },
        "command_chaos_map": {
            "title": "chaos_map",
            "description": "compute chaos map from tracking. Note that the number of turns tracked is set by the run_control command.",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "xmin",
                "xmax",
                "ymin",
                "ymax",
                "delta_min",
                "delta_max",
                "nx",
                "ny",
                "ndelta",
                "forward_backward",
                "change_x",
                "change_y",
                "verbosity"
            ]
        },
        "command_chromaticity": {
            "title": "chromaticity",
            "description": "set up for chromaticity correction.",
            "fieldsPerTab": 8,
            "advanced": [
                "sextupoles",
                "exclude",
                "dnux_dp",
                "dnuy_dp",
                "sextupole_tweek",
                "correction_fraction",
                "n_iterations",
                "tolerance",
                "strength_log",
                "change_defined_values",
                "strength_limit",
                "use_perturbed_matrix",
                "exit_on_failure",
                "update_orbit",
                "verbosity",
                "dK2_weight"
            ]
        },
        "command_closed_orbit": {
            "title": "closed_orbit",
            "description": "set up for computation of the closed orbit.",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "output_monitors_only",
                "start_from_centroid",
                "start_from_dp_centroid",
                "closed_orbit_accuracy",
                "closed_orbit_iterations",
                "iteration_fraction",
                "fraction_multiplier",
                "multiplier_interval",
                "fixed_length",
                "start_from_recirc",
                "verbosity",
                "tracking_turns",
                "disable"
            ]
        },
        "command_correct": {
            "title": "correct",
            "description": "set up for correction of the trajectory or closed orbit.",
            "fieldsPerTab": 8,
            "advanced": [
                "mode",
                "method",
                "trajectory_output",
                "corrector_output",
                "statistics",
                "bpm_output",
                "corrector_tweek",
                "corrector_limit",
                "correction_fraction",
                "correction_accuracy",
                "do_correction",
                "remove_smallest_SVs",
                "keep_largest_SVs",
                "minimum_SV_ratio",
                "auto_limit_SVs",
                "remove_pegged",
                "threading_divisor",
                "threading_correctors",
                "bpm_noise",
                "bpm_noise_cutoff",
                "bpm_noise_distribution",
                "verbose",
                "fixed_length",
                "fixed_length_matrix",
                "n_xy_cycles",
                "minimum_cycles",
                "force_alternation",
                "n_iterations",
                "prezero_correctors",
                "track_before_and_after",
                "start_from_centroid",
                "use_actual_beam",
                "closed_orbit_accuracy",
                "closed_orbit_iterations",
                "closed_orbit_iteration_fraction",
                "closed_orbit_tracking_turns",
                "use_perturbed_matrix",
                "disable",
                "use_response_from_computed_orbits"
            ]
        },
        "command_correct_tunes": {
            "title": "correct_tunes",
            "description": "set up for correction of the tunes.",
            "fieldsPerTab": 8,
            "advanced": [
                "quadrupoles",
                "tune_x",
                "tune_y",
                "n_iterations",
                "correction_fraction",
                "tolerance",
                "step_up_interval",
                "max_correction_fraction",
                "delta_correction_fraction",
                "strength_log",
                "change_defined_values",
                "use_perturbed_matrix",
                "dK1_weight"
            ]
        },
        "command_correction_matrix_output": {
            "title": "correction_matrix_output",
            "description": "provide output of the orbit/trajectory correction matrix.",
            "fieldsPerTab": 8,
            "advanced": [
                "response",
                "inverse",
                "KnL_units",
                "BnL_units",
                "output_at_each_step",
                "output_before_tune_correction",
                "fixed_length",
                "coupled",
                "use_response_from_computed_orbits"
            ]
        },
        "command_coupled_twiss_output": {
            "title": "coupled_twiss_output",
            "description": "set up or execute computation of coupled twiss parameters and beam sizes",
            "fieldsPerTab": 8,
            "advanced": [
                "filename",
                "output_at_each_step",
                "emittances_from_twiss_command",
                "emit_x",
                "emittance_ratio",
                "sigma_dp",
                "calculate_3d_coupling",
                "verbosity",
                "concat_order"
            ]
        },
        "command_divide_elements": {
            "title": "divide_elements",
            "description": "define how to subdivide certain beamline elements.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "type",
                "exclude",
                "divisions",
                "maximum_length",
                "clear"
            ]
        },
        "command_elastic_scattering": {
            "title": "elastic_scattering",
            "description": "perform simulation of elastic scattering at multiple s locations, for use in computing elastic gas scattering lifetime and loss distribution",
            "fieldsPerTab": 8,
            "advanced": [
                "losses",
                "output",
                "log_file",
                "theta_min",
                "theta_max",
                "n_theta",
                "n_phi",
                "twiss_scaling",
                "s_start",
                "s_end",
                "include_name_pattern",
                "include_type_pattern",
                "verbosity"
            ]
        },
        "command_error_control": {
            "title": "error_control",
            "description": "overall control of random errors.",
            "fieldsPerTab": 8,
            "advanced": [
                "clear_error_settings",
                "summarize_error_settings",
                "no_errors_for_first_step",
                "error_log",
                "error_factor"
            ]
        },
        "command_error_element": {
            "title": "error_element",
            "description": "assert a random error defintion for the accelerator.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "element_type",
                "item",
                "type",
                "amplitude",
                "cutoff",
                "bind",
                "bind_number",
                "bind_across_names",
                "post_correction",
                "fractional",
                "additive",
                "allow_missing_elements",
                "after",
                "before",
                "sample_file",
                "sample_file_column",
                "sample_mode"
            ]
        },
        "command_find_aperture": {
            "title": "find_aperture",
            "description": "find the aperture in (x, y) space for an accelerator.",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "search_output",
                "boundary",
                "mode",
                "xmin",
                "xmax",
                "xpmin",
                "xpmax",
                "ymin",
                "ymax",
                "ypmin",
                "ypmax",
                "nx",
                "ny",
                "n_splits",
                "split_fraction",
                "desired_resolution",
                "assume_nonincreasing",
                "verbosity",
                "offset_by_orbit",
                "n_lines",
                "optimization_mode",
                "full_plane"
            ]
        },
        "command_floor_coordinates": {
            "title": "floor_coordinates",
            "description": "compute floor coordinates for an accelerator.",
            "fieldsPerTab": 8,
            "advanced": [
                "filename",
                "X0",
                "Z0",
                "theta0",
                "include_vertices",
                "vertices_only",
                "magnet_centers",
                "store_vertices"
            ]
        },
        "command_frequency_map": {
            "title": "frequency_map",
            "description": "compute frequency map from tracking",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "xmin",
                "xmax",
                "ymin",
                "ymax",
                "delta_min",
                "delta_max",
                "nx",
                "ny",
                "ndelta",
                "verbosity",
                "include_changes",
                "quadratic_spacing",
                "full_grid_output"
            ]
        },
        "command_global_settings": {
            "title": "global_settings",
            "description": "change global settings.",
            "fieldsPerTab": 8,
            "advanced": [
                "inhibit_fsync",
                "echo_namelists",
                "mpi_randomization_mode",
                "exact_normalized_emittance",
                "SR_gaussian_limit",
                "inhibit_seed_permutation",
                "log_file",
                "error_log_file",
                "parallel_tracking_based_matrices",
                "share_tracking_based_matrices",
                "tracking_matrix_step_factor",
                "tracking_matrix_points",
                "tracking_matrix_step_size"
            ]
        },
        "command_ignore_elements": {
            "title": "ignore_elements",
            "description": "causes specified elements to be ignored during tracking.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "type",
                "exclude",
                "disable",
                "clear",
                "completely"
            ]
        },
        "command_inelastic_scattering": {
            "title": "inelastic_scattering",
            "description": "perform simulation of inelastic scattering at multiple s locations, for use in computing inelastic gas scattering lifetime and loss distribution",
            "fieldsPerTab": 8,
            "advanced": [
                "losses",
                "output",
                "log_file",
                "k_min",
                "momentum_aperture",
                "momentum_aperture_scale",
                "momentum_aperture_periodicity",
                "n_k",
                "s_start",
                "s_end",
                "include_name_pattern",
                "include_type_pattern",
                "verbosity",
                "soft_failure",
                "allow_watch_file_output"
            ]
        },
        "command_insert_elements": {
            "title": "insert_elements",
            "description": "Insert elements into a beamline at specified locations. This is a convenient way to add elements to a beamline without modifying the lattice file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "type",
                "exclude",
                "s_start",
                "s_end",
                "skip",
                "disable",
                "insert_before",
                "add_at_end",
                "add_at_start",
                "element_def",
                "total_occurrences",
                "occurrence"
            ]
        },
        "command_insert_sceffects": {
            "title": "insert_sceffects",
            "description": "set up for transverse space charge calculation.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "type",
                "exclude",
                "disable",
                "clear",
                "element_prefix",
                "skip",
                "vertical",
                "horizontal",
                "nonlinear",
                "uniform_distribution",
                "verbosity",
                "averaging_factor"
            ]
        },
        "command_ion_effects": {
            "title": "ion_effects",
            "description": "set up for modeling of residual gas ions.",
            "fieldsPerTab": 8,
            "advanced": [
                "pressure_profile",
                "pressure_factor",
                "ion_properties",
                "beam_output",
                "beam_output_all_locations",
                "ion_density_output",
                "ion_output_all_locations",
                "ion_species_output",
                "ion_output_interval",
                "field_calculation_method",
                "distribution_fit_target",
                "distribution_fit_tolerance",
                "distribution_fit_evaluations",
                "distribution_fit_passes",
                "distribution_fit_restarts",
                "hybrid_simplex_comparison_interval",
                "fit_residual_type",
                "macro_ions",
                "symmetrize",
                "generation_interval",
                "multiple_ionization_interval",
                "multiple_ionization_energy_peak",
                "multiple_ionization_energy_rms",
                "ion_span",
                "ion_bin_divisor",
                "ion_range_multiplier",
                "ion_sigma_limit_multiplier",
                "ion_histogram_max_bins",
                "ion_histogram_min_per_bin",
                "ion_histogram_output",
                "ion_histogram_output_s_start",
                "ion_histogram_output_s_end",
                "ion_histogram_output_interval",
                "ion_histogram_min_output_bins",
                "disable_until_pass",
                "freeze_ions_until_pass",
                "freeze_electrons_until_pass",
                "verbosity"
            ]
        },
        "command_linear_chromatic_tracking_setup": {
            "title": "linear_chromatic_tracking_setup",
            "description": "define chromatic variation of beta functions, tunes, etc. for using in fast linear-chromatic tracking",
            "fieldsPerTab": 8,
            "advanced": [
                "nux",
                "betax",
                "alphax",
                "etax",
                "etapx",
                "nuy",
                "betay",
                "alphay",
                "etay",
                "etapy",
                "alphac"
            ]
        },
        "command_link_control": {
            "title": "link_control",
            "description": "overall control of element parameter links.",
            "fieldsPerTab": 8,
            "advanced": [
                "clear_links",
                "summarize_links",
                "verbosity"
            ]
        },
        "command_link_elements": {
            "title": "link_elements",
            "description": "assert a link between parameters of accelerator elements.",
            "fieldsPerTab": 8,
            "advanced": [
                "target",
                "exclude",
                "item",
                "source",
                "source_from_target_edit",
                "source_position",
                "mode",
                "equation",
                "minimum",
                "maximum",
                "exclude_self"
            ]
        },
        "command_load_parameters": {
            "title": "load_parameters",
            "description": "load parameters for elements from an SDDS file.",
            "fieldsPerTab": 8,
            "advanced": [
                "filename",
                "include_name_pattern",
                "exclude_name_pattern",
                "include_item_pattern",
                "exclude_item_pattern",
                "include_type_pattern",
                "exclude_type_pattern",
                "edit_name_command",
                "change_defined_values",
                "clear_settings",
                "allow_missing_elements",
                "allow_missing_parameters",
                "allow_missing_files",
                "force_occurence_data",
                "verbose",
                "skip_pages",
                "use_first"
            ]
        },
        "command_matrix_output": {
            "title": "matrix_output",
            "description": "generate matrix output, or set up to do so later.",
            "fieldsPerTab": 8,
            "advanced": [
                "printout",
                "printout_order",
                "full_matrix_only",
                "print_element_data",
                "mathematica_full_matrix",
                "mathematica_matrix_name",
                "mathematica_matrix_file",
                "SDDS_output",
                "SDDS_output_order",
                "individual_matrices",
                "SDDS_output_match",
                "output_at_each_step",
                "start_from",
                "start_from_occurence"
            ]
        },
        "command_modulate_elements": {
            "title": "modulate_elements",
            "description": "define parameters for time-dependent modulation of elements",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "item",
                "type",
                "expression",
                "filename",
                "time_column",
                "convert_pass_to_time",
                "amplitude_column",
                "refresh_matrix",
                "differential",
                "multiplicative",
                "start_occurence",
                "end_occurence",
                "s_start",
                "s_end",
                "before",
                "after",
                "verbose",
                "verbose_threshold",
                "record",
                "flush_record"
            ]
        },
        "command_moments_output": {
            "title": "moments_output",
            "description": "compute periodic or propagate non-periodic beam moments without tracking, optionally including radiation.",
            "fieldsPerTab": 8,
            "advanced": [
                "filename",
                "output_at_each_step",
                "output_before_tune_correction",
                "final_values_only",
                "verbosity",
                "matched",
                "equilibrium",
                "radiation",
                "n_slices",
                "slice_etilted",
                "emit_x",
                "beta_x",
                "alpha_x",
                "eta_x",
                "etap_x",
                "emit_y",
                "beta_y",
                "alpha_y",
                "eta_y",
                "etap_y",
                "emit_z",
                "beta_z",
                "alpha_z"
            ]
        },
        "command_momentum_aperture": {
            "title": "momentum_aperture",
            "description": "determine momentum aperture as a function of position in the lattice by tracking",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "x_initial",
                "y_initial",
                "delta_negative_start",
                "delta_positive_start",
                "delta_negative_limit",
                "delta_positive_limit",
                "delta_step_size",
                "steps_back",
                "splits",
                "split_step_divisor",
                "skip_elements",
                "process_elements",
                "s_start",
                "s_end",
                "include_name_pattern",
                "include_type_pattern",
                "fiducialize",
                "verbosity",
                "soft_failure",
                "output_mode",
                "forbid_resonance_crossing"
            ]
        },
        "command_obstruction_data": {
            "title": "obstruction_data",
            "description": "define obstructions in the global coordinate system (Z,X)",
            "fieldsPerTab": 8,
            "advanced": [
                "input",
                "periods",
                "disable",
                "y_spacing",
                "y_limit"
            ]
        },
        "command_optimization_constraint": {
            "title": "optimization_constraint",
            "description": "define a constraint for optimization.",
            "fieldsPerTab": 8,
            "advanced": [
                "quantity",
                "lower",
                "upper"
            ]
        },
        "command_optimization_covariable": {
            "title": "optimization_covariable",
            "description": "define an element parameter to be varied as a function of optimization parameters.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "item",
                "equation",
                "disable"
            ]
        },
        "command_optimization_setup": {
            "title": "optimization_setup",
            "description": "define overall optimization parameters and methods.",
            "fieldsPerTab": 8,
            "advanced": [
                "equation",
                "mode",
                "method",
                "tolerance",
                "target",
                "center_on_orbit",
                "center_momentum_also",
                "soft_failure",
                "n_passes",
                "n_evaluations",
                "n_restarts",
                "matrix_order",
                "log_file",
                "term_log_file",
                "output_sparsing_factor",
                "balance_terms",
                "restart_worst_term_factor",
                "restart_worst_terms",
                "verbose",
                "simplex_divisor",
                "simplex_pass_range_factor",
                "include_simplex_1d_scans",
                "start_from_simplex_vertex1",
                "restart_random_numbers"
            ]
        },
        "command_optimization_term": {
            "title": "optimization_term",
            "description": "define optimization equation via individual terms",
            "fieldsPerTab": 8,
            "advanced": [
                "term",
                "weight",
                "field_string",
                "field_initial_value",
                "field_final_value",
                "field_interval",
                "input_file",
                "input_column",
                "verbose"
            ]
        },
        "command_optimization_variable": {
            "title": "optimization_variable",
            "description": "defines a parameter of an element to be used in optimization.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "item",
                "lower_limit",
                "upper_limit",
                "differential_limits",
                "step_size",
                "disable",
                "force_inside",
                "no_element",
                "initial_value"
            ]
        },
        "command_optimize": {
            "title": "optimize",
            "description": "perform optimization.",
            "fieldsPerTab": 8,
            "advanced": [
                "summarize_setup"
            ]
        },
        "command_parallel_optimization_setup": {
            "title": "parallel_optimization_setup",
            "description": "define overall parallel optimization parameters and methods.",
            "fieldsPerTab": 8,
            "advanced": [
                "method",
                "hybrid_simplex_tolerance",
                "hybrid_simplex_tolerance_count",
                "hybrid_simplex_comparison_interval",
                "random_factor",
                "n_iterations",
                "max_no_change",
                "population_size",
                "population_log",
                "print_all_individuals",
                "output_sparsing_factor",
                "crossover",
                "simplex_log",
                "simplex_log_interval"
            ]
        },
        "command_print_dictionary": {
            "title": "print_dictionary",
            "description": "print dictionary of supported accelerator elements.",
            "fieldsPerTab": 8,
            "advanced": [
                "filename",
                "SDDS_form"
            ]
        },
        "command_ramp_elements": {
            "title": "ramp_elements",
            "description": "define parameters for time-dependent ramping of elements",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "item",
                "type",
                "start_pass",
                "end_pass",
                "start_value",
                "end_value",
                "refresh_matrix",
                "differential",
                "multiplicative",
                "start_occurence",
                "end_occurence",
                "exponent",
                "s_start",
                "s_end",
                "before",
                "after",
                "verbose",
                "record"
            ]
        },
        "command_replace_elements": {
            "title": "replace_elements",
            "description": "Replace old element with a newly defined element, or just or just remove it from beamline.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "type",
                "exclude",
                "skip",
                "disable",
                "element_def",
                "total_occurrences",
                "occurrence"
            ]
        },
        "command_rf_setup": {
            "title": "rf_setup",
            "description": "set up rf cavity frequency, phase, and voltage for a storage ring",
            "fieldsPerTab": 8,
            "advanced": [
                "filename",
                "name",
                "start_occurence",
                "end_occurence",
                "s_start",
                "s_end",
                "set_for_each_step",
                "near_frequency",
                "harmonic",
                "bucket_half_height",
                "over_voltage",
                "total_voltage",
                "disable",
                "output_only",
                "track_for_frequency"
            ]
        },
        "command_rpn_expression": {
            "title": "rpn_expression",
            "description": "pass an expression directly to the rpn submodule for execution.",
            "fieldsPerTab": 8,
            "advanced": [
                "expression"
            ]
        },
        "command_rpn_load": {
            "title": "rpn_load",
            "description": "load data from SDDS file into RPN variables.",
            "fieldsPerTab": 8,
            "advanced": [
                "tag",
                "filename",
                "match_column",
                "match_column_value",
                "matching_row_number",
                "match_parameter",
                "match_parameter_value",
                "use_row",
                "use_page",
                "load_parameters"
            ]
        },
        "command_run_control": {
            "title": "run_control",
            "description": "set up the number of simulation steps and passes.",
            "fieldsPerTab": 8,
            "advanced": [
                "n_steps",
                "bunch_frequency",
                "n_indices",
                "n_passes",
                "n_passes_fiducial",
                "reset_rf_for_each_step",
                "first_is_fiducial",
                "restrict_fiducialization"
            ]
        },
        "command_run_setup": {
            "title": "run_setup",
            "description": "set global parameters of the simulation and define primary input and output files.",
            "fieldsPerTab": 8,
            "advanced": [
                "lattice",
                "use_beamline",
                "output",
                "centroid",
                "sigma",
                "final",
                "acceptance",
                "losses",
                "losses_include_global_coordinates",
                "magnets",
                "parameters",
                "rfc_reference_output",
                "combine_bunch_statistics",
                "wrap_around",
                "final_pass",
                "default_order",
                "concat_order",
                "print_statistics",
                "show_element_timing",
                "monitor_memory_usage",
                "random_number_seed",
                "correction_iterations",
                "p_central",
                "p_central_mev",
                "always_change_p0",
                "expand_for",
                "tracking_updates",
                "echo_lattice",
                "element_divisions",
                "load_balancing_on",
                "back_tracking"
            ]
        },
        "command_sasefel": {
            "title": "sasefel",
            "description": "set parameters for computation of SASE FEL gain and other properties.",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "model",
                "beta",
                "undulator_K",
                "undulator_period",
                "slice_fraction",
                "n_slices"
            ]
        },
        "command_save_lattice": {
            "title": "save_lattice",
            "description": "save the current accelerator element and beamline definitions.",
            "fieldsPerTab": 8,
            "advanced": [
                "filename",
                "output_seq"
            ]
        },
        "command_sdds_beam": {
            "title": "sdds_beam",
            "description": "set up for tracking and histogram analyzing of particle coordinates stored in an SDDS file.",
            "fieldsPerTab": 8,
            "advanced": [
                "input",
                "input_type",
                "n_particles_per_ring",
                "selection_parameter",
                "selection_string",
                "one_random_bunch",
                "reuse_bunch",
                "prebunched",
                "track_pages_separately",
                "use_bunched_mode",
                "fiducialization_bunch",
                "sample_interval",
                "n_tables_to_skip",
                "center_transversely",
                "center_arrival_time",
                "sample_fraction",
                "p_lower",
                "p_upper",
                "save_initial_coordinates",
                "reverse_t_sign",
                "n_duplicates",
                "duplicate_stagger"
            ]
        },
        "command_set_reference_particle_output": {
            "title": "set_reference_particle_output",
            "description": "Allows defining a reference set of particle coordinates to which tracked coordinates will be compared for purposes of optimization.",
            "fieldsPerTab": 8,
            "advanced": [
                "match_to",
                "weight",
                "comparison_mode"
            ]
        },
        "command_slice_analysis": {
            "title": "slice_analysis",
            "description": "set parameters for slice analysis of the beam along a a beamline.",
            "fieldsPerTab": 8,
            "advanced": [
                "output",
                "n_slices",
                "s_start",
                "s_end",
                "final_values_only"
            ]
        },
        "command_steering_element": {
            "title": "steering_element",
            "description": "setup for use of a given parameter of a given element as a steering corrector.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "element_type",
                "item",
                "plane",
                "tweek",
                "limit",
                "start_occurence",
                "end_occurence",
                "occurence_step",
                "s_start",
                "s_end",
                "before",
                "after"
            ]
        },
        "command_touschek_scatter": {
            "title": "touschek_scatter",
            "description": "Simulate Touschek scattering process at each TSCATTER element",
            "fieldsPerTab": 8,
            "advanced": [
                "charge",
                "frequency",
                "emit_x",
                "emit_nx",
                "emit_y",
                "emit_ny",
                "sigma_dp",
                "sigma_s",
                "distribution_cutoff",
                "Momentum_Aperture_scale",
                "Momentum_Aperture",
                "XDist",
                "YDist",
                "ZDist",
                "TranDist",
                "FullDist",
                "bunch",
                "loss",
                "distribution",
                "initial",
                "output",
                "nbins",
                "sbin_step",
                "n_simulated",
                "ignored_portion",
                "i_start",
                "i_end",
                "do_track",
                "match_position_only",
                "overwrite_files",
                "verbosity"
            ]
        },
        "command_track": {
            "title": "track",
            "description": "track particles.",
            "fieldsPerTab": 8,
            "advanced": [
                "center_on_orbit",
                "center_momentum_also",
                "offset_by_orbit",
                "offset_momentum_also",
                "soft_failure",
                "use_linear_chromatic_matrix",
                "longitudinal_ring_only",
                "stop_tracking_particle_limit",
                "check_beam_structure"
            ]
        },
        "command_transmute_elements": {
            "title": "transmute_elements",
            "description": "Changes the type of selected elements, which may be used to turn off unneeded diagnostics and speed up tracking when concatenation is being used.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "type",
                "exclude",
                "new_type",
                "disable",
                "clear"
            ]
        },
        "command_tune_footprint": {
            "title": "tune_footprint",
            "description": "compute frequency map from tracking and use it to determine the chromatic and amplitude tune footprints.",
            "fieldsPerTab": 8,
            "advanced": [
                "delta_output",
                "xy_output",
                "xmin",
                "xmax",
                "ymin",
                "ymax",
                "x_for_delta",
                "y_for_delta",
                "delta_min",
                "delta_max",
                "nx",
                "ny",
                "ndelta",
                "separate_xy_for_delta",
                "verbosity",
                "quadratic_spacing",
                "compute_diffusion",
                "diffusion_rate_limit",
                "immediate",
                "filtered_output",
                "ignore_half_integer"
            ]
        },
        "command_tune_shift_with_amplitude": {
            "title": "tune_shift_with_amplitude",
            "description": "prepare for computation of tune shifts with amplitude.",
            "fieldsPerTab": 8,
            "advanced": [
                "turns",
                "x0",
                "y0",
                "x1",
                "y1",
                "grid_size",
                "lines_only",
                "sparse_grid",
                "spread_only",
                "nux_roi_width",
                "nuy_roi_width",
                "scale_down_factor",
                "scale_up_factor",
                "scale_down_limit",
                "scale_up_limit",
                "scaling_iterations",
                "use_concatenation",
                "verbose",
                "order",
                "tune_output"
            ]
        },
        "command_twiss_analysis": {
            "title": "twiss_analysis",
            "description": "analyze Twiss parameters within a user-defined region for purposes of optimization.",
            "fieldsPerTab": 8,
            "advanced": [
                "match_name",
                "start_name",
                "end_name",
                "s_start",
                "s_end",
                "tag",
                "verbosity",
                "clear"
            ]
        },
        "command_twiss_output": {
            "title": "twiss_output",
            "description": "compute and output uncoupled Twiss parameters, or set up to do so.",
            "fieldsPerTab": 8,
            "advanced": [
                "filename",
                "matched",
                "output_at_each_step",
                "output_before_tune_correction",
                "final_values_only",
                "statistics",
                "radiation_integrals",
                "concat_order",
                "higher_order_chromaticity",
                "higher_order_chromaticity_points",
                "higher_order_chromaticity_range",
                "chromatic_tune_spread_half_range",
                "quick_higher_order_chromaticity",
                "beta_x",
                "alpha_x",
                "eta_x",
                "etap_x",
                "beta_y",
                "alpha_y",
                "eta_y",
                "etap_y",
                "reference_file",
                "reference_element",
                "reference_element_occurrence",
                "reflect_reference_values",
                "cavities_are_drifts_if_matched",
                "compute_driving_terms",
                "leading_order_driving_terms_only",
                "s_dependent_driving_terms_file",
                "local_dispersion"
            ]
        },
        "command_vary_element": {
            "title": "vary_element",
            "description": "define an index and/or tie a parameter of an element to it.",
            "fieldsPerTab": 8,
            "advanced": [
                "index_number",
                "index_limit",
                "name",
                "item",
                "initial",
                "final",
                "differential",
                "multiplicative",
                "geometric",
                "enumeration_file",
                "enumeration_column"
            ]
        },
        "ALPH": {
            "title": "ALPH",
            "description": "An alpha magnet implemented as a matrix, up to 3rd order. PART is used to split the magnet into halves. XS<n>and DP<n>allow momentum filtration at the midpoint.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "xmax",
                "xs1",
                "xs2",
                "dp1",
                "dp2",
                "xpuck",
                "widthpuck",
                "dx",
                "dy",
                "dz",
                "tilt",
                "part",
                "order",
                "group"
            ]
        },
        "APCONTOUR": {
            "title": "APCONTOUR",
            "description": "An aperture (or its inverse) defined by (x, y) points in an SDDS file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "tilt",
                "dx",
                "dy",
                "dz",
                "resolution",
                "invert",
                "sticky",
                "cancel",
                "filename",
                "xcolumn",
                "ycolumn",
                "group"
            ]
        },
        "BGGEXP": {
            "title": "BGGEXP",
            "description": "A straight magnetic field element using generalized gradient expansion.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "lfield",
                "filename",
                "normal_filename",
                "skew_filename",
                "strength",
                "tilt",
                "dx",
                "dy",
                "dz",
                "bx",
                "by",
                "maximum_m",
                "maximum_2n",
                "z_interval",
                "symplectic",
                "synch_rad",
                "isr",
                "particle_output_file",
                "is_bend",
                "xvertex",
                "zvertex",
                "xentry",
                "zentry",
                "xexit",
                "zexit",
                "dxexpansion",
                "group"
            ]
        },
        "BMAPXY": {
            "title": "BMAPXY",
            "description": "A map of Bx and By vs x and y.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "strength",
                "accuracy",
                "method",
                "filename",
                "fx",
                "fy",
                "group"
            ]
        },
        "BMXYZ": {
            "title": "BMXYZ",
            "description": "A map of (Bx, By, Bz) vs (x, y, z), for straight elements only",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "dx",
                "dy",
                "dz",
                "tilt",
                "lfield",
                "strength",
                "fse",
                "accuracy",
                "method",
                "filename",
                "synch_rad",
                "check_fields",
                "inject_at_z0",
                "drift_matrix",
                "xy_interpolation_order",
                "xy_grid_excess",
                "single_precision",
                "particle_output_file",
                "group"
            ]
        },
        "BRANCH": {
            "title": "BRANCH",
            "description": "Conditional branch instruction to jump to another part of the beamline",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "counter",
                "interval",
                "offset",
                "verbosity",
                "default_to_else",
                "branch_to",
                "else_to",
                "group"
            ]
        },
        "BOFFAXE": {
            "title": "BOFFAXE",
            "description": "A straight magnetic field element using off-axis expansion from an on-axis derivative.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "lfield",
                "filename",
                "z_column",
                "field_column",
                "order",
                "expansion_order",
                "strength",
                "tilt",
                "dx",
                "dy",
                "dz",
                "bx",
                "by",
                "z_interval",
                "z_subdivisions",
                "synch_rad",
                "isr",
                "particle_output_file",
                "group"
            ]
        },
        "BRAT": {
            "title": "BRAT",
            "description": "Bending magnet Ray Tracing using (Bx, By, Bz) vs (x, y, z).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "fse",
                "accuracy",
                "filename",
                "xvertex",
                "zvertex",
                "xentry",
                "zentry",
                "xexit",
                "zexit",
                "dxmap",
                "dzmap",
                "yawmap",
                "factor",
                "delta_by_inside",
                "use_ftable",
                "xy_interpolation_order",
                "xy_grid_excess",
                "xy_extrapolate",
                "use_sben_matrix",
                "single_precision",
                "particle_output_file",
                "particle_output_lost_only",
                "particle_output_selection_interval",
                "particle_output_sample_interval",
                "group"
            ]
        },
        "BUMPER": {
            "title": "BUMPER",
            "description": "A time-dependent kicker magnet with optional spatial dependence of the kick and no fringe effects. The waveform is in SDDS format, with time in seconds and amplitude normalized to 1. The optional spatial dependence is also specified as an SDDS file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "tilt",
                "dx",
                "dy",
                "dz",
                "b2",
                "time_offset",
                "periodic",
                "phase_reference",
                "fire_on_pass",
                "n_kicks",
                "waveform",
                "deflection_map",
                "group"
            ]
        },
        "CCBEND": {
            "title": "CCBEND",
            "description": "A canonically-integrated straight dipole magnet, assumed to have multipoles defined in Cartesian coordinates.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "k1",
                "k2",
                "k3",
                "k4",
                "k5",
                "k6",
                "k7",
                "k8",
                "tilt",
                "yaw",
                "hgap",
                "fint1",
                "fint2",
                "dx",
                "dy",
                "dz",
                "xkick",
                "fse",
                "fse_dipole",
                "fse_quadrupole",
                "etilt",
                "n_kicks",
                "integration_order",
                "systematic_multipoles",
                "edge_multipoles",
                "edge1_multipoles",
                "edge2_multipoles",
                "random_multipoles",
                "systematic_multipole_factor",
                "random_multipole_factor",
                "reference_order",
                "min_normal_order",
                "min_skew_order",
                "max_normal_order",
                "max_skew_order",
                "synch_rad",
                "isr",
                "isr1part",
                "use_rad_dist",
                "add_opening_angle",
                "optimize_fse",
                "optimize_dx",
                "optimize_fse_once",
                "optimize_dx_once",
                "compensate_kn",
                "edge_order",
                "dx_dy_sign",
                "verbose",
                "group"
            ]
        },
        "CENTER": {
            "title": "CENTER",
            "description": "An element that centers the beam transversely on the ideal trajectory.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "x",
                "xp",
                "y",
                "yp",
                "s",
                "delta",
                "t",
                "once_only",
                "on_pass",
                "group"
            ]
        },
        "CEPL": {
            "title": "CEPL",
            "description": "A numerically-integrated linearly-ramped electric field deflector.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "ramp_time",
                "time_offset",
                "voltage",
                "gap",
                "static_voltage",
                "tilt",
                "accuracy",
                "x_max",
                "y_max",
                "dx",
                "dy",
                "phase_reference",
                "n_steps",
                "method",
                "fiducial",
                "group"
            ]
        },
        "CHARGE": {
            "title": "CHARGE",
            "description": "An element to establish the total charge of a beam. Active on first pass only. If given,overrides all charge specifications on other elements.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "total",
                "per_particle",
                "allow_total_change",
                "group"
            ]
        },
        "CLEAN": {
            "title": "CLEAN",
            "description": "Cleans the beam by removing outlier particles.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "mode",
                "xlimit",
                "xplimit",
                "ylimit",
                "yplimit",
                "tlimit",
                "deltalimit",
                "group"
            ]
        },
        "CORGPIPE": {
            "title": "CORGPIPE",
            "description": "A corrugated round pipe, commonly used as a dechirper in linacs.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "radius",
                "period",
                "gap",
                "depth",
                "dt",
                "tmax",
                "n_bins",
                "interpolate",
                "smoothing",
                "sg_halfwidth",
                "sg_order",
                "change_p0",
                "allow_long_beam",
                "ramp_passes",
                "group"
            ]
        },
        "CSBEND": {
            "title": "CSBEND",
            "description": "A canonical kick sector dipole magnet.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "k1",
                "k2",
                "k3",
                "k4",
                "k5",
                "k6",
                "k7",
                "k8",
                "e1",
                "e2",
                "tilt",
                "h1",
                "h2",
                "hgap",
                "fint",
                "fint1",
                "fint2",
                "dx",
                "dy",
                "dz",
                "xkick",
                "ykick",
                "fse",
                "fse_dipole",
                "fse_quadrupole",
                "etilt",
                "n_kicks",
                "etilt_sign",
                "nonlinear",
                "synch_rad",
                "edge1_effects",
                "edge2_effects",
                "edge_order",
                "integration_order",
                "expand_hamiltonian",
                "edge1_kick_limit",
                "edge2_kick_limit",
                "kick_limit_scaling",
                "use_bn",
                "expansion_order",
                "b1",
                "b2",
                "b3",
                "b4",
                "b5",
                "b6",
                "b7",
                "b8",
                "xreference",
                "f1",
                "f2",
                "f3",
                "f4",
                "f5",
                "f6",
                "f7",
                "f8",
                "g1",
                "g2",
                "g3",
                "g4",
                "g5",
                "g6",
                "g7",
                "g8",
                "isr",
                "isr1part",
                "sqrt_order",
                "use_rad_dist",
                "add_opening_angle",
                "photon_output_file",
                "photon_low_energy_cutoff",
                "reference_correction",
                "tracking_matrix",
                "fse_correction",
                "group"
            ]
        },
        "CSRCSBEND": {
            "title": "CSRCSBEND",
            "description": "Like CSBEND, but incorporates a simulation of Coherent Synchrotron radiation.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "k1",
                "k2",
                "k3",
                "k4",
                "k5",
                "k6",
                "k7",
                "k8",
                "e1",
                "e2",
                "tilt",
                "h1",
                "h2",
                "hgap",
                "fint",
                "dx",
                "dy",
                "dz",
                "fse",
                "etilt",
                "n_kicks",
                "etilt_sign",
                "nonlinear",
                "linearize",
                "synch_rad",
                "edge1_effects",
                "edge2_effects",
                "edge_order",
                "integration_order",
                "bins",
                "bin_once",
                "bin_range_factor",
                "sg_halfwidth",
                "sg_order",
                "sgderiv_halfwidth",
                "sgderiv_order",
                "trapazoid_integration",
                "output_file",
                "output_interval",
                "output_last_wake_only",
                "steady_state",
                "igf",
                "use_bn",
                "expansion_order",
                "b1",
                "b2",
                "b3",
                "b4",
                "b5",
                "b6",
                "b7",
                "b8",
                "isr",
                "isr1part",
                "csr",
                "block_csr",
                "derbenev_criterion_mode",
                "particle_output_file",
                "particle_output_interval",
                "slice_analysis_interval",
                "low_frequency_cutoff0",
                "low_frequency_cutoff1",
                "high_frequency_cutoff0",
                "high_frequency_cutoff1",
                "clip_negative_bins",
                "wake_filter_file",
                "wff_freq_column",
                "wff_real_column",
                "wff_imag_column",
                "group"
            ]
        },
        "CSRDRIFT": {
            "title": "CSRDRIFT",
            "description": "A follow-on element for CSRCSBEND that applies the CSR wake over a drift.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "attenuation_length",
                "dz",
                "n_kicks",
                "spread",
                "use_overtaking_length",
                "ol_multiplier",
                "use_saldin54",
                "saldin54points",
                "csr",
                "saldin54norm_mode",
                "spread_mode",
                "wavelength_mode",
                "bunchlength_mode",
                "saldin54_output",
                "use_stupakov",
                "stupakov_output",
                "stupakov_output_interval",
                "slice_analysis_interval",
                "linearize",
                "lsc_bins",
                "lsc_interpolate",
                "lsc_low_frequency_cutoff0",
                "lsc_low_frequency_cutoff1",
                "lsc_high_frequency_cutoff0",
                "lsc_high_frequency_cutoff1",
                "lsc_radius_factor",
                "group"
            ]
        },
        "CWIGGLER": {
            "title": "CWIGGLER",
            "description": "Tracks through a wiggler using canonical integration routines of Y.Wu (Duke University).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "b_max",
                "bx_max",
                "by_max",
                "tgu_gradient",
                "tgu_comp_factor",
                "pole1_factor",
                "pole2_factor",
                "pole3_factor",
                "dx",
                "dy",
                "dz",
                "tilt",
                "periods",
                "steps_per_period",
                "integration_order",
                "by_file",
                "bx_file",
                "by_split_pole",
                "bx_split_pole",
                "synch_rad",
                "isr",
                "isr1part",
                "sinusoidal",
                "vertical",
                "helical",
                "tgu",
                "force_matched",
                "field_output",
                "verbosity",
                "group"
            ]
        },
        "DRIF": {
            "title": "DRIF",
            "description": "A drift space implemented as a matrix, up to 2nd order",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "order",
                "group"
            ]
        },
        "DSCATTER": {
            "title": "DSCATTER",
            "description": "A scattering element to add random changes to particle coordinates according to a user-supplied distribution function",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "plane",
                "filename",
                "valuename",
                "cdfname",
                "pdfname",
                "onceperparticle",
                "factor",
                "probability",
                "groupid",
                "randomsign",
                "limitperpass",
                "limittotal",
                "startonpass",
                "endonpass",
                "group"
            ]
        },
        "ECOL": {
            "title": "ECOL",
            "description": "An elliptical collimator.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "x_max",
                "y_max",
                "dx",
                "dy",
                "open_side",
                "exponent",
                "yexponent",
                "invert",
                "group"
            ]
        },
        "EDRIFT": {
            "title": "EDRIFT",
            "description": "Tracks through adrift with no approximations (Exact DRIFT).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "group"
            ]
        },
        "EHKICK": {
            "title": "EHKICK",
            "description": "A horizontal steering dipole implemented using an exact hard-edge model",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "kick",
                "tilt",
                "dx",
                "dy",
                "dz",
                "calibration",
                "steering",
                "synch_rad",
                "isr",
                "lerad",
                "steering_multipoles",
                "random_multipoles",
                "random_multipole_factor",
                "steering_multipole_factor",
                "group"
            ]
        },
        "EKICKER": {
            "title": "EKICKER",
            "description": "A combined horizontal/vertical steering dipole implemented using an exact hard-edge model",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "hkick",
                "vkick",
                "tilt",
                "dx",
                "dy",
                "dz",
                "hcalibration",
                "vcalibration",
                "steering",
                "synch_rad",
                "isr",
                "lerad",
                "steering_multipoles",
                "random_multipoles",
                "random_multipole_factor",
                "steering_multipole_factor",
                "group"
            ]
        },
        "ELSE": {
            "title": "ELSE",
            "description": "Not implemented.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "group"
            ]
        },
        "EMATRIX": {
            "title": "EMATRIX",
            "description": "Explicit matrix input with data in the element definition, rather than in a file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "dx",
                "dy",
                "dz",
                "tilt",
                "yaw",
                "pitch",
                "order",
                "c1",
                "c2",
                "c3",
                "c4",
                "c5",
                "c6",
                "deltap",
                "r11",
                "r12",
                "r13",
                "r14",
                "r15",
                "r16",
                "r21",
                "r22",
                "r23",
                "r24",
                "r25",
                "r26",
                "r31",
                "r32",
                "r33",
                "r34",
                "r35",
                "r36",
                "r41",
                "r42",
                "r43",
                "r44",
                "r45",
                "r46",
                "r51",
                "r52",
                "r53",
                "r54",
                "r55",
                "r56",
                "r61",
                "r62",
                "r63",
                "r64",
                "r65",
                "r66",
                "t111",
                "t121",
                "t122",
                "t131",
                "t132",
                "t133",
                "t141",
                "t142",
                "t143",
                "t144",
                "t151",
                "t152",
                "t153",
                "t154",
                "t155",
                "t161",
                "t162",
                "t163",
                "t164",
                "t165",
                "t166",
                "t211",
                "t221",
                "t222",
                "t231",
                "t232",
                "t233",
                "t241",
                "t242",
                "t243",
                "t244",
                "t251",
                "t252",
                "t253",
                "t254",
                "t255",
                "t261",
                "t262",
                "t263",
                "t264",
                "t265",
                "t266",
                "t311",
                "t321",
                "t322",
                "t331",
                "t332",
                "t333",
                "t341",
                "t342",
                "t343",
                "t344",
                "t351",
                "t352",
                "t353",
                "t354",
                "t355",
                "t361",
                "t362",
                "t363",
                "t364",
                "t365",
                "t366",
                "t411",
                "t421",
                "t422",
                "t431",
                "t432",
                "t433",
                "t441",
                "t442",
                "t443",
                "t444",
                "t451",
                "t452",
                "t453",
                "t454",
                "t455",
                "t461",
                "t462",
                "t463",
                "t464",
                "t465",
                "t466",
                "t511",
                "t521",
                "t522",
                "t531",
                "t532",
                "t533",
                "t541",
                "t542",
                "t543",
                "t544",
                "t551",
                "t552",
                "t553",
                "t554",
                "t555",
                "t561",
                "t562",
                "t563",
                "t564",
                "t565",
                "t566",
                "t611",
                "t621",
                "t622",
                "t631",
                "t632",
                "t633",
                "t641",
                "t642",
                "t643",
                "t644",
                "t651",
                "t652",
                "t653",
                "t654",
                "t655",
                "t661",
                "t662",
                "t663",
                "t664",
                "t665",
                "t666",
                "group"
            ]
        },
        "EMITTANCE": {
            "title": "EMITTANCE",
            "description": "Applies a linear transformation to the beam to force the emittance to given values.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "emitx",
                "emity",
                "emitnx",
                "emitny",
                "group"
            ]
        },
        "ENERGY": {
            "title": "ENERGY",
            "description": "An element that matches the central momentum to the beam momentum, or changes the central momentum or energy to a specified value.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "central_energy",
                "central_momentum",
                "match_beamline",
                "match_particles",
                "group"
            ]
        },
        "EVKICK": {
            "title": "EVKICK",
            "description": "A vertical steering dipole implemented using an exact hard-edge model",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "kick",
                "tilt",
                "dx",
                "dy",
                "dz",
                "calibration",
                "steering",
                "synch_rad",
                "isr",
                "lerad",
                "steering_multipoles",
                "random_multipoles",
                "random_multipole_factor",
                "steering_multipole_factor",
                "group"
            ]
        },
        "FLOOR": {
            "title": "FLOOR",
            "description": "Sets floor coordinates",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "x",
                "y",
                "z",
                "theta",
                "phi",
                "psi",
                "group"
            ]
        },
        "FMULT": {
            "title": "FMULT",
            "description": "Multipole kick element with coefficient input from an SDDS file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "tilt",
                "dx",
                "dy",
                "dz",
                "fse",
                "n_kicks",
                "synch_rad",
                "filename",
                "sqrt_order",
                "group"
            ]
        },
        "FRFMODE": {
            "title": "FRFMODE",
            "description": "One or more beam-driven TM monopole modes of an RF cavity, with data from a file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "filename",
                "bin_size",
                "n_bins",
                "rigid_until_pass",
                "use_symm_data",
                "factor",
                "cutoff",
                "output_file",
                "flush_interval",
                "ramp_passes",
                "reset_for_each_step",
                "long_range_only",
                "n_cavities",
                "bunched_beam_mode",
                "group"
            ]
        },
        "FTABLE": {
            "title": "FTABLE",
            "description": "Tracks through a magnetic field which is expressed by a SDDS table.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "input_file",
                "simple_input",
                "l",
                "l1",
                "l2",
                "angle",
                "e1",
                "e2",
                "tilt",
                "dx",
                "dy",
                "dz",
                "factor",
                "threshold",
                "n_kicks",
                "verbose",
                "group"
            ]
        },
        "FTRFMODE": {
            "title": "FTRFMODE",
            "description": "One or more beam-driven TM dipole modes of an RF cavity, with data from a file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "filename",
                "bin_size",
                "n_bins",
                "rigid_until_pass",
                "use_symm_data",
                "dx",
                "dy",
                "xfactor",
                "yfactor",
                "cutoff",
                "output_file",
                "flush_interval",
                "ramp_passes",
                "reset_for_each_step",
                "long_range_only",
                "n_cavities",
                "bunched_beam_mode",
                "group"
            ]
        },
        "GFWIGGLER": {
            "title": "GFWIGGLER",
            "description": "Tracks through a wiggler using generate function method of J.Bahrdt and G. Wuestefeld (BESSY, Berlin, Germany).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "b_max",
                "shim_scale",
                "dx",
                "dy",
                "dz",
                "tilt",
                "periods",
                "step",
                "order",
                "end_pole",
                "shim_on",
                "input_file",
                "shim_input",
                "synch_rad",
                "isr",
                "isr1part",
                "x0",
                "gap0",
                "d_gap",
                "phase_1",
                "phase_2",
                "phase_3",
                "phase_4",
                "verbosity",
                "group"
            ]
        },
        "HISTOGRAM": {
            "title": "HISTOGRAM",
            "description": "Request for histograms of particle coordinates to be output to SDDS file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "filename",
                "interval",
                "start_pass",
                "bins",
                "fixed_bin_size",
                "x_data",
                "y_data",
                "longit_data",
                "bin_size_factor",
                "normalize",
                "disable",
                "sparse",
                "start_pid",
                "end_pid",
                "group"
            ]
        },
        "HKICK": {
            "title": "HKICK",
            "description": "A horizontal steering dipole implemented as a matrix, up to 2nd order.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "kick",
                "tilt",
                "b2",
                "calibration",
                "edge_effects",
                "order",
                "steering",
                "synch_rad",
                "isr",
                "lerad",
                "group"
            ]
        },
        "HMON": {
            "title": "HMON",
            "description": "A horizontal position monitor, accepting a rpn equation for the readout as a function of the actual position (x).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "dx",
                "dy",
                "weight",
                "tilt",
                "calibration",
                "setpoint",
                "order",
                "readout",
                "co_fitpoint",
                "group"
            ]
        },
        "IBSCATTER": {
            "title": "IBSCATTER",
            "description": "A simulation of intra-beam scattering.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "factor",
                "do_x",
                "do_y",
                "do_z",
                "nslice",
                "smooth",
                "force_matched_twiss",
                "isring",
                "interval",
                "filename",
                "bunched_beam_mode",
                "verbose",
                "group"
            ]
        },
        "ILMATRIX": {
            "title": "ILMATRIX",
            "description": "An Individualized Linear Matrix for each particle for fast symplectic tracking with chromatic and amplitude-dependent effects",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "nux",
                "nuy",
                "nux1m",
                "nuy1m",
                "nux2m",
                "nuy2m",
                "nux3m",
                "nuy3m",
                "nux1ax",
                "nuy1ax",
                "nux1ay",
                "nuy1ay",
                "nux2ax",
                "nuy2ax",
                "nux2ay",
                "nuy2ay",
                "nux1ax1ay",
                "nuy1ax1ay",
                "betax",
                "betay",
                "betax1m",
                "betay1m",
                "alphax",
                "alphay",
                "alphax1m",
                "alphay1m",
                "etax",
                "etapx",
                "etay",
                "etapy",
                "etax1",
                "etapx1",
                "etay1",
                "etapy1",
                "alphac",
                "alphac2",
                "alphac3",
                "ds1ax",
                "ds1ay",
                "ds2ax",
                "ds2ay",
                "ds1ax1ay",
                "tilt",
                "cross_resonance",
                "verbosity",
                "group"
            ]
        },
        "IONEFFECTS": {
            "title": "IONEFFECTS",
            "description": "Simulates ionization of residual gas and interaction with the beam.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "disable",
                "macro_ions",
                "generation_interval",
                "x_span",
                "y_span",
                "x_bin_divisor",
                "y_bin_divisor",
                "x_range_multiplier",
                "y_range_multiplier",
                "x_sigma_limit_multiplier",
                "y_sigma_limit_multiplier",
                "startpass",
                "endpass",
                "passinterval",
                "group"
            ]
        },
        "KICKER": {
            "title": "KICKER",
            "description": "A combined horizontal-vertical steering magnet implemented as a matrix, up to 2nd order. For time-dependent kickers, see BUMPER.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "hkick",
                "vkick",
                "tilt",
                "b2",
                "hcalibration",
                "vcalibration",
                "edge_effects",
                "order",
                "steering",
                "synch_rad",
                "isr",
                "lerad",
                "group"
            ]
        },
        "KOCT": {
            "title": "KOCT",
            "description": "A canonical kick octupole.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "k3",
                "tilt",
                "bore",
                "b",
                "dx",
                "dy",
                "dz",
                "fse",
                "n_kicks",
                "synch_rad",
                "systematic_multipoles",
                "random_multipoles",
                "integration_order",
                "sqrt_order",
                "isr",
                "isr1part",
                "expand_hamiltonian",
                "group"
            ]
        },
        "KPOLY": {
            "title": "KPOLY",
            "description": "A thin kick element with polynomial dependence on the coordinates in one plane.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "coefficient",
                "tilt",
                "dx",
                "dy",
                "dz",
                "factor",
                "order",
                "plane",
                "group"
            ]
        },
        "KQUAD": {
            "title": "KQUAD",
            "description": "A canonical kick quadrupole, which differs from the MULT element with ORDER=1 in that it can be used for tune correction.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "k1",
                "tilt",
                "bore",
                "b",
                "dx",
                "dy",
                "dz",
                "fse",
                "hkick",
                "vkick",
                "hcalibration",
                "vcalibration",
                "hsteering",
                "vsteering",
                "n_kicks",
                "synch_rad",
                "systematic_multipoles",
                "edge_multipoles",
                "random_multipoles",
                "steering_multipoles",
                "systematic_multipole_factor",
                "random_multipole_factor",
                "steering_multipole_factor",
                "min_normal_order",
                "min_skew_order",
                "max_normal_order",
                "max_skew_order",
                "integration_order",
                "sqrt_order",
                "isr",
                "isr1part",
                "edge1_effects",
                "edge2_effects",
                "leffective",
                "i0p",
                "i1p",
                "i2p",
                "i3p",
                "lambda2p",
                "i0m",
                "i1m",
                "i2m",
                "i3m",
                "lambda2m",
                "edge1_linear",
                "edge2_linear",
                "edge1_nonlinear_factor",
                "edge2_nonlinear_factor",
                "radial",
                "expand_hamiltonian",
                "tracking_matrix",
                "group"
            ]
        },
        "KQUSE": {
            "title": "KQUSE",
            "description": "A canonical kick element combining quadrupole and sextupole fields.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "k1",
                "k2",
                "tilt",
                "dx",
                "dy",
                "dz",
                "fse1",
                "fse2",
                "n_kicks",
                "synch_rad",
                "integration_order",
                "isr",
                "isr1part",
                "matrix_tracking",
                "expand_hamiltonian",
                "group"
            ]
        },
        "KSBEND": {
            "title": "KSBEND",
            "description": "A kick bending magnet which is NOT canonical, but is better than a 2nd order matrix implementation. Recommend using CSBEND instead.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "k1",
                "k2",
                "k3",
                "k4",
                "e1",
                "e2",
                "tilt",
                "h1",
                "h2",
                "hgap",
                "fint",
                "dx",
                "dy",
                "dz",
                "fse",
                "etilt",
                "n_kicks",
                "nonlinear",
                "synch_rad",
                "edge1_effects",
                "edge2_effects",
                "edge_order",
                "paraxial",
                "transport",
                "method",
                "group"
            ]
        },
        "KSEXT": {
            "title": "KSEXT",
            "description": "A canonical kick sextupole, which differs from the MULT element with ORDER=2 in that it can be used for chromaticity correction.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "k2",
                "k1",
                "j1",
                "tilt",
                "bore",
                "b",
                "dx",
                "dy",
                "dz",
                "fse",
                "hkick",
                "vkick",
                "hcalibration",
                "vcalibration",
                "hsteering",
                "vsteering",
                "n_kicks",
                "synch_rad",
                "systematic_multipoles",
                "edge_multipoles",
                "random_multipoles",
                "steering_multipoles",
                "systematic_multipole_factor",
                "random_multipole_factor",
                "steering_multipole_factor",
                "min_normal_order",
                "min_skew_order",
                "max_normal_order",
                "max_skew_order",
                "integration_order",
                "sqrt_order",
                "isr",
                "isr1part",
                "expand_hamiltonian",
                "group"
            ]
        },
        "LMIRROR": {
            "title": "LMIRROR",
            "description": "A mirror for light optics",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "rx",
                "ry",
                "theta",
                "dx",
                "dy",
                "dz",
                "tilt",
                "yaw",
                "pitch",
                "group"
            ]
        },
        "LRWAKE": {
            "title": "LRWAKE",
            "description": "Long-range (inter-bunch and inter-turn) longitudinal and transverse wake",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "inputfile",
                "tcolumn",
                "wxcolumn",
                "wycolumn",
                "wzcolumn",
                "qxcolumn",
                "qycolumn",
                "factor",
                "xfactor",
                "yfactor",
                "zfactor",
                "qxfactor",
                "qyfactor",
                "turns_to_keep",
                "ramp_passes",
                "group"
            ]
        },
        "LSCDRIFT": {
            "title": "LSCDRIFT",
            "description": "Longitudinal space charge impedance",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "leffective",
                "bins",
                "smoothing",
                "sg_halfwidth",
                "sg_order",
                "interpolate",
                "lsc",
                "auto_leffective",
                "low_frequency_cutoff0",
                "low_frequency_cutoff1",
                "high_frequency_cutoff0",
                "high_frequency_cutoff1",
                "radius_factor",
                "group"
            ]
        },
        "LSRMDLTR": {
            "title": "LSRMDLTR",
            "description": "A non-symplectic numerically integrated planar undulator including optional co-propagating laser beam for laser modulation of the electron beam.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "bu",
                "tgu_gradient",
                "tgu_comp_factor",
                "periods",
                "method",
                "field_expansion",
                "accuracy",
                "n_steps",
                "pole_factor1",
                "pole_factor2",
                "pole_factor3",
                "laser_wavelength",
                "laser_peak_power",
                "laser_w0",
                "laser_phase",
                "laser_x0",
                "laser_y0",
                "laser_z0",
                "laser_tilt",
                "laser_m",
                "laser_n",
                "synch_rad",
                "isr",
                "helical",
                "time_profile",
                "time_offset",
                "group"
            ]
        },
        "LTHINLENS": {
            "title": "LTHINLENS",
            "description": "A thin lens for light optics",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "fx",
                "fy",
                "dx",
                "dy",
                "dz",
                "tilt",
                "yaw",
                "pitch",
                "group"
            ]
        },
        "MAGNIFY": {
            "title": "MAGNIFY",
            "description": "An element that allows multiplication of phase-space coordinates of all particles by constants.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "mx",
                "mxp",
                "my",
                "myp",
                "ms",
                "mdp",
                "group"
            ]
        },
        "MALIGN": {
            "title": "MALIGN",
            "description": "A misalignment of the beam, implemented as a zero-order matrix.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "dxp",
                "dyp",
                "dx",
                "dy",
                "dz",
                "dt",
                "dp",
                "de",
                "on_pass",
                "force_modify_matrix",
                "start_pid",
                "end_pid",
                "floor",
                "group"
            ]
        },
        "MAPSOLENOID": {
            "title": "MAPSOLENOID",
            "description": "A numerically-integrated solenoid specified as a map of (Bz,Br) vs (z, r).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "dx",
                "dy",
                "etilt",
                "eyaw",
                "epitch",
                "n_steps",
                "inputfile",
                "rcolumn",
                "zcolumn",
                "brcolumn",
                "bzcolumn",
                "factor",
                "bxuniform",
                "byuniform",
                "luniform",
                "accuracy",
                "method",
                "group"
            ]
        },
        "MARK": {
            "title": "MARK",
            "description": "A marker, equivalent to a zero-length drift space.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "dx",
                "dy",
                "fitpoint",
                "group"
            ]
        },
        "MATR": {
            "title": "MATR",
            "description": "Explicit matrix input from a text file, in the format written by the print matrix command.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "fraction",
                "filename",
                "order",
                "group"
            ]
        },
        "MATTER": {
            "title": "MATTER",
            "description": "A Coulomb-scattering and energy-absorbing element simulating material in the beam path.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "leffective",
                "xo",
                "energy_decay",
                "energy_straggle",
                "nuclear_bremsstrahlung",
                "electron_recoil",
                "z",
                "a",
                "rho",
                "pressure",
                "temperature",
                "multiplicity",
                "plimit",
                "width",
                "spacing",
                "tilt",
                "center",
                "n_slots",
                "start_pass",
                "end_pass",
                "group"
            ]
        },
        "MAXAMP": {
            "title": "MAXAMP",
            "description": "A collimating element that sets the maximum transmitted particle amplitudes for all following elements, until the next MAXAMP.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "x_max",
                "y_max",
                "elliptical",
                "exponent",
                "yexponent",
                "open_side",
                "group"
            ]
        },
        "MBUMPER": {
            "title": "MBUMPER",
            "description": "A time-dependent multipole kicker magnet. The waveform is in SDDS format, with time in seconds and amplitude normalized to 1.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "strength",
                "tilt",
                "dx",
                "dy",
                "dz",
                "time_offset",
                "order",
                "periodic",
                "phase_reference",
                "fire_on_pass",
                "n_kicks",
                "waveform",
                "group"
            ]
        },
        "MHISTOGRAM": {
            "title": "MHISTOGRAM",
            "description": "Request for multiple dimensions (1, 2, 4 or 6) histogram output of particle coordinates.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "file1d",
                "file2dh",
                "file2dv",
                "file2dl",
                "file4d",
                "file6d",
                "input_bins",
                "interval",
                "start_pass",
                "normalize",
                "disable",
                "lumped",
                "group"
            ]
        },
        "MODRF": {
            "title": "MODRF",
            "description": "A first-order matrix RF cavity with exact phase dependence, plus optional amplitude and phase modulation.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "volt",
                "phase",
                "freq",
                "q",
                "phase_reference",
                "ammag",
                "amphase",
                "amfreq",
                "amdecay",
                "pmmag",
                "pmphase",
                "pmfreq",
                "pmdecay",
                "fiducial",
                "group"
            ]
        },
        "MONI": {
            "title": "MONI",
            "description": "A two-plane position monitor, accepting two rpn equations for the readouts as a function of the actual positions (x and y).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "dx",
                "dy",
                "weight",
                "tilt",
                "xcalibration",
                "ycalibration",
                "xsetpoint",
                "ysetpoint",
                "order",
                "xreadout",
                "yreadout",
                "co_fitpoint",
                "group"
            ]
        },
        "MRFDF": {
            "title": "MRFDF",
            "description": "Zero-length Multipole RF DeFlector from dipole to decapole",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "factor",
                "tilt",
                "a1",
                "a2",
                "a3",
                "a4",
                "a5",
                "b1",
                "b2",
                "b3",
                "b4",
                "b5",
                "frequency1",
                "frequency2",
                "frequency3",
                "frequency4",
                "frequency5",
                "phase1",
                "phase2",
                "phase3",
                "phase4",
                "phase5",
                "phase_reference",
                "group"
            ]
        },
        "MULT": {
            "title": "MULT",
            "description": "A canonical kick multipole.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "knl",
                "tilt",
                "bore",
                "btipl",
                "dx",
                "dy",
                "dz",
                "factor",
                "order",
                "n_kicks",
                "synch_rad",
                "expand_hamiltonian",
                "group"
            ]
        },
        "NIBEND": {
            "title": "NIBEND",
            "description": "A numerically-integrated dipole magnet with various extended-fringe-field models.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "e1",
                "e2",
                "tilt",
                "dx",
                "dy",
                "dz",
                "fint",
                "hgap",
                "fp1",
                "fp2",
                "fp3",
                "fp4",
                "fse",
                "etilt",
                "accuracy",
                "model",
                "method",
                "synch_rad",
                "adjust_boundary",
                "adjust_field",
                "fudge_path_length",
                "fringe_position",
                "group"
            ]
        },
        "NISEPT": {
            "title": "NISEPT",
            "description": "A numerically-integrated dipole magnet with a Cartesian gradient.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "e1",
                "b1",
                "q1ref",
                "flen",
                "accuracy",
                "method",
                "model",
                "group"
            ]
        },
        "OCTU": {
            "title": "OCTU",
            "description": "An octupole implemented as a third-order matrix",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "k3",
                "tilt",
                "dx",
                "dy",
                "dz",
                "fse",
                "order",
                "group"
            ]
        },
        "PEPPOT": {
            "title": "PEPPOT",
            "description": "A pepper-pot plate.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "radii",
                "transmission",
                "tilt",
                "theta_rms",
                "n_holes",
                "group"
            ]
        },
        "PFILTER": {
            "title": "PFILTER",
            "description": "An element for energy and momentum filtration.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "deltalimit",
                "lowerfraction",
                "upperfraction",
                "fixplimits",
                "beamcentered",
                "bins",
                "group"
            ]
        },
        "POLYSERIES": {
            "title": "POLYSERIES",
            "description": "Tracks through a Polynomial series map specified by a file containing coefficients.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "tilt",
                "dx",
                "dy",
                "dz",
                "filename",
                "group"
            ]
        },
        "QUAD": {
            "title": "QUAD",
            "description": "A quadrupole implemented as a matrix, up to 3rd order.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "k1",
                "tilt",
                "dx",
                "dy",
                "dz",
                "fse",
                "hkick",
                "vkick",
                "hcalibration",
                "vcalibration",
                "hsteering",
                "vsteering",
                "order",
                "edge1_effects",
                "edge2_effects",
                "fringe_type",
                "ffringe",
                "leffective",
                "i0p",
                "i1p",
                "i2p",
                "i3p",
                "lambda2p",
                "i0m",
                "i1m",
                "i2m",
                "i3m",
                "lambda2m",
                "radial",
                "group"
            ]
        },
        "QUFRINGE": {
            "title": "QUFRINGE",
            "description": "An element consisting of a linearly increasing or decreasing quadrupole field.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "k1",
                "tilt",
                "dx",
                "dy",
                "dz",
                "fse",
                "direction",
                "order",
                "group"
            ]
        },
        "RAMPP": {
            "title": "RAMPP",
            "description": "A momentum-ramping element that changes the central momentum according to an SDDS-format file of the momentum factor vs time in seconds.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "waveform",
                "group"
            ]
        },
        "RAMPRF": {
            "title": "RAMPRF",
            "description": "A voltage-, phase-, and/or frequency-ramped RF cavity, implemented like RFCA.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "volt",
                "phase",
                "freq",
                "phase_reference",
                "volt_waveform",
                "phase_waveform",
                "freq_waveform",
                "fiducial",
                "group"
            ]
        },
        "RBEN": {
            "title": "RBEN",
            "description": "A rectangular dipole, implemented as a SBEND with edge angles, up to 2nd order.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "k1",
                "e1",
                "e2",
                "tilt",
                "k2",
                "h1",
                "h2",
                "hgap",
                "fint",
                "dx",
                "dy",
                "dz",
                "fse",
                "fse_dipole",
                "fse_quadrupole",
                "etilt",
                "etilt_sign",
                "edge1_effects",
                "edge2_effects",
                "order",
                "edge_order",
                "transport",
                "use_bn",
                "b1",
                "b2",
                "group"
            ]
        },
        "RCOL": {
            "title": "RCOL",
            "description": "A rectangular collimator.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "x_max",
                "y_max",
                "dx",
                "dy",
                "open_side",
                "invert",
                "group"
            ]
        },
        "RECIRC": {
            "title": "RECIRC",
            "description": "An element that defines the point to which particles recirculate in multi-pass tracking",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "i_recirc_element",
                "group"
            ]
        },
        "REFLECT": {
            "title": "REFLECT",
            "description": "Reflects the beam back on itself, which is useful for multiple beamline matching.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "dummy",
                "group"
            ]
        },
        "REMCOR": {
            "title": "REMCOR",
            "description": "An element to remove correlations from the tracked beam to simulate certain types of correction.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "x",
                "xp",
                "y",
                "yp",
                "with",
                "once_only",
                "group"
            ]
        },
        "RFCA": {
            "title": "RFCA",
            "description": "A first-order matrix RF cavity with exact phase dependence.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "volt",
                "phase",
                "freq",
                "q",
                "phase_reference",
                "change_p0",
                "change_t",
                "fiducial",
                "end1_focus",
                "end2_focus",
                "body_focus_model",
                "n_kicks",
                "dx",
                "dy",
                "t_reference",
                "linearize",
                "lock_phase",
                "group"
            ]
        },
        "RFCW": {
            "title": "RFCW",
            "description": "A combination of RFCA, WAKE, TRWAKE, and LSCDRIFT.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "cell_length",
                "volt",
                "phase",
                "freq",
                "q",
                "phase_reference",
                "change_p0",
                "change_t",
                "fiducial",
                "end1_focus",
                "end2_focus",
                "body_focus_model",
                "n_kicks",
                "zwake",
                "trwake",
                "wakefile",
                "zwakefile",
                "trwakefile",
                "tcolumn",
                "wxcolumn",
                "wycolumn",
                "wzcolumn",
                "n_bins",
                "interpolate",
                "smoothing",
                "sg_halfwidth",
                "sg_order",
                "dx",
                "dy",
                "t_reference",
                "linearize",
                "lsc",
                "lsc_bins",
                "lsc_interpolate",
                "lsc_low_frequency_cutoff0",
                "lsc_low_frequency_cutoff1",
                "lsc_high_frequency_cutoff0",
                "lsc_high_frequency_cutoff1",
                "lsc_radius_factor",
                "wakes_at_end",
                "group"
            ]
        },
        "RFDF": {
            "title": "RFDF",
            "description": "A simple traveling or standing wave deflecting RF cavity.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "phase",
                "tilt",
                "frequency",
                "voltage",
                "fse",
                "b2",
                "time_offset",
                "n_kicks",
                "phase_reference",
                "standing_wave",
                "voltage_waveform",
                "voltage_periodic",
                "align_waveforms",
                "voltage_noise",
                "phase_noise",
                "group_voltage_noise",
                "group_phase_noise",
                "voltage_noise_group",
                "phase_noise_group",
                "start_pass",
                "end_pass",
                "drift_matrix",
                "dx",
                "dy",
                "dz",
                "magnetic_deflection",
                "group"
            ]
        },
        "RFMODE": {
            "title": "RFMODE",
            "description": "A simulation of a beam-driven TM monopole mode of an RF cavity.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "ra",
                "rs",
                "q",
                "freq",
                "charge",
                "initial_v",
                "initial_phase",
                "initial_t",
                "beta",
                "bin_size",
                "n_bins",
                "interpolate",
                "preload",
                "preload_charge",
                "preload_factor",
                "preload_harmonic",
                "rigid_until_pass",
                "detuned_until_pass",
                "sample_interval",
                "flush_interval",
                "record",
                "single_pass",
                "pass_interval",
                "freq_waveform",
                "q_waveform",
                "ramp_passes",
                "binless",
                "reset_for_each_step",
                "long_range_only",
                "allow_unbinned_particles",
                "n_cavities",
                "bunched_beam_mode",
                "bunch_interval",
                "drive_frequency",
                "v_setpoint",
                "phase_setpoint",
                "update_interval",
                "read_offset",
                "adjustment_start",
                "adjustment_end",
                "adjustment_interval",
                "adjustment_fraction",
                "amplitude_filter",
                "phase_filter",
                "in_phase_filter",
                "quadrature_filter",
                "feedback_record",
                "mute_generator",
                "noise_alpha_gen",
                "noise_phi_gen",
                "noise_alpha_v",
                "noise_phi_v",
                "noise_i_gen",
                "noise_q_gen",
                "noise_i_v",
                "noise_q_v",
                "group"
            ]
        },
        "RFTM110": {
            "title": "RFTM110",
            "description": "Tracks through a TM110-mode (deflecting) rf cavity with all magneticand electric field components. NOT RECOMMENDED—See below.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "phase",
                "tilt",
                "frequency",
                "voltage",
                "phase_reference",
                "voltage_waveform",
                "voltage_periodic",
                "align_waveforms",
                "voltage_noise",
                "phase_noise",
                "group_voltage_noise",
                "group_phase_noise",
                "voltage_noise_group",
                "phase_noise_group",
                "start_pass",
                "end_pass",
                "group"
            ]
        },
        "RFTMEZ0": {
            "title": "RFTMEZ0",
            "description": "A TM-mode RF cavity specified by the on-axis Ez field.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "frequency",
                "phase",
                "ez_peak",
                "time_offset",
                "phase_reference",
                "dx",
                "dy",
                "dz",
                "etilt",
                "eyaw",
                "epitch",
                "n_steps",
                "radial_order",
                "change_p0",
                "inputfile",
                "zcolumn",
                "ezcolumn",
                "solenoid_file",
                "solenoid_zcolumn",
                "solenoid_rcolumn",
                "solenoid_bzcolumn",
                "solenoid_brcolumn",
                "solenoid_factor",
                "solenoid_dx",
                "solenoid_dy",
                "solenoid_dz",
                "solenoid_etilt",
                "solenoid_eyaw",
                "solenoid_epitch",
                "bx_stray",
                "by_stray",
                "accuracy",
                "method",
                "fiducial",
                "field_test_file",
                "group"
            ]
        },
        "RIMULT": {
            "title": "RIMULT",
            "description": "Multiplies radiation integrals by a given factor. Use to compute emittance for collection of various types of cells.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "factor",
                "group"
            ]
        },
        "RMDF": {
            "title": "RMDF",
            "description": "A linearly-ramped electric field deflector, using an approximate analytical solution FOR LOW ENERGY PARTICLES.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "tilt",
                "ramp_time",
                "voltage",
                "gap",
                "time_offset",
                "n_sections",
                "phase_reference",
                "dx",
                "dy",
                "group"
            ]
        },
        "ROTATE": {
            "title": "ROTATE",
            "description": "An element that rotates the beam about the longitudinal axis.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "tilt",
                "exclude_floor",
                "exclude_optics",
                "group"
            ]
        },
        "SAMPLE": {
            "title": "SAMPLE",
            "description": "An element that reduces the number of particles in the beam by intervaal-based or random sampling.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "fraction",
                "interval",
                "group"
            ]
        },
        "SBEN": {
            "title": "SBEN",
            "description": "A sector dipole implemented as a matrix, up to 2nd order.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "k1",
                "e1",
                "e2",
                "tilt",
                "k2",
                "h1",
                "h2",
                "hgap",
                "fint",
                "dx",
                "dy",
                "dz",
                "fse",
                "fse_dipole",
                "fse_quadrupole",
                "etilt",
                "etilt_sign",
                "edge1_effects",
                "edge2_effects",
                "order",
                "edge_order",
                "transport",
                "use_bn",
                "b1",
                "b2",
                "group"
            ]
        },
        "SCATTER": {
            "title": "SCATTER",
            "description": "A scattering element to add gaussian random numbers to particle coordinates.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "x",
                "xp",
                "y",
                "yp",
                "dp",
                "probability",
                "startonpass",
                "endonpass",
                "group"
            ]
        },
        "SCMULT": {
            "title": "SCMULT",
            "description": "Tracks through a zero length multipole to simulate space charge effects",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "group"
            ]
        },
        "SCRAPER": {
            "title": "SCRAPER",
            "description": "A collimating element that sticks into the beam from one side only. The directions 0, 1, 2, and 3 are from +x, +y, -x, and -y, respectively.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "xo",
                "energy_decay",
                "energy_straggle",
                "nuclear_bremsstrahlung",
                "electron_recoil",
                "z",
                "a",
                "rho",
                "plimit",
                "position",
                "dx",
                "dy",
                "insert_from",
                "direction",
                "group"
            ]
        },
        "SCRIPT": {
            "title": "SCRIPT",
            "description": "An element that allows transforming the beam using an external script.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "command",
                "commandFile",
                "commandInputFile",
                "use_csh",
                "verbosity",
                "start_pass",
                "end_pass",
                "pass_interval",
                "on_pass",
                "directory",
                "rootname",
                "input_extension",
                "output_extension",
                "keep_files",
                "drift_matrix",
                "use_particle_id",
                "no_new_particles",
                "determine_losses_from_pid",
                "np0",
                "np1",
                "np2",
                "np3",
                "np4",
                "np5",
                "np6",
                "np7",
                "np8",
                "np9",
                "sp0",
                "sp1",
                "sp2",
                "sp3",
                "sp4",
                "sp5",
                "sp6",
                "sp7",
                "sp8",
                "sp9",
                "group"
            ]
        },
        "SEXT": {
            "title": "SEXT",
            "description": "A sextupole implemented as a matrix, up to 3rd order",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "k2",
                "k1",
                "j1",
                "tilt",
                "dx",
                "dy",
                "dz",
                "fse",
                "ffringe",
                "order",
                "group"
            ]
        },
        "SHRFDF": {
            "title": "SHRFDF",
            "description": "Simulation through space harmonics of zero length deflecting cavity.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "factor",
                "tilt",
                "period_length",
                "period_phase",
                "v0",
                "v1",
                "v2",
                "v3",
                "v4",
                "v5",
                "v6",
                "v7",
                "v8",
                "v9",
                "phase0",
                "phase1",
                "phase2",
                "phase3",
                "phase4",
                "phase5",
                "phase6",
                "phase7",
                "phase8",
                "phase9",
                "phase_reference",
                "group"
            ]
        },
        "SLICE": {
            "title": "SLICE",
            "description": "Performs slice-by-slice analysis of the beam for output to a file.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "n_slices",
                "start_pid",
                "end_pid",
                "interval",
                "start_pass",
                "end_pass",
                "filename",
                "label",
                "index_offset",
                "reference_frequency",
                "disable",
                "use_disconnect",
                "group"
            ]
        },
        "SOLE": {
            "title": "SOLE",
            "description": "A solenoid implemented as a matrix, up to 2nd order.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "ks",
                "b",
                "dx",
                "dy",
                "dz",
                "order",
                "group"
            ]
        },
        "SPEEDBUMP": {
            "title": "SPEEDBUMP",
            "description": "Simulates a semi-circular protuberance from one or both walls of the chamber.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "chord",
                "dzcenter",
                "height",
                "position",
                "dx",
                "dy",
                "insert_from",
                "group"
            ]
        },
        "SREFFECTS": {
            "title": "SREFFECTS",
            "description": "Lumped simulation of synchrotron radiation effects (damping andquantum excitation) for rings.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "jx",
                "jy",
                "jdelta",
                "exref",
                "eyref",
                "sdeltaref",
                "ddeltaref",
                "pref",
                "coupling",
                "fraction",
                "damping",
                "qexcitation",
                "losses",
                "cutoff",
                "include_offsets",
                "group"
            ]
        },
        "STRAY": {
            "title": "STRAY",
            "description": "A stray field element with local and global components. Global components are defined relative to the initial beamline direction.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "lbx",
                "lby",
                "gbx",
                "gby",
                "gbz",
                "order",
                "group"
            ]
        },
        "TAPERAPC": {
            "title": "TAPERAPC",
            "description": "A tapered aperture that is a section of a circular cylinder.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "rstart",
                "rend",
                "dx",
                "dy",
                "sticky",
                "group"
            ]
        },
        "TAPERAPE": {
            "title": "TAPERAPE",
            "description": "A tapered elliptical aperture.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "astart",
                "aend",
                "bstart",
                "bend",
                "dx",
                "dy",
                "tilt",
                "resolution",
                "xexponent",
                "yexponent",
                "sticky",
                "group"
            ]
        },
        "TAPERAPR": {
            "title": "TAPERAPE",
            "description": "A tapered rectangular aperture.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "xstart",
                "xend",
                "ystart",
                "yend",
                "dx",
                "dy",
                "tilt",
                "sticky",
                "group"
            ]
        },
        "TFBDRIVER": {
            "title": "TFBDRIVER",
            "description": "Driver for a turn-by-turn feedback loop",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "id",
                "strength",
                "kick_limit",
                "frequency",
                "drive_frequency",
                "clock_frequency",
                "clock_offset",
                "phase",
                "raoverq",
                "qloaded",
                "output_file",
                "gain_factor_file",
                "gain_factor_column",
                "delay",
                "a0",
                "a1",
                "a2",
                "a3",
                "a4",
                "a5",
                "a6",
                "a7",
                "a8",
                "a9",
                "a10",
                "a11",
                "a12",
                "a13",
                "a14",
                "a15",
                "a16",
                "a17",
                "a18",
                "a19",
                "a20",
                "a21",
                "a22",
                "a23",
                "a24",
                "a25",
                "a26",
                "a27",
                "a28",
                "a29",
                "update_interval",
                "output_interval",
                "start_pass",
                "end_pass",
                "longitudinal",
                "bunched_beam_mode",
                "group"
            ]
        },
        "TFBPICKUP": {
            "title": "TFBPICKUP",
            "description": "Pickup for a turn-by-turn feedback loop",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "id",
                "plane",
                "rms_noise",
                "a0",
                "a1",
                "a2",
                "a3",
                "a4",
                "a5",
                "a6",
                "a7",
                "a8",
                "a9",
                "a10",
                "a11",
                "a12",
                "a13",
                "a14",
                "a15",
                "a16",
                "a17",
                "a18",
                "a19",
                "a20",
                "a21",
                "a22",
                "a23",
                "a24",
                "a25",
                "a26",
                "a27",
                "a28",
                "a29",
                "bunched_beam_mode",
                "update_interval",
                "start_pass",
                "end_pass",
                "reference_frequency",
                "dx",
                "dy",
                "group"
            ]
        },
        "TMCF": {
            "title": "TMCF",
            "description": "A numerically-integrated accelerating TM RF cavity with spatially-constant fields.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "frequency",
                "phase",
                "time_offset",
                "radial_offset",
                "tilt",
                "er",
                "bphi",
                "ez",
                "accuracy",
                "x_max",
                "y_max",
                "dx",
                "dy",
                "phase_reference",
                "n_steps",
                "method",
                "fiducial",
                "group"
            ]
        },
        "TRCOUNT": {
            "title": "TRCOUNT",
            "description": "An element that defines the point from which transmission calculations are made.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "dummy",
                "group"
            ]
        },
        "TRFMODE": {
            "title": "TRFMODE",
            "description": "A simulation of a beam-driven TM dipole mode of an RF cavity.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "ra",
                "rs",
                "q",
                "freq",
                "charge",
                "beta",
                "bin_size",
                "n_bins",
                "interpolate",
                "plane",
                "sample_interval",
                "per_particle_output",
                "record",
                "single_pass",
                "rigid_until_pass",
                "dx",
                "dy",
                "xfactor",
                "yfactor",
                "ramp_passes",
                "binless",
                "reset_for_each_step",
                "long_range_only",
                "n_cavities",
                "bunched_beam_mode",
                "group"
            ]
        },
        "TRWAKE": {
            "title": "TRWAKE",
            "description": "Transverse wake specified as a function of time lag behind the particle.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "inputfile",
                "tcolumn",
                "wxcolumn",
                "wycolumn",
                "charge",
                "factor",
                "xfactor",
                "yfactor",
                "n_bins",
                "interpolate",
                "smoothing",
                "sg_halfwidth",
                "sg_order",
                "dx",
                "dy",
                "tilt",
                "x_drive_exponent",
                "y_drive_exponent",
                "x_probe_exponent",
                "y_probe_exponent",
                "ramp_passes",
                "bunched_beam_mode",
                "acausal_allowed",
                "group"
            ]
        },
        "TSCATTER": {
            "title": "TSCATTER",
            "description": "An element to simulate Touschek scattering.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "dummy",
                "group"
            ]
        },
        "TUBEND": {
            "title": "TUBEND",
            "description": "A special rectangular bend element for top-up backtracking.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "angle",
                "fse",
                "offset",
                "magnet_width",
                "magnet_angle",
                "group"
            ]
        },
        "TWISS": {
            "title": "TWISS",
            "description": "Sets Twiss parameter values.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "betax",
                "alphax",
                "etax",
                "etaxp",
                "betay",
                "alphay",
                "etay",
                "etayp",
                "from_beam",
                "from_0values",
                "compute_once",
                "apply_once",
                "verbose",
                "disable",
                "betax0",
                "alphax0",
                "etax0",
                "etaxp0",
                "betay0",
                "alphay0",
                "etay0",
                "etayp0",
                "group"
            ]
        },
        "TWLA": {
            "title": "TWLA",
            "description": "A numerically-integrated first-space-harmonic traveling-wave linear accelerator.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "frequency",
                "phase",
                "time_offset",
                "ez",
                "b_solenoid",
                "accuracy",
                "x_max",
                "y_max",
                "dx",
                "dy",
                "beta_wave",
                "alpha",
                "phase_reference",
                "n_steps",
                "focussing",
                "method",
                "fiducial",
                "change_p0",
                "sum_bn2",
                "group"
            ]
        },
        "TWMTA": {
            "title": "TWMTA",
            "description": "A numerically-integrated traveling-wave muffin-tin accelerator.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "frequency",
                "phase",
                "ez",
                "accuracy",
                "x_max",
                "y_max",
                "dx",
                "dy",
                "kx",
                "beta_wave",
                "bsol",
                "alpha",
                "phase_reference",
                "n_steps",
                "method",
                "fiducial",
                "group"
            ]
        },
        "TWPL": {
            "title": "TWPL",
            "description": "A numerically-integrated traveling-wave stripline deflector.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "ramp_time",
                "time_offset",
                "voltage",
                "gap",
                "static_voltage",
                "tilt",
                "accuracy",
                "x_max",
                "y_max",
                "dx",
                "dy",
                "phase_reference",
                "n_steps",
                "method",
                "fiducial",
                "group"
            ]
        },
        "UKICKMAP": {
            "title": "UKICKMAP",
            "description": "An undulator kick map (e.g., using data from RADIA).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "tilt",
                "dx",
                "dy",
                "dz",
                "field_factor",
                "xy_factor",
                "yaw",
                "input_file",
                "n_kicks",
                "periods",
                "kref",
                "kactual",
                "synch_rad",
                "isr",
                "yaw_end",
                "single_period_map",
                "group"
            ]
        },
        "VKICK": {
            "title": "VKICK",
            "description": "A vertical steering dipole implemented as a matrix, up to 2nd order.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "kick",
                "tilt",
                "b2",
                "calibration",
                "edge_effects",
                "order",
                "steering",
                "synch_rad",
                "isr",
                "lerad",
                "group"
            ]
        },
        "VMON": {
            "title": "VMON",
            "description": "A vertical position monitor, accepting a rpn equation for the readout as a function of the actual position (y).",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "dx",
                "dy",
                "weight",
                "tilt",
                "calibration",
                "setpoint",
                "order",
                "readout",
                "co_fitpoint",
                "group"
            ]
        },
        "WAKE": {
            "title": "WAKE",
            "description": "Longitudinal wake specified as a function of time lag behind the particle.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "inputfile",
                "tcolumn",
                "wcolumn",
                "charge",
                "factor",
                "n_bins",
                "interpolate",
                "smoothing",
                "sg_halfwidth",
                "sg_order",
                "change_p0",
                "allow_long_beam",
                "ramp_passes",
                "bunched_beam_mode",
                "acausal_allowed",
                "group"
            ]
        },
        "WATCH": {
            "title": "WATCH",
            "description": "A beam property/motion monitor-allowed modes are centroid, parameter, coordinate, and fft.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "fraction",
                "start_pid",
                "end_pid",
                "interval",
                "start_pass",
                "end_pass",
                "filename",
                "label",
                "mode",
                "x_data",
                "y_data",
                "longit_data",
                "exclude_slopes",
                "flush_interval",
                "sparse_interval",
                "disable",
                "use_disconnect",
                "index_offset",
                "reference_frequency",
                "group"
            ]
        },
        "WIGGLER": {
            "title": "WIGGLER",
            "description": "A wiggler or undulator for damping or excitation of the beam.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "l",
                "radius",
                "k",
                "b",
                "dx",
                "dy",
                "dz",
                "tilt",
                "poles",
                "focusing",
                "group"
            ]
        },
        "ZLONGIT": {
            "title": "ZLONGIT",
            "description": "A simulation of a single-pass broad-band or functionally specified longitudinal impedance.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "charge",
                "broad_band",
                "ra",
                "rs",
                "q",
                "freq",
                "zreal",
                "zimag",
                "bin_size",
                "n_bins",
                "max_n_bins",
                "wakes",
                "wake_interval",
                "wake_start",
                "wake_end",
                "area_weight",
                "interpolate",
                "smoothing",
                "sg_order",
                "sg_halfwidth",
                "reverse_time_order",
                "factor",
                "start_on_pass",
                "ramp_passes",
                "high_frequency_cutoff0",
                "high_frequency_cutoff1",
                "bunched_beam_mode",
                "allow_long_beam",
                "group"
            ]
        },
        "ZTRANSVERSE": {
            "title": "ZTRANSVERSE",
            "description": "A simulation of a single-pass broad-band or functionally-specified transverse impedance.",
            "fieldsPerTab": 8,
            "advanced": [
                "name",
                "charge",
                "broad_band",
                "rs",
                "q",
                "freq",
                "inputfile",
                "freqcolumn",
                "zxreal",
                "zximag",
                "zyreal",
                "zyimag",
                "bin_size",
                "interpolate",
                "n_bins",
                "max_n_bins",
                "smoothing",
                "sg_order",
                "sg_halfwidth",
                "dx",
                "dy",
                "factor",
                "xfactor",
                "yfactor",
                "wakes",
                "wake_interval",
                "wake_start",
                "wake_end",
                "start_on_pass",
                "ramp_passes",
                "high_frequency_cutoff0",
                "high_frequency_cutoff1",
                "x_drive_exponent",
                "y_drive_exponent",
                "x_probe_exponent",
                "y_probe_exponent",
                "bunched_beam_mode",
                "allow_long_beam",
                "group"
            ]
        }
    }
}
