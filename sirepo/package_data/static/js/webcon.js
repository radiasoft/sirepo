'use strict';

var srlog = SIREPO.srlog;
var srdbg = SIREPO.srdbg;

SIREPO.app.config(function() {
    SIREPO.appFieldEditors += [
        '<div data-ng-switch-when="MiniFloat" class="col-sm-7">',
          '<input data-string-to-number="" data-ng-model="model[field]" data-min="info[4]" data-max="info[5]" class="form-control" style="text-align: right" data-lpignore="true" required />',
        '</div>',
        '<div data-ng-switch-when="AnalysisParameter" class="col-sm-5">',
          '<div data-analysis-parameter="" data-model="model" data-field="field"></div>',
        '</div>',
        '<div data-ng-switch-when="AnalysisOptionalParameter" class="col-sm-5">',
          '<div data-analysis-parameter="" data-model="model" data-field="field" data-is-optional="true"></div>',
        '</div>',
        '<div data-ng-switch-when="Equation" class="col-sm-7">',
          '<div data-equation="equation" data-model="model" data-field="field" data-form="form"></div>',
          '<div class="sr-input-warning" data-ng-show="showWarning">{{warningText}}</div>',
        '</div>',
        '<div data-ng-switch-when="EquationVariables" class="col-sm-7">',
          '<div data-equation-variables="" data-model="model" data-field="field" data-form="form" data-is-variable="true"></div>',
        '</div>',
        '<div data-ng-switch-when="EquationParameters" class="col-sm-7">',
          '<div data-equation-variables="" data-model="model" data-field="field" data-form="form" data-is-variable="false"></div>',
        '</div>',
        '<div data-ng-switch-when="ClusterFields" class="col-sm-7">',
          '<div data-cluster-fields="" data-model="model" data-field="field"></div>',
        '</div>',
        '<div data-ng-switch-when="PlotActionButtons" class="col-sm-12">',
          '<div data-plot-action-buttons="" data-model="model" data-field="field"></div>',
        '</div>',
        '<div data-ng-switch-when="TrimButton" class="col-sm-5">',
          '<div data-trim-button="" data-model-name="modelName" data-model="model" data-field="field"></div>',
        '</div>',
    ].join('');
    SIREPO.appReportTypes = [
        '<div data-ng-switch-when="bpmMonitor" data-bpm-monitor-plot="" class="sr-plot" data-model-name="{{ modelKey }}"></div>',
    ].join('');
    SIREPO.lattice = {
        elementColor: {},
        elementPic: {
            drift: ['DRIF'],
            magnet: ['KICKER', 'QUAD'],
            watch: ['WATCH'],
        },
    };
});

SIREPO.app.factory('webconService', function(appState, panelState) {
    var self = {};
    var parameterCache = {
        analysisParameter: null,
        parameterValues: null,
        optionalParameterValues: null,
    };

    self.addSubreport = function(parent, action) {
        var report = appState.clone(parent);
        var subreports = self.getSubreports();
        report.id = subreports.length
            ? (Math.max.apply(null, subreports) + 1)
            : 1;
        report.action = null;
        report.history.push(action);
        var name = 'analysisReport' + report.id;
        var fftName = 'fftReport' + report.id;
        appState.models[name] = report;
        appState.models[fftName] = {
            'analysisReport': name,
        };
        subreports.push(report.id);
        appState.saveChanges([name, fftName, 'hiddenReport']);
    };

    self.buildParameterList = function(includeOptional) {
        if (! appState.isLoaded()) {
            return null;
        }
        var name = includeOptional ? 'optionalParameterValues' : 'parameterValues';
        // use cached list unless the columnInfo changes
        if (parameterCache.analysisParameters == appState.models.analysisData.columnInfo) {
            if (parameterCache[name]) {
                return parameterCache[name];
            }
        }
        parameterCache.analysisParameters = appState.models.analysisData.columnInfo;
        if (! parameterCache.analysisParameters) {
            return null;
        }
        var parameterValues = [];
        var visited = {};
        parameterCache.analysisParameters.names.forEach(function(name, idx) {
            // skip duplicate columns
            if (! visited[name]) {
                parameterValues.push(['' + idx, name]);
                visited[name] = true;
            }
        });
        parameterValues.sort(function(a, b) {
            return a[1].localeCompare(b[1]);
        });
        if (includeOptional) {
            parameterValues.unshift(['none', 'None']);
        }
        parameterCache[name] = parameterValues;
        return parameterValues;
    };

    self.computeModel = function(analysisModel) {
        return 'epicsServerAnimation';
    };

    self.getSubreports = function() {
        // subreports are kept on a report which is never shown.
        // This avoids refreshing all reports when a subreport is added or removed.
        return appState.models.hiddenReport.subreports;
    };

    self.removeAllSubreports = function() {
        var subreports = self.getSubreports();
        while (subreports.length) {
            self.removeSubreport(subreports[0]);
        }
    };

    self.removeSubreport = function(id) {
        var subreports = self.getSubreports();
        subreports.splice(subreports.indexOf(id), 1);
        appState.removeModel('analysisReport' + id);
        appState.removeModel('fftReport' + id);
        panelState.clear('analysisReport' + id);
    };

    self.tokenizeEquation = function(eq) {
        return (eq || '').split(/[-+*/^|%().0-9\s]/)
            .filter(function (t) {
                return t.length > 0 &&
                    SIREPO.APP_SCHEMA.constants.allowedEquationOps.indexOf(t) < 0;
        });
    };

    self.tokenizeParams = function(val) {
        return (val || '').split(/\s*,\s*/).filter(function (t) {
            return t.length > 0;
        });
    };

    appState.setAppService(self);

    return self;
});

SIREPO.app.controller('AnalysisController', function (appState, panelState, requestSender, webconService, $scope) {
    var self = this;
    var currentFile = null;
    self.subplots = null;

    function buildSubplots() {
        if (! currentFile) {
            self.subplots = null;
            return;
        }
        self.subplots = [];
        webconService.getSubreports().forEach(function(id, idx) {
            var modelKey = 'analysisReport' + id;
            self.subplots.push({
                id: id,
                modelKey: modelKey,
                title: 'Analysis Subplot #' + (idx + 1),
                getData: function() {
                    return appState.models[modelKey];
                },
            });
        });
    }

    function updateAnalysisParameters() {
        requestSender.sendStatefulCompute(
            appState,
            function(data) {
                if (appState.isLoaded() && data.columnInfo) {
                    appState.models.analysisData.columnInfo = data.columnInfo;
                    appState.saveChanges('analysisData');
                }
            },
            {
                method: 'column_info',
                analysisData: appState.models.analysisData,
            }
        );
    }

    self.hasFile = function() {
        return appState.isLoaded() && appState.applicationState().analysisData.file;
    };

    appState.whenModelsLoaded($scope, function() {
        currentFile = appState.models.analysisData.file;
        if (currentFile && ! appState.models.analysisData.columnInfo) {
            updateAnalysisParameters();
        }
        $scope.$on('analysisData.changed', function() {
            var analysisData = appState.models.analysisData;
            if (currentFile != analysisData.file) {
                currentFile = analysisData.file;
                if (currentFile) {
                    updateAnalysisParameters();
                    webconService.removeAllSubreports();
                    appState.models.analysisReport.action = null;
                    appState.saveChanges(['analysisReport', 'hiddenReport']);
                }
            }
        });
        $scope.$on('modelChanged', function(e, name) {
            if (name.indexOf('analysisReport') >= 0) {
                // invalidate the corresponding fftReport
                appState.saveChanges('fftReport' + (appState.models[name].id || ''));
            }
        });
        $scope.$on('hiddenReport.changed', buildSubplots);
        buildSubplots();
    });
});

SIREPO.app.controller('ControlsController', function (appState, frameCache, panelState, persistentSimulation, requestSender, webconService, $scope) {
    var self = this;
    self.simScope = $scope;
    var wantFinalKickerUpdate = false;
    self.isEpicsConnectionSuccessful = false;

    function buildMonitorToModelFields() {
        self.monitorToModelFields = {
            WATCH: [],
            KICKER: []
        };
        appState.models.elements.forEach(function(el) {
            var t = el.type;
            if (! self.monitorToModelFields[t]) {
                return;
            }
            var count = self.monitorToModelFields[t].length + 1;
            var map = {};
            if (t === 'WATCH') {
                ['hpos', 'vpos'].forEach(function(pos) {
                    map[pos] = 'bpm' + count + '_' + pos;
                });
            }
            else if (t === 'KICKER') {
                ['hkick', 'vkick'].forEach(function(pos) {
                    map[pos] ='corrector' + count
                        + (pos == 'hkick' ? '_HCurrent' : '_VCurrent');
                });
            }
            self.monitorToModelFields[t].push(map);
        });
    }

    function elementForId(id) {
        var model = null;
        appState.models.elements.some(function(m) {
            if (m._id == id) {
                model = m;
                return true;
            }
        });
        if (! model) {
            throw new Error('model not found for id: ' + id);
        }
        return model;
    }

    function enableLatticeFields(isEnabled) {
        // all quad fields enabled at once...
        panelState.enableField('QUAD', 'k1', isEnabled);
        Object.keys(appState.models.bunch).forEach(function(f) {
            panelState.enableField('bunch', f, isEnabled);
        });
    }

    self.simHandleStatus = function (data) {
        if (data.summaryData) {
            self.isEpicsConnectionSuccessful = true;
            updateFromMonitorValues(data.summaryData.monitorValues);
            if (data.summaryData.optimizationValues) {
                stopSteering(data.summaryData.optimizationValues);
            }
        }
        if (data.state == 'completed' || data.state == 'error' || data.state == 'canceled') {
            appState.models.epicsServerAnimation.connectToServer = '0';
            appState.saveChanges('epicsServerAnimation');
        }
        else if (data.state != 'running' && data.state != 'pending') {
            //console.log('handle state:', data.state);
        }
    };

    function kickerModelNames() {
        var res = [];
        appState.models.elements.forEach(function(el) {
            if (el.type == 'KICKER') {
                res.push(el.type + el._id);
            }
        });
        return res;
    }

    function modelForElement(element) {
        var modelKey = element.type + element._id;
        if (! appState.models[modelKey]) {
            appState.models[modelKey] = element;
            appState.saveQuietly(modelKey);
        }
        return {
            id: element._id,
            modelKey: element.type === 'WATCH' ? self.watchpointReportName(element._id) : modelKey,
            title: element.name.replace(/\_/g, ' '),
            viewName: element.type,
            element: element,
            getData: function() {
                return appState.models[modelKey];
            },
        };
    }

    function processEPICSServer() {
        // updates the UI state of the epicsServer view
        if (self.isConnectedToEPICS()) {
            panelState.showField('epicsServerAnimation', 'serverType', false);
            panelState.showField('epicsServerAnimation', 'serverAddress', false);
            enableLatticeFields(false);
        }
        else {
            panelState.showField('epicsServerAnimation', 'serverType', true);
            panelState.showField(
                'epicsServerAnimation', 'serverAddress',
                appState.models.epicsServerAnimation.serverType == 'remote');
            enableLatticeFields(true);
        }
    }

    function processKickers() {
        panelState.enableField('KICKER', 'hkick', ! isSteeringBeam());
        panelState.enableField('KICKER', 'vkick', ! isSteeringBeam());
        panelState.showField('beamSteering', 'steeringMethod', ! isSteeringBeam());
    }

    function updateBeamSteering() {
        var steering = appState.applicationState().beamSteering;
        if (steering.useSteering == '1') {
            $scope.$broadcast('sr-clearPointData');
        }
        requestSender.getApplicationData(
            {
                method: 'enable_steering',
                simulationId: appState.models.simulation.simulationId,
                beamSteering: steering,
            },
            function(data) {});
        if (! isSteeringBeam()) {
            stopSteering(null);
        }
        processKickers();
    }

    function isSteeringBeam() {
        return self.isConnectedToEPICS()
            && appState.applicationState().beamSteering.useSteering == '1';
    }

    function stopSteering(results) {
        if (appState.applicationState().beamSteering.useSteering == '1') {
            appState.models.beamSteering.useSteering = '0';
            appState.saveChanges('beamSteering');
        }
        // steering may have been stopped before the UI has updated the kicker settings
        wantFinalKickerUpdate = true;
        $scope.$broadcast('wc-optimizationValues', results);
    }

    function updateFromMonitorValues(monitorValues) {
        var countByType = {
            WATCH: 0,
            KICKER: 0,
        };
        var isSteering = isSteeringBeam() || wantFinalKickerUpdate;
        wantFinalKickerUpdate = false;
        appState.models.elements.forEach(function(el) {
            if (! self.monitorToModelFields[el.type]) {
                return;
            }
            if (el.type == 'KICKER' && ! isSteering) {
                return;
            }
            var count = countByType[el.type]++;
            var map = self.monitorToModelFields[el.type][count];
            var hasChanged = false;
            for (var f in map) {
                var v = monitorValues[map[f]];
                if (el[f] != v) {
                    el[f] = v;
                    hasChanged = true;
                }
            }
            if (hasChanged) {
                appState.models[el.type + el._id] = el;
                appState.saveQuietly(el.type + el._id);
                if (el.type == 'WATCH') {
                    // let the parameter plot know a new point is available
                    $scope.$broadcast('sr-pointData-' + self.watchpointReportName(el._id), [el.hpos, el.vpos]);
                }
            }
        });
    }

    function updateEPICSServer() {
        // update the simulation status for epics
        if (self.isConnectedToEPICS()) {
            if (! self.simState.isProcessing()) {
                //console.log('starting epics');
                $scope.$broadcast('sr-clearPointData');
                if (self.isRemoteServer()) {
                    updateKickersFromEPICSAndRunSimulation();
                }
                else {
                    self.simState.runSimulation();
                }
            }
        }
        else {
            if (self.simState.isProcessing()) {
                //console.log('stopping epics');
                self.simState.cancelSimulation();
            }
            if (appState.applicationState().beamSteering.useSteering == '1') {
                stopSteering(null);
                processKickers();
            }
        }
    }

    function updateKickersFromEPICSAndRunSimulation() {
        requestSender.getApplicationData(
            {
                method: 'read_kickers',
                epicsServerAnimation: appState.applicationState().epicsServerAnimation,
            },
            function(data) {
                if (data.kickers) {
                    var modelNames = kickerModelNames();
                    modelNames.forEach(function(name) {
                        appState.models[name].hkick = data.kickers.shift();
                        appState.models[name].vkick = data.kickers.shift();
                    });
                    appState.saveChanges(modelNames, self.simState.runSimulation);
                }
            });
    }

    function updateKicker(name) {
        if (isSteeringBeam()) {
            // don't respond to kicker changes if server is controlling the steering
            return;
        }
        var epicsField = kickerModelNames().indexOf(name) + 1;
        if (! epicsField) {
            throw new Error('invalid kicker name: ' + name);
        }
        requestSender.getApplicationData(
            {
                method: 'update_kicker',
                epics_field: epicsField,
                kicker: appState.models[name],
                epicsServerAnimation: appState.applicationState().epicsServerAnimation,
                simulationId: appState.models.simulation.simulationId,
            },
            function(data) {
                //TODO(pjm): look for error from epics
            });
    }

    self.isConnectedToEPICS = function() {
        if (appState.isLoaded()) {
            if (appState.applicationState().epicsServerAnimation.connectToServer == '1') {
                return true;
            }
        }
        self.isEpicsConnectionSuccessful = false;
        return false;
    };

    self.isRemoteServer = function() {
        if (appState.isLoaded()) {
            return appState.applicationState().epicsServerAnimation.serverType == 'remote';
        }
        return false;
    };

    self.reset = function () {
        var toSave = [];
        self.monitoredModels.forEach(function(m) {
            var am = appState.models[m.modelKey];
            var info = appState.modelInfo(am.type);
            for (var field in info) {
                am[field] = info[field][SIREPO.INFO_INDEX_DEFAULT_VALUE];
            }
            toSave.push(m.modelKey);
        });
        appState.saveChanges(toSave);
    };

    self.showEditor = function(item) {
        if (self.isRemoteServer()) {
            return item.element.type != 'QUAD';
        }
        return true;
    };

    self.watchpointReportName = function (id) {
        return 'watchpointReport' + id;
    };

    appState.whenModelsLoaded($scope, function() {
        self.watches = [];
        self.editorColumns = [];
        self.monitoredModels = [];
        var quadCount = 0;
        appState.models.beamlines[0].items.forEach(function(id) {
            var element = elementForId(id);
            var m = modelForElement(element);
            if (element.type == 'WATCH') {
                self.watches.push(m);
                // this to remove panel editor
                SIREPO.APP_SCHEMA.view[m.modelKey] = {advanced: []};
            }
            else if (element.type == 'KICKER') {
                self.editorColumns.push([m]);
                self.monitoredModels.push(m);
            }
            else if (element.type == 'QUAD') {
                self.editorColumns[quadCount].push(m);
                quadCount += 1;
            }
        });

        buildMonitorToModelFields();

        appState.watchModelFields($scope, ['epicsServerAnimation.serverType'], processEPICSServer);
        // the elements UI get setup in the next digest cycle, so wait before disabling
        panelState.waitForUI(function() {
            processEPICSServer();
            processKickers();
        });

        $scope.$on('modelChanged', function(e, name) {
            if (name.indexOf('KICKER') >= 0) {
                updateKicker(name);
            }
            else if (name == 'epicsServerAnimation') {
                processEPICSServer();
                updateEPICSServer();
            }
            else if (name == 'beamSteering') {
                updateBeamSteering();
            }
        });
    });

    self.simState = persistentSimulation.initSimulationState(self);

    return self;
});

SIREPO.app.directive('analysisActions', function(appState, panelState, webconService) {
    return {
        restrict: 'A',
        scope: {
            modelName: '@',
            modelData: '=',
        },
        template: `
            <button data-ng-if="isSubreport()" data-ng-click="closeSubreport()" title="close" type="button" class="close" style="position: absolute; top: 55px; right: 25px">
              <span>&times;</span>
            </button>
            <div data-ng-show="! isLoading()" style="background: white; padding: 1ex; border-radius: 4px;">
              <div class="clearfix"></div>
              <div data-ng-repeat="view in viewNames track by $index" style="margin-top: -40px;">
                <div data-ng-if="isActiveView(view)" style="margin-top:3ex;">
                  <div data-advanced-editor-pane="" data-model-data="modelData" data-view-name="view" data-field-def="basic" data-want-buttons="{{ wantButtons() }}"></div>
                </div>
              </div>
              <div class="clearfix"></div>
              <div data-ng-show="showFFT()">
                <div data-fft-report="" data-model-data="modelData" style="margin-top: 5px;"></div>
              </div>
            </div>
        `,
        controller: function($scope, $element) {
            var analysisReport;
            var isFirstRefresh = true;
            var modelKey = $scope.modelData
                ? $scope.modelData.modelKey
                : $scope.modelName;
            var viewForEnum = {
                '': 'analysisNone',
                'cluster': 'analysisCluster',
                'fft': 'analysisFFT',
                'fit': 'analysisFit',
                'trim': 'analysisTrim',
            };
            $scope.viewNames = Object.keys(viewForEnum).map(function(k) {
                return viewForEnum[k];
            });

            function addSubreport(clusterIndex) {
                var action = {
                    clusterIndex: clusterIndex,
                };
                var parent = $scope.model();
                ['action', 'clusterMethod', 'clusterCount', 'clusterFields', 'clusterScaleMin', 'clusterScaleMax', 'clusterRandomSeed', 'clusterKmeansInit', 'clusterDbscanEps'].forEach(function(f) {
                    action[f] = parent[f];
                });
                webconService.addSubreport(parent, action);
            }

            function initAnalysisReport(reportScope) {
                analysisReport = reportScope;
                var oldLoad = analysisReport.load;
                analysisReport.load = function(json) {
                    isFirstRefresh = true;
                    $('.scatter-point').popover('hide');
                    oldLoad(json);
                };
                var oldRefresh = analysisReport.refresh;
                analysisReport.refresh = function() {
                    if (isFirstRefresh) {
                        isFirstRefresh = false;
                        setupAnalysisReport();
                        // resize will call refresh again
                        analysisReport.resize();
                        return;
                    }
                    oldRefresh();
                    processTrimRange();
                };
            }

            function processClusterMethod() {
                //TODO(pjm): this does not work correctly for subreports
                panelState.showField($scope.modelName, 'clusterCount', $scope.model().clusterMethod != 'dbscan');
            }

            function processTrimRange() {
                var model = $scope.model();
                if (model && model.action == 'trim') {
                    model.trimField = model.x;
                    var xDomain = analysisReport.axes.x.scale.domain();
                    model.trimMin = xDomain[0];
                    model.trimMax = xDomain[1];
                }
            }

            function roundTo3Places(f) {
                return Math.round(f * 1000) / 1000;
            }

            function setupAnalysisReport() {
                analysisReport.select('svg').selectAll('.overlay').classed('disabled-overlay', true);
                analysisReport.zoomContainer = '.plot-viewport';
                if ($scope.model().action == 'cluster'
                    && appState.applicationState()[modelKey].action == 'cluster') {
                    var viewport = analysisReport.select('.plot-viewport');
                    viewport.selectAll('.scatter-point').on('click', function(d, idx) {
                        var clusterIndex = analysisReport.clusterInfo.group[idx];

                        function buttonHandler() {
                            $('.scatter-point').popover('hide');
                            $scope.$apply(function() {
                                addSubreport(clusterIndex);
                            });
                        }

                        $(this).popover({
                            trigger: 'manual',
                            html: true,
                            placement: 'bottom',
                            container: 'body',
                            title: 'Cluster: ' + (clusterIndex + 1),
                            content: '<div><button class="btn btn-default webcon-popover">Open in New Plot</button></div>',
                        }).on('hide.bs.popover', function() {
                            $(document).off('click', buttonHandler);
                        });
                        $('.scatter-point').not($(this)).popover('hide');
                        $(this).popover('toggle');
                        $(document).on('click', '.webcon-popover', buttonHandler);
                    });
                }
            }

            $scope.closeSubreport = function() {
                webconService.removeSubreport($scope.model().id);
                appState.saveChanges('hiddenReport');
            };

            $scope.isActiveView = function(view) {
                var model = $scope.model();
                if (model) {
                    return viewForEnum[model.action || ''] == view;
                }
                return false;
            };

            $scope.isLoading = function() {
                return panelState.isLoading(modelKey);
            };

            $scope.isSubreport = function() {
                return modelKey != $scope.modelName;
            };

            $scope.model = function() {
                if (appState.isLoaded()) {
                    return appState.models[modelKey];
                }
                return null;
            };

            $scope.showFFT = function() {
                if (appState.isLoaded()) {
                    return $scope.model().action == 'fft'
                        && appState.applicationState()[modelKey].action == 'fft';
                }
                return false;
            };

            $scope.wantButtons = function() {
                if (appState.isLoaded()) {
                    var action = $scope.model().action;
                    if (action == 'trim') {
                        return '';
                    }
                    return '1';
                }
                return '';
            };

            appState.whenModelsLoaded($scope, function() {
                $scope.$on(modelKey + '.summaryData', function (e, data) {
                    var str = '';
                    if (data.p_vals) {
                        var pNames = ($scope.model().fitParameters || '').split(/\s*,\s*/);
                        var pVals = data.p_vals.map(roundTo3Places);
                        var pErrs = data.p_errs.map(roundTo3Places);
                        pNames.forEach(function (p, i) {
                            str = str + p + ' = ' + pVals[i] + ' ± ' + pErrs[i];
                            str = str + (i < pNames.length - 1 ? '; ' : '');
                        });
                    }
                    $($element).closest('.panel-body').find('.focus-hint').text(str);
                });
                appState.watchModelFields($scope, [modelKey + '.action'], processTrimRange);
                appState.watchModelFields($scope, [modelKey + '.clusterMethod', modelKey + '.action'], processClusterMethod);
                processClusterMethod();
            });

            // hook up listener on report content to get the plot events
            $scope.$parent.$parent.$parent.$on('sr-plotLinked', function(event) {
                var reportScope = event.targetScope;
                if (reportScope.modelName.indexOf('analysisReport') >= 0) {
                    initAnalysisReport(reportScope);
                }
                else if (reportScope.modelName.indexOf('fftReport') >= 0) {
                    // it may be useful to have the fftReport scope available
                    //fftReport = reportScope;
                }
            });

        },
    };
});

SIREPO.app.directive('analysisParameter', function(appState, webconService) {
    return {
        restrict: 'A',
        scope: {
            model: '=',
            field: '=',
            isOptional: '@',
        },
        template: `
            <select class="form-control" data-ng-model="model[field]" data-ng-options="item[0] as item[1] for item in parameterValues()"></select>
        `,
        controller: function($scope) {
            $scope.parameterValues = function() {
                return webconService.buildParameterList($scope.isOptional);
            };
        },
    };
});

SIREPO.app.directive('appFooter', function() {
    return {
        restrict: 'A',
        scope: {
            nav: '=appFooter',
        },
        template: `
            <div data-common-footer="nav"></div>
        `,
    };
});

SIREPO.app.directive('appHeader', function(appState, panelState) {
    return {
        restrict: 'A',
        scope: {
            nav: '=appHeader',
        },
        template: `
            <div data-app-header-brand="nav"></div>
            <div data-app-header-left="nav"></div>
            <div data-app-header-right="nav">
              <app-header-right-sim-loaded>
                <div data-sim-sections="">
                  <li class="sim-section" data-ng-class="{active: nav.isActive(\'analysis\')}"><a href data-ng-click="nav.openSection(\'analysis\')"><span class="glyphicon glyphicon-tasks"></span> Analysis</a></li>
                  <li class="sim-section" data-ng-class="{active: nav.isActive(\'controls\')}"><a href data-ng-click="nav.openSection(\'controls\')"><span class="glyphicon glyphicon-dashboard"></span> Controls</a></li>
                </div>
              </app-header-right-sim-loaded>
              <app-settings>
              </app-settings>
              <app-header-right-sim-list>
              </app-header-right-sim-list>
            </div>
        `,
    };
});

SIREPO.app.directive('beamSteeringResults', function(appState) {
    return {
        restrict: 'A',
        scope: {},
        template: `
            <div data-ng-if="showStatus()" class="well" style="margin-top: 10px; margin-bottom: 0;">{{ status }}<br />{{ message }}</div>
        `,
        controller: function($scope) {
            $scope.showStatus = function() {
                if (! appState.isLoaded()) {
                    return false;
                }
                var steering = appState.applicationState().beamSteering;
                if (steering.useSteering == '1') {
                    $scope.status = 'Running ' + appState.enumDescription('SteeringMethod', steering.steeringMethod);
                    $scope.message = '';
                    return true;
                }
                return $scope.status;
            };

            $scope.$on('wc-optimizationValues', function(e, values) {
                if (! values) {
                    $scope.status = '';
                    $scope.message = '';
                }
                else {
                    $scope.status = values.success ? 'Steering Successful' : 'Steering failed to find optimal values.';
                    $scope.message = values.message;
                }
            });
        },
    };
});

SIREPO.app.directive('clusterFields', function(appState, webconService) {
    return {
        restrict: 'A',
        scope: {
            model: '=',
            field: '=',
        },
        template: `
            <div style="margin: -3px 0 5px 0; min-height: 34px; max-height: 13.4em; overflow-y: auto; border: 1px solid #ccc; border-radius: 4px">
              <table class="table table-condensed table-hover" style="margin:0">
                <tbody>
                  <tr data-ng-repeat="item in itemList() track by item.index" data-ng-click="toggleItem(item)">
                    <td>{{ item.name }}</td>
                    <td><input type="checkbox" data-ng-checked="isSelected(item)"></td>
                  </tr>
                </tbody>
              </table>
            </div>
        `,
        controller: function($scope) {
            var itemList, paramList;

            $scope.isSelected = function(item) {
                var v = $scope.model[$scope.field] || [];
                return v[item.index];
            };

            $scope.itemList = function() {
                var params = webconService.buildParameterList();
                if (paramList != params) {
                    paramList = params;
                    itemList = [];
                    paramList.forEach(function(param) {
                        itemList.push({
                            name: param[1],
                            index: parseInt(param[0]),
                        });
                    });
                }
                return itemList;
            };

            $scope.toggleItem = function(item) {
                var v = $scope.model[$scope.field] || [];
                v[item.index] = ! v[item.index];
                $scope.model[$scope.field] = v;
            };
        },
    };
});

SIREPO.app.directive('refreshButton', function(appState) {
    return {
        scope: {
            modelName: '@refreshButton',
        },
        template: `
            <div class="pull-right btn-default btn" data-ng-click="refreshReport()">
              <span class="glyphicon glyphicon-refresh"></span>
            </div>
        `,
        controller: function($scope) {
            $scope.refreshReport = function() {
                appState.models[$scope.modelName].refreshTime = Date.now();
                appState.saveChanges($scope.modelName);
            };
        },
    };
});

SIREPO.app.directive('controlCorrectorReport', function(appState, frameCache) {
    return {
        scope: {},
        template: `
            <div data-report-panel="parameter" data-model-name="correctorSettingReport">
              <div data-refresh-button="correctorSettingReport"></div>
              <button class="btn btn-default" data-ng-show="showSpreadButton()" data-ng-click="toggleSpreadView()">{{ spreadButtonText() }}</button>
            </div>
        `,
        controller: function($scope, $element) {
            $scope.modelName = 'correctorSettingReport';
            $scope.spreadView = false;

            function currentXform(selection) {
                var xform = selection.attr('transform');
                if (! xform) {
                    return [0, 0];
                }
                var xlateIndex = xform.indexOf('translate(');
                if (xlateIndex < 0) {
                    return [0, 0];
                }
                var tmp = xform.substring('translate('.length);
                var coords = tmp.substring(0, tmp.indexOf(')'));
                var delimiter = coords.indexOf(',') >= 0 ? ',' : ' ';
                return [
                    parseFloat(coords.substring(0, coords.indexOf(delimiter))),
                    parseFloat(coords.substring(coords.indexOf(delimiter) + 1))
                ];
            }

            function doSpread(doAnimate) {
                var spread = [40.0, 0];
                var d3self = d3.selectAll($element);
                d3self.selectAll('.param-plot')
                    .each(function (p) {
                        var sp = d3.select(this).selectAll('.scatter-point');
                        var numPts = sp[0].length;
                        var ds = spread.map(function (s) {
                            return s / numPts;
                        });
                        if (doAnimate) {
                            sp = sp.transition();
                        }
                        sp.attr('transform', function (d, j) {
                            var curr = currentXform(d3.select(this));
                            var dx = ds[0] * j * ($scope.spreadView ? 1 : -1);
                            var dy = ds[1] * j * ($scope.spreadView ? 1 : -1);
                            return 'translate(' + (curr[0] + dx) + ',' + (curr[1] + dy) + ')';
                        });
                    });
            }

            $scope.showSpreadButton = function() {
                return (appState.models.correctorSettingReport || {}).plotOrder == 'position';
            };

            $scope.spreadButtonText = function () {
                return $scope.spreadView ? 'Collapse' : 'Expand';
            };

            $scope.toggleSpreadView = function () {
                 $scope.spreadView = ! $scope.spreadView;
                 doSpread(true);
            };

            // changing plot visibility triggers a refresh, which undoes the spread.
            // put it back if active but don't animate it
            var spreadEvents = ['setInfoVisible' ,'retranslate'];
            $scope.$on('sr-plotEvent', function (e, data) {
                if (spreadEvents.indexOf(data.name) < 0) {
                    return;
                }
                if ($scope.spreadView) {
                    doSpread();
                }
            });
        },
    };
});

SIREPO.app.directive('equation', function(appState, webconService, $timeout) {
    return {
        scope: {
            model: '=',
            field: '=',
            form: '=',
        },
        template: `
            <div>
                <input type="text" data-ng-change="validateAll()" data-ng-model="model[field]" class="form-control" required>
                <input type="checkbox" data-ng-model="model.autoFill" data-ng-change="validateAll()"> Auto-fill variables
            </div>
        `,
        controller: function ($scope) {

            var defaultFitVars = ['x', 'y', 'z', 't'];

            function tokenizeEquation() {
                return webconService.tokenizeEquation($scope.model[$scope.field]);
            }

            function extractParams() {

                var params = webconService.tokenizeParams($scope.model.fitParameters).sort();
                var tokens = tokenizeEquation().filter(function (t) {
                    return t !== $scope.model.fitVariable;
                });

                // remove parameters no longer in the equation
                params.reverse().forEach(function (p, i) {
                    if (tokens.indexOf(p) < 0) {
                        params.splice(i, 1);
                    }
                });

                // add tokens not represented
                tokens.forEach(function (t) {
                    if (params.indexOf(t) < 0) {
                        params.push(t);
                    }
                });
                params.sort();

                return params;
            }

            function extractVar() {
                var tokens = tokenizeEquation();
                var indVar = $scope.model.fitVariable;

                if (! indVar|| tokens.indexOf(indVar) < 0) {
                    indVar = null;
                    tokens.forEach(function (t) {
                        if (indVar) {
                            return;
                        }
                        if (defaultFitVars.indexOf(t) >= 0) {
                            indVar = t;
                        }
                    });
                }
                return indVar;
            }

            $scope.validateAll = function() {
                if ($scope.model.autoFill) {
                    // allow time for models to be set before validating
                    $timeout(function () {
                        $scope.model.fitVariable = extractVar();
                        $scope.model.fitParameters = extractParams().join(',');
                    });
                }

                $scope.form.$$controls.forEach(function (c) {
                    c.$setDirty();
                    c.$validate();
                });
            };

            if ($scope.model.autoFill === null) {
                $scope.model.autoFill = true;
            }
        },
    };
});

SIREPO.app.directive('equationVariables', function(webconService, $timeout) {
    return {
        restrict: 'A',
        scope: {
            field: '=',
            form: '=',
            isVariable: '<',
            model: '=',
        },
        template: `
            <div>
                <input type="text" data-ng-model="model[field]" data-valid-variable-or-param="" class="form-control" required />
            </div>
            <div class="sr-input-warning" data-ng-show="warningText.length > 0">{{warningText}}</div>
        `,
        controller: function($scope, $element) {
        },
    };
});

SIREPO.app.directive('fftReport', function(appState) {
    return {
        scope: {
            modelData: '=',
        },
        template: `
            <div data-report-content="parameter" data-model-key="{{ modelKey }}"></div>
        `,
        controller: function($scope, $element) {
            $scope.modelKey = 'fftReport';
            if ($scope.modelData) {
                $scope.modelKey += appState.models[$scope.modelData.modelKey].id;
            }

            $scope.$on($scope.modelKey + '.summaryData', function (e, data) {
                var str = '';
                data.freqs.forEach(function (wi, i) {
                    if (str == '') {
                        str = 'Found frequncies: ';
                    }
                    var w = wi[1];
                    str = str + w + 's-1';
                    str = str + (i < data.freqs.length - 1 ? ', ' : '');
                });
                $($element).find('.focus-hint').text(str);
            });
        },
    };
});

SIREPO.app.directive('plotActionButtons', function(appState) {
    return {
        restrict: 'A',
        scope: {
            model: '=',
            field: '=',
        },
        template: `
            <div class="text-center">
            <div class="btn-group">
              <button class="btn sr-enum-button" data-ng-repeat="item in enumValues" data-ng-click="model[field] = item[0]" data-ng-class="{\'active btn-primary\': isSelectedValue(item[0]), \'btn-default\': ! isSelectedValue(item[0])}">{{ item[1] }}</button>
            </div>
            </div>
        `,
        controller: function($scope) {
            $scope.enumValues = SIREPO.APP_SCHEMA.enum.PlotAction;

            $scope.isSelectedValue = function(value) {
                if ($scope.model && $scope.field) {
                    return $scope.model[$scope.field] == value;
                }
                return false;
            };
        },
    };
});

SIREPO.app.directive('trimButton', function(appState, webconService) {
    return {
        restrict: 'A',
        scope: {
            model: '=',
            field: '=',
            modelName: '=',
        },
        template: `
            <div class="text-center">
              <button class="btn btn-default" data-ng-click="trimPlot()">Open in New Plot</button>
            </div>
        `,
        controller: function($scope) {
            $scope.trimPlot = function() {
                var action = {};
                ['action', 'trimField', 'trimMin', 'trimMax'].forEach(function(f) {
                    action[f] = $scope.model[f];
                });
                webconService.addSubreport($scope.model, action);
                appState.cancelChanges($scope.modelName + ($scope.model.id || ''));
            };
        },
    };
});

SIREPO.app.directive('validVariableOrParam', function(webconService) {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attrs, ngModel) {

            // set dirty on load to catch invalid variables that might have been saved
            if (! ngModel.$valid) {
                ngModel.$setDirty();
            }

            function isUnique (val, arr) {
                var i = arr.indexOf(val);
                if (i < 0) {
                    throw new Error(val + ': Value not in array');
                }
                return i === arr.lastIndexOf(val);
            }

            function validateParam(p) {
                scope.warningText = '';
                if (! /^[a-zA-Z]+$/.test(p)) {
                    scope.warningText = (scope.isVariable ? 'Variables' : 'Parameters') + ' must be alphabetic';
                    return false;
                }
                if (! scope.isVariable && p === scope.model.fitVariable) {
                    scope.warningText = p + ' is an independent variable';
                    return false;
                }
                if (webconService.tokenizeEquation(scope.model.fitEquation).indexOf(p) < 0) {
                    scope.warningText = p + ' does not appear in the equation';
                    return false;
                }
                if (! isUnique(p, webconService.tokenizeParams(ngModel.$viewValue))) {
                    scope.warningText = p + ' is duplicated';
                    return false;
                }
                if (p.length > 1) {
                    scope.warningText = p + ': use single character';
                    return false;
                }

                return true;
            }

            ngModel.$validators.validTokens = function (v) {
                if (! v) {
                    scope.warningText = '';
                    return false;
                }
                return webconService.tokenizeParams(v)
                    .reduce(function (valid, p) {
                        return valid && validateParam(p);
                    }, true);
            };
        },
    };
});

SIREPO.app.directive('webconLattice', function(appState) {
    return {
        restrict: 'A',
        scope: {},
        template: `
            <div class="col-sm-10 col-sm-offset-1 col-md-8 col-md-offset-2 col-xl-6 col-xl-offset-3">
              <div class="webcon-lattice">
                <div id="sr-lattice" data-lattice="" class="sr-plot" data-model-name="beamlines" data-flatten="1"></div>
                <div class="row">
                  <div class="col-xs-2">HV KICKER 1</div>
                  <div class="col-xs-2">HV KICKER 2</div>
                  <div class="col-xs-2 text-right">F/D QUAD 1</div>
                  <div class="col-xs-2">HV KICKER 3</div>
                  <div class="col-xs-2">HV KICKER 4</div>
                  <div class="col-xs-2 text-center">F/D QUAD 2</div>
                </div>
              </div>
            </div>
        `,
        controller: function($scope) {
            var axis, latticeScope;

            function windowResize() {
                if (axis) {
                    axis.scale.range([0, $('.webcon-lattice').parent().width()]);
                    latticeScope.updateFixedAxis(axis, 0, 50, 65, 55);
                    $scope.$applyAsync();
                }
            }

            $scope.isLoaded = appState.isLoaded;

            $scope.$on('sr-latticeLinked', function(event) {
                latticeScope = event.targetScope;
                event.stopPropagation();
                axis = {
                    scale: d3.scale.linear(),
                    //TODO(pjm): 3.4 is the hard-code example beamline length
                    domain: [0, 3.4],
                };
                axis.scale.domain(axis.domain);
                windowResize();
            });

            $scope.$on('sr-window-resize', windowResize);
        },
    };
});

SIREPO.app.directive('bpmMonitorPlot', function(appState, plot2dService, plotting, webconService) {
    return {
        restrict: 'A',
        scope: {
            modelName: '@',
        },
        templateUrl: '/static/html/plot2d.html' + SIREPO.SOURCE_CACHE_KEY,
        controller: function($scope) {
            var points;

            $scope.isClientOnly = true;
            $scope.isZoomXY = true;

            $scope.init = function() {
                plot2dService.init2dPlot($scope, {
                    margin: {top: 50, right: 10, bottom: 50, left: 75},
                });
                $scope.load();
            };

            $scope.load = function() {
                //TODO(pjm): compute BPM positions
                var TITLE = {
                    'watchpointReport27': 'z = 1.0m',
                    'watchpointReport9': 'z = 0.4m',
                    'watchpointReport28': 'z = 2.1m',
                    'watchpointReport29': 'z = 2.7m',
                };
                points = [];
                $scope.aspectRatio = 1;
                ['x', 'y'].forEach(function(dim) {
                    $scope.axes[dim].domain = [-1, 1];
                    $scope.axes[dim].scale.domain([-0.0015, 0.0015]).nice();
                });
                $scope.updatePlot({
                    x_label: 'x [m]',
                    y_label: 'y [m]',
                    title: TITLE[$scope.modelName],
                });
                plotting.addConvergencePoints($scope.select, '.plot-viewport', [], []);
            };

            $scope.refresh = function() {
                plotting.refreshConvergencePoints($scope.select, '.plot-viewport', $scope.graphLine);
                $scope.select('.plot-viewport').selectAll('.webcon-scatter-point')
                    .data(points)
                    .enter().append('circle')
                    .attr('class', 'webcon-scatter-point')
                    .attr('r', 8);
                $scope.select('.plot-viewport').selectAll('.webcon-scatter-point')
                    .attr('cx', $scope.graphLine.x())
                    .attr('cy', $scope.graphLine.y())
                    .attr('style', function(d) {
                        return 'fill: rgba(0, 0, 255, 0.4); stroke-width: 2; stroke: black';
                    });
            };

            function pushAndTrim(p) {
                var MAX_BPM_POINTS = 10;
                points.push(p);
                if (points.length > MAX_BPM_POINTS) {
                    points = points.slice(points.length - MAX_BPM_POINTS);
                }
            }

            $scope.$on('sr-clearPointData', function() {
                points = [];
                plotting.addConvergencePoints($scope.select, '.plot-viewport', [], points);
                $scope.select('.plot-viewport').selectAll('.webcon-scatter-point').remove();
                $scope.refresh();
            });

            $scope.$on('sr-pointData-' + $scope.modelName, function(event, point) {
                if (! point) {
                    return;
                }
                if (point[0] === undefined) {
                    return;
                }
                pushAndTrim(point);
                plotting.addConvergencePoints($scope.select, '.plot-viewport', [], points);
                $scope.refresh();
            });
        },
        link: function link(scope, element) {
            plotting.linkPlot(scope, element);
        },
    };
});
