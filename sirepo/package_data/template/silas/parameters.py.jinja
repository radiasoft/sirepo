#!/usr/bin/env python
from scipy import ndimage, constants
from sirepo.template import silasOpticsLib
import array
import h5py
import math
import numpy as np
import srwlib


def rmsIntensity(IntArray,xvals,yvals):
    """
    Compute rms values in x and y from array
    #IntArray is a 2D array representation of a function
    #xvals represents the horizontal coordinates
    #yvals represents the vertical coordinates
    """
    datax=np.sum(IntArray,axis=1)
    datay=np.sum(IntArray,axis=0)
    sxsq=sum(datax*xvals*xvals)/sum(datax)
    xavg=sum(datax*xvals)/sum(datax)
    sx=math.sqrt(sxsq-xavg*xavg)

    sysq=sum(datay*yvals*yvals)/sum(datay)
    yavg=sum(datay*yvals)/sum(datay)
    sy=math.sqrt(sysq-yavg*yavg)
    return sx, sy, xavg, yavg


def rmsWavefrontIntensity(wfr):
    """
    #Compute rms values from a wavefront object
    """
    IntensityArray2D = array.array('f', [0]*wfr.mesh.nx*wfr.mesh.ny) #"flat" array to take 2D intensity data
    srwlib.srwl.CalcIntFromElecField(IntensityArray2D, wfr, 6, 0, 3, wfr.mesh.eStart, 0, 0) #extracts intensity
    ##Reshaping electric field data from flat to 2D array
    IntensityArray2D = np.array(IntensityArray2D).reshape((wfr.mesh.nx, wfr.mesh.ny), order='C')
    xvals=np.linspace(wfr.mesh.xStart,wfr.mesh.xFin,wfr.mesh.nx)
    yvals=np.linspace(wfr.mesh.yStart,wfr.mesh.yFin,wfr.mesh.ny)
    return IntensityArray2D, rmsIntensity(IntensityArray2D,xvals,yvals)


def wavefront_to_hdf5(wfr, count, pos):
    assert wfr.mesh.ne == 1
    ar2d, (sx, sy, xavg, yavg) = rmsWavefrontIntensity(wfr)
    with open('wavefront.csv', 'a' if pos else 'w') as f:
        if pos == 0:
            f.write('count,pos,sx,sy,xavg,yavg\n')
        f.write(f'{count},{pos},{sx},{sy},{xavg},{yavg}\n')
    if count % 2 == 0:
        return
    count = int((count + 1) / 2)
    with h5py.File(f'wfr{count:05d}.h5', 'w') as f:
        # resize output data to 500x500 max
        max_size = 500
        x_resize = 1
        y_resize = 1
        if len(ar2d[0]) > max_size:
            x_resize = max_size / len(ar2d[0])
        if len(ar2d) > max_size:
            y_resize = max_size / len(ar2d)
        if y_resize != 1 or x_resize != 1:
            ar2d = ndimage.zoom(ar2d, [y_resize, x_resize], order=1)
        dset = f.create_dataset('wfr', data=ar2d)
        dset.attrs['eStart'] = wfr.mesh.eStart
        for dim in ('x', 'y'):
            for field in (f'n{dim}', f'{dim}Start', f'{dim}Fin'):
                dset.attrs[field] = getattr(wfr.mesh, field)
        dset.attrs['sx'] = sx
        dset.attrs['sy'] = sy
        dset.attrs['xavg'] = xavg
        dset.attrs['yavg'] = yavg
        dset.attrs['pos'] = pos


#---

#Specify parameters for simulation
L_cav = {{ simulationSettings_cavity_length }} #Length of cavity [m]
dfL = {{ leftMirrorFocusingError }}
dfR = {{ rightMirrorFocusingError }}

#Crystal parameters
L_cryst = {{ crystal_width }}
n0 = {{ crystal_refractionIndex }}
n2 = {{ crystal_radius }}

wavefrontEnergy = {{ gaussianBeam_photonEnergy }} #Wavefront Energy [eV]. 1.55 eV is 800 nm wavelength
lam = constants.c * constants.value('Planck constant in eV/Hz')/wavefrontEnergy # convert energy [eV] to wavelength [m]

L_eff = L_cav+(1/n0 - 1)*L_cryst #Define effective length as path length reduced by index of refraction n0
print("L_eff=",L_eff)
beta0 = math.sqrt(L_eff*(L_cav/4+dfL)-L_eff**2/4)
print("beta0=",beta0)
sigx0 = math.sqrt(lam*beta0/4/math.pi)
print("sigx0=",sigx0)
sigmaRCenter0 = sigx0

propLen = {{ gaussianBeam_initialPropagationLength }} #Propagation of initial Gaussian [m]. It will then be back-propagated by propLen: a trick to get the Gaussian mode at the waist
pulseE = {{ gaussianBeam_energyPerPulse }} #Total energy of pulse [eV]
mx = 0 #Horizontal mode number (0 for Gaussian)
my = 0 #Vertical mode number (0 for Gaussian)
poltype = {{ gaussianBeam_polarization }} #Polarization of mode (0=linear horizontal, 1=linear vertical, 2=linear 45 deg, 3=linear 135 deg, 4=circular right, 5=circular left, 6=total)
sampFact = {{ simulationSettings_sample_factor }} #Determines grid size of initial wavefront

#---

#Now we construct the initial wavefront at the center of cavity
wfrCenter0=silasOpticsLib.createGsnSrcSRW(sigmaRCenter0,propLen,pulseE,poltype,wavefrontEnergy,sampFact,mx,my) #creates Gaussian wavefront in SRW
(nx0,ny0)=(wfrCenter0.mesh.nx,wfrCenter0.mesh.ny)
print("Initial wavefront calculated on a grid of %d x %d points" %(nx0,ny0))

#---

#Now build the different beamline elements we need to propagate to the right and to the left
propagateHalfCrystal = [silasOpticsLib.createCrystal(n0,n2,L_cryst/2), L_cryst/2]
propagateRight = [silasOpticsLib.createDriftLensBL2((L_cav-L_cryst)/2, L_cav/4 + dfR), (L_cav-L_cryst)/2]
propagateLeft = [silasOpticsLib.createDriftLensBL2((L_cav-L_cryst)/2, L_cav/4 + dfL), (L_cav-L_cryst)/2]
propagateDrift = [silasOpticsLib.createDriftBL(L_cav-L_cryst), (L_cav-L_cryst)/2]

#---

#Now construct a list of wavefront objects starting with initial wavefront wfrCenter0

wfr = wfrCenter0
count = 1
pos = 0
npass = {{ simulationSettings_n_reflections }}

for i in range(npass):
    for section in (
        propagateHalfCrystal,
        propagateRight,
        propagateDrift,
        propagateHalfCrystal,
        propagateHalfCrystal,
        propagateLeft,
        propagateDrift,
        propagateHalfCrystal,
    ):
        wavefront_to_hdf5(wfr, count, pos)
        srwlib.srwl.PropagElecField(wfr, section[0])
        pos += section[1]
        count += 1
wavefront_to_hdf5(wfr, count, pos)
