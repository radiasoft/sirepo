# ^^ pulse defined in laserPulse.py.jinja ^^ #

def _intensity(wavefront):
    return srwl_uti_data.calc_int_from_elec(wavefront).tolist()


def _phase(wavefront):
    z, m = srwl_uti_data.calc_int_from_wfr(
        wavefront,
        _int_type=4,
        _pr=False,
    )
    {% if laserPulse.distribution == "file" %}
    nx, ny = m.nx, m.ny
    {% else %}
    {% endif %}
    return numpy.array(z).reshape(wavefront.mesh.ny, wavefront.mesh.nx).tolist()


def _ranges(wavefront):
    m = wavefront.mesh
    return {
        "x": [m.xStart, m.xFin],
        "y": [m.yStart, m.yFin],
    }


def save_wavefront(pulse):
    h5_data = PKDict()
    for x in {{ dataPaths }}:
        h5_data[x] = globals()[f"_{x}"](pulse.slice_wfr({{ sliceNumber }}))
    template_common.write_dict_to_h5(h5_data, "{{ resultsFile }}")


{% if report in ("initialIntensityReport","initialPhaseReport")  %}
save_wavefront(pulse)
{% else %}

def _build_crystal(model):
    from rslaser.optics import crystal
    return crystal.Crystal(
        params=PKDict(
            l_scale=1,
            length=model.width,
            n0=[model.refractionIndex] * model.numSlices,
            n2=[model.radialVariation] * model.numSlices,
            nslice=model.numSlices,
        )
    )


def _build_drift(length):
    from rslaser.optics import drift
    return drift.Drift(length)


def _build_lens(model):
    from rslaser.optics import lens
    return lens.Lens(model.focalLength)


def _build_watch(model):
    return _build_drift(0.0)


def propagate(pulse):
    beamline = {{ beamline }}
    prev = 0
    for element in [PKDict(e) for e in beamline]:
        dz = element.position - prev
        if dz:
            e = _build_drift(dz)
            pulse = e.propagate(pulse, "default")
        e = globals()[f"_build_{element.type}"](element)
        pulse = e.propagate(pulse, element.propagationType)
        prev = element.position
    return pulse


save_wavefront(propagate(pulse))

{% endif %}
