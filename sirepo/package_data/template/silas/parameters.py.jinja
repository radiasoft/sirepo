# ^^ pulse, slice defined in laserPulse.py ^^ #

w = pulse.slice_wfr(0)
{% if report == "initialIntensityReport" %}
z = srwl_uti_data.calc_int_from_elec(w).tolist()
{% elif report == "initialPhaseReport" %}
z, m = srwl_uti_data.calc_int_from_wfr(
    w,
    _pol={{ laserPulse.polarization | int }},
    _int_type=4,
    _pr=False,
)
{% if laserPulse.geometryFromFiles == "1" %}
nx = m.nx
ny = m.ny
{% else %}
nx = slice.nx_slice
ny = slice.ny_slice
{% endif %}
z = numpy.array(z).reshape(ny, nx).tolist()
{% elif report == "animation" %}

def _build_crystal(model):
    from rslaser.optics import crystal
    return crystal.Crystal(
        params=PKDict(
            l_scale=1,
            length=model.width,
            n0=[model.refractionIndex] * model.numSlices,
            n2=[model.radius] * model.numSlices,
            nslice=model.numSlices,
        )
    )


def _build_drift(length):
    from rslaser.optics import drift
    return drift.Drift(length)


def _build_lens(model):
    from rslaser.optics import lens
    return lens.Lens(model.focalLength)


def _build_watch(model):
    return _build_drift(0.0)


def propagate(pulse):

    beamline = {{ beamline }}
    prev = {"position": 0.0}
    for element in beamline:
        dz = element["position"] - prev["position"]
        if dz:
            e = _build_drift(dz)
            pulse = e.propagate(pulse, "default")
        e = globals()[f"_build_{element['type']}"](PKDict(element))
        pulse = e.propagate(pulse, element["propagationType"])
        prev = element

propagate(pulse)
{% endif %}

