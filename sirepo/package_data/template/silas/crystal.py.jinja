from numpy import array, meshgrid, unique
from pykern.pkcollections import PKDict
from rslaser.optics import Crystal
from rslaser.thermal import ThermoOptic
from sirepo.template import template_common
import dolfin
import mshr
import fenics
import numpy

crystal = Crystal(params=PKDict({{crystalParams}}))

def thermo_optic_sim():
    md = {{ thermalCrystal.mesh_density }}
    thermo = ThermoOptic(crystal, md)
    domain = mshr.Cylinder(
        fenics.Point(0, 0, crystal.params.length / 2),
        fenics.Point(0., 0., -crystal.params.length / 2),
        crystal.params.pop_inversion_mesh_extent,
        crystal.params.pop_inversion_mesh_extent,
    )
    mesh = mshr.generate_mesh(domain, md)
    inds = []
    for item in dolfin.cpp.mesh.facets(mesh):
        inds.append(item.entities(0).tolist())
    vertices = mesh.coordinates()
    thermo.eval_pts = vertices
    #thermo.set_points((
    #    {{thermalTransportSettings_grid_points_r}},
    #    {{thermalTransportSettings_grid_points_w}},
    #    {{thermalTransportSettings_grid_points_z}},
    #), {{thermalTransportSettings_edge_fraction}})
    thermo.set_boundary(2*(crystal.radius*100.)**2./40.)

    if '{{ crystalSimType }}' == "analytical":
        Ts = thermo.{{ pump_pulse_profile }}_solution()

    elif '{{ crystalSimType }}' == "simulated":
        thermo.set_load('{{ pump_pulse_profile }}')
        r = crystal.params.pop_inversion_pump_rep_rate
        if r <= 1:
            Ts = thermo.slow_solution('{{ pump_pulse_profile }}')
        elif r >= 100:
            Ts = thermo.solve_steady()
        else:
            raise AssertionError(f"Invalid rep rate for simulated solve heat_load={'{{ pump_pulse_profile }}'}")

    # Positions of each evaluation point & sets of the unique values
    ptzs = thermo.eval_pts[:, 2]
    ptrs = (thermo.eval_pts[:, 0] ** 2 + thermo.eval_pts[:, 1] ** 2) ** 0.5
    zs = unique(ptzs)
    rs = unique(ptrs)
    rcenter = rs.min()
    zface = zs.min() if crystal.params.pop_inversion_pump_type != "right" else zs.max()

    # Radial values reflected across axis & meshgrid with longitudinal values
    temp_profile = PKDict(
        radial=[rs, Ts[ptzs==zface]],
        longitudinal=[zs, Ts[ptrs==rcenter]]
    )
    pTs = Ts.reshape((len(rs), len(zs)), order='F')
    pTs = array((pTs[::-1]).tolist()+pTs[1:].tolist())
    heat_map = Ts.T

    return PKDict(
        thermo=thermo,
        heat_map=heat_map,
        temp_profile=temp_profile,
        intensity=Ts,
        vertices=vertices,
        indices=numpy.array(inds),
        #indices=numpy.array([nT, n0Fit, n2Fit])
    )


res = thermo_optic_sim()


# we will provide these indices to plotly so it can draw proper surfaces
print("intensity", res.intensity.shape)
numpy.save("indices.npy", res.indices)
print("indices", res.indices.shape)
print("vertices", res.vertices.shape)
numpy.save("intensity.npy", res.intensity)
numpy.save("vertices.npy", res.vertices)
template_common.write_dict_to_h5(
    res.temp_profile,
    "tempProfile.h5"
)
template_common.write_dict_to_h5(
    PKDict(
        intensity=res.heat_map,
        ranges=PKDict(
            x=[
                -crystal.params.pop_inversion_mesh_extent,
                crystal.params.pop_inversion_mesh_extent,
            ],
            y=[
                -crystal.params.length / 2,
                crystal.params.length / 2,
            ],
        ),
    ),
    "tempHeatMap.h5",
)
