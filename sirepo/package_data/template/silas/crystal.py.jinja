from numpy import array, meshgrid, unique
from pykern.pkcollections import PKDict
from rslaser.optics import Crystal
from rslaser.thermal import ThermoOptic
from sirepo.template import template_common
import dolfin
import numpy

crystal = Crystal(params=PKDict({{crystalParams}}))

def thermo_optic_sim():
    thermo = ThermoOptic(crystal, {{thermalCrystal.mesh_density}})

    # Initialize a simulator with a crystal object set
    # Set evaluation points & boundary conditions
    thermo.set_points((
        {{thermalTransportSettings_grid_points_r}},
        {{thermalTransportSettings_grid_points_w}},
        {{thermalTransportSettings_grid_points_z}},
    ), {{thermalTransportSettings_edge_fraction}})
    thermo.set_boundary(2*(crystal.radius*100.)**2./40.)

    if '{{ crystalSimType }}' == "analytical":
        Ts = thermo.{{ pump_pulse_profile }}_solution() #solve_steady()#gaussian_solution()

    elif '{{ crystalSimType }}' == "simulated":
        thermo.set_load('{{ pump_pulse_profile }}')
        r = crystal.params.pop_inversion_pump_rep_rate
        if r <= 1:
            Ts = thermo.slow_solution('{{ pump_pulse_profile }}')
        elif r >= 100:
            Ts = thermo.solve_steady()
        else:
            raise AssertionError(f"Invalid rep rate for simulated {'{{ pump_pulse_profile }}'}")

    nT, n0Fit, n2Fit = thermo.compute_indices(Ts)
    # Positions of each evaluation point & sets of the unique values
    ptzs = thermo.eval_pts[:, 2]
    ptrs = (thermo.eval_pts[:, 0] ** 2 + thermo.eval_pts[:, 1] ** 2) ** 0.5
    zs = unique(ptzs)
    rs = unique(ptrs)
    rcenter = rs.min()
    zface = zs.min() if crystal.params.pop_inversion_pump_type != "right" else zs.max()

    # Radial values reflected across axis & meshgrid with longitudinal values
    rrs = array((-rs[::-1]).tolist() + rs[1:].tolist())
    RZ, ZR = meshgrid(rrs, zs)
    temp_profile = PKDict(
        radial=[rs, Ts[ptzs==zface]],
        longitudinal=[zs, Ts[ptrs==rcenter]]
    )
    pTs = Ts.reshape((len(rs), len(zs)), order='F')
    pTs = array((pTs[::-1]).tolist()+pTs[1:].tolist())
    heat_map = pTs.T
    return PKDict(
        thermo=thermo,
        heat_map=heat_map,
        temp_profile=temp_profile,
        nT=nT,
        n0Fit=n0Fit,
        n2Fit=n2Fit,
    )



res = thermo_optic_sim()

# for 3D plots, get the facets, and build an array
# containing the indices of their coordinates
inds = []
for item in dolfin.cpp.mesh.facets(res.thermo.mesh):
    inds.append(item.entities(0).tolist())

# we will provide these indices to plotly so it can draw proper surfaces
inds = numpy.array(inds)
numpy.save("indices.npy", inds)
numpy.save("vertices.npy", res.thermo.mesh.coordinates())
template_common.write_dict_to_h5(
    res.temp_profile,
    "tempProfile.h5"
)
template_common.write_dict_to_h5(
    PKDict(
        intensity=res.heat_map,
        ranges=PKDict(
            x=[
                -crystal.params.pop_inversion_mesh_extent,
                crystal.params.pop_inversion_mesh_extent,
            ],
            y=[
                -crystal.params.length / 2,
                crystal.params.length / 2,
            ],
        ),
    ),
    "tempHeatMap.h5",
)
