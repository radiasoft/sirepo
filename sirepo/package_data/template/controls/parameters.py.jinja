# -*- python -*-
from pykern import pkcompat
from pykern import pkio
from pykern.pkcollections import PKDict
from pykern.pkdebug import pkdp, pkdlog
from sirepo.sim_data.controls import AmpConverter
from sirepo.template import particle_beam
import os
import numpy as np
import re
import requests
import scipy.optimize
import sirepo.pkcli.controls
import sirepo.pkcli.madx
import sirepo.template.madx
import subprocess

{% if controlSettings_operationMode == 'madx' %}
lattice_file = """
{{ madxSource -}}
"""

amp_tables_by_name = PKDict({
{% for k in ampTables %}
    "{{ k }}": [
        {% for row in ampTables[k] %}
        [{{ row[0] }}, {{ row[1] }}],
        {% endfor %}
    ],
{% endfor %}
})

amp_table_for_corrector = [
{% for row in ampTableNames %}
    {% if row %}
    amp_tables_by_name['{{ row }}'],
    {% else %}
    None,
    {% endif %}
{% endfor %}
]
{% endif %}

targets = np.array([
    # [target value, weight]
    {% for v in optimizerTargets %}
    {% if 'x' in v %}
    [{{ v.x }}, {{ v.weight }}],
    {% endif %}
    {% if 'y' in v %}
    [{{ v.y }}, {{ v.weight }}],
    {% endif %}
    {% endfor %}
])

finished_sims = False
_FAIL_COST = 1e24


def _failed_sim_results():
    return np.full({{ monitorCount }}, _FAIL_COST), _FAIL_COST

{% if optimizerSettings_method == 'nmead' %}
def _nelder_mead_cost_function(correctors):
    readings, cost = update_and_read_results(correctors)
    return cost


def _optimize_nelder_mead(initial_correctors):
    opt = scipy.optimize.minimize(
        _nelder_mead_cost_function,
        initial_correctors,
        method='Nelder-Mead',
        options={
            'maxiter': 500,
            'maxfev': 500,
        },
        tol={{ optimizerSettings_tolerance }},
    )
    res = {
        'message': opt.message,
        'success': opt.success,
    }
    if 'x' in opt and len(opt.x) == len(initial_correctors):
        res['result'] = opt.x
        # run one last time with optimal settings
        update_and_read_results(opt.x)
    return res
{% endif %}

{% if optimizerSettings_method == 'polyfit' %}
def _optimize_polyfit(variable_count):
    settings_0 = np.zeros(variable_count)
    sets = np.identity(variable_count)
    M = np.zeros([variable_count, len(targets)])
    sets_a = np.linspace(-5, 5, 5) * 0.00001
    readings = np.zeros([len(targets), 5])
    for i in range(0, len(settings_0)):
        for j in range(0, len(sets_a)):
            setting_test = sets[i,:] * sets_a[j]
            r, cost = update_and_read_results(setting_test)
            if cost == _FAIL_COST:
                raise AssertionError(f'Linear optimization step failed')
            readings[:,j] = r
        for k in range(0, len(targets)):
            M[i,k] = np.polyfit(sets_a, readings[k,:], 1)[0]
    # inverse response matrix
    MI = np.linalg.pinv(M.T)
    # reset the beam-line
    readings_1, cost = update_and_read_results(settings_0)
    if cost == _FAIL_COST:
        raise AssertionError('Linear optimization reset failed')
    # create settings to cancel out offsets
    new_sets = np.dot(MI, -np.array(readings_1))
    if update_and_read_results(new_sets[:variable_count])[1] == _FAIL_COST:
        raise AssertionError(f'Final optimization failed')
    return {
        'message': '',
        'success': True,
        'result': new_sets,
    }
{% endif %}

def update_and_read_results(correctors):
{% if controlSettings_operationMode == 'DeviceServer' %}
    return set_correctors_and_read_device_server(correctors)
{% else %}
    global finished_sims
    columns, observes = run_simulation(correctors)
    if columns:
        readings = []
        finished_sims = True
        for i in range(len(observes)):
            if '_MONITOR' in observes[i]:
                readings += [columns['x0'][i], columns['y0'][i]]
            elif '_HMONITOR' in observes[i]:
                readings += [columns['x0'][i]]
            elif '_VMONITOR' in observes[i]:
                readings += [columns['y0'][i]]
            else:
                pass
        res = np.array(readings)
        cost = update_summary_csv(correctors.tolist(), readings)
        read_cols_and_save_report('ptc_track.file.tfsone', '{{ ptcTrackFile }}', '{{ ptcTrackColumns }}')
        return res, cost
    return _failed_sim_results()
{% endif %}

{% if controlSettings_operationMode == 'madx' %}
def check_twiss_success():
    beam_data, observes, columns = particle_beam.read_ptc_data('ptc_track.file.tfsone')
    res = particle_beam.analyze_ptc_beam(
        beam_data,
        mc2={{ mc2 }},
    )
    for c in ('beta_x', 'beta_y', 'alpha_x', 'alpha_y'):
        if list(filter(lambda x: np.isnan(x), res[c])):
            return None, None
    return res, observes


def run_simulation(correctors):
    lattice = lattice_file
    values = {}
    for idx in range(len(correctors)):
        ac = AmpConverter(
            PKDict(
                {% if command_beam_particle == 'other' %}
                mass={{command_beam_mass}},
                charge={{command_beam_charge}},
                {% else %}
                particle="{{command_beam_particle}}",
                {% endif %}
                gamma={{command_beam_gamma}},
            ),
            amp_table_for_corrector[idx],
        )
        values[f'sr_opt{idx}'] = ac.current_to_kick(correctors[idx])
    with open('in.madx', 'w') as f:
        for k in values:
            lattice = re.sub('{' + k + '}', str(values[k]), lattice)
        f.write(lattice)
    p = subprocess.run(('madx', 'in.madx'), capture_output=True, text=True)
    pkio.write_text('madx.log', p.stdout)
    pkio.write_text('madx.err', p.stderr)
    if p.returncode != 0 or p.stdout.count('is lost') == {{ bunch_numberOfParticles }}:
        return None, None
    return check_twiss_success()


def read_cols_and_save_report(default_file, save_file, cols_file):
    if pkio.py_path(default_file).exists():
        cols = sirepo.template.madx.file_info(
                default_file,
                pkio.py_path('.'),
                'unused',
            ).plottableColumns
        pkio.write_text(cols_file, ','.join(cols))
        os.rename(default_file, save_file)

{% elif controlSettings_operationMode == 'DeviceServer' %}

{% for prop_type in property_types %}
{{ prop_type }}_properties = [
    {% for prop in properties[prop_type] %}
    {
        'device': '{{ prop.device }}',
        'name': '{{ prop.name }}',
        'type': '{{ prop.type }}',
        {% if prop.index is not none %}
        'index': {{ prop.index }},
        {% endif %}
    },
    {% endfor %}
]
{% endfor %}

_DEVICE_SERVER_BASEPATH = '{{ controlSettings_deviceServerURL }}'

value_regexp = [
    r'^\s*(\[.*?\])\s*,?',
    r'^\s*(.+?)\s*(?:,|$)',
]


def next_value(text):
    def parse_array(text):
        if text[0] == '[':
            text = re.sub(r'\[|\]', '', text)
            return list(re.split(r'\s*,\s*', text))
        return text
    for regexp in value_regexp:
        m = re.search(regexp, text)
        if m:
            v = m.group(1)
            assert v
            text = re.sub(regexp, '', text).strip()
            return text, parse_array(v)
    raise AssertionError(f'Un-parse-able value: "{text}"')


def read_values(text):
    res = []
    while True:
        text, v = next_value(text.strip())
        res.append(v)
        if not text:
            break
    return res


def read_device_server():
    # call DeviceServer to read all process variables
    # write to summaryCSV
    # return monitor values
    url = _DEVICE_SERVER_BASEPATH + '/api/device/list/value?' \
        + 'names=' + ','.join([v['device'] for v in read_properties]) \
        + '&props=' + ','.join([v['name'] for v in read_properties])
    response = requests.get(url)
    if response.status_code != requests.codes.ok:
        return _failed_sim_results()
    assert 'sirepo-dev' in response.headers \
        and response.headers['sirepo-dev'] == '1', \
        'ATTEMPT TO RUN SIREPO AGAINST NON-DEV DEVICE SERVER'
    values = read_values(response.text)
    correctors = []
    readings = []
    for idx in range(len(values)):
        prop = read_properties[idx]
        v = values[idx]
        if 'index' in prop:
            v = v[prop['index']]
        if 'MONITOR' in prop['type']:
            readings += [float(v)]
        elif 'KICKER' in prop['type']:
            correctors += [float(v)]
    cost = update_summary_csv(correctors, readings)
    return readings, cost


context_id = None

def set_correctors_and_read_device_server(correctors):
    global context_id
    if not context_id:
        url = _DEVICE_SERVER_BASEPATH + '/api/device/context?{{ deviceServerSetContext }}'
        response = requests.get(url)
        if response.status_code != requests.codes.ok:
            raise AssertionError(f'set context request failed: {response.text}')
        context_id = response.text.strip()
    url = _DEVICE_SERVER_BASEPATH + '/api/device/list/value?' \
        + 'names=' + ','.join([v['device'] for v in write_properties]) \
        + '&props=' + ','.join([v['name'] for v in write_properties]) \
        + '&values=' + ','.join([str(v) for v in correctors.tolist()]) \
        + '&context=' + context_id
    response = requests.put(url)
    if response.status_code != requests.codes.ok:
        raise AssertionError(f'set values request failed: {response.text}')
    return read_device_server()


{% endif %}

def update_summary_csv(correctors, readings):
    cost = np.sqrt(np.mean(((readings - targets[:,0]) * 1000) ** 2 * targets[:,1] / np.sum(targets[:,1])))
    with open('{{ summaryCSV }}', 'a') as f:
        f.write('{},{}\n'.format(','.join([str(x) for x in correctors + readings]), cost))
    return cost

{% if controlSettings_operationMode == 'madx' %}
sirepo.pkcli.controls.particle_file_for_external_lattice()
{% endif %}

with open('{{ summaryCSV }}', 'w') as f:
    f.write('{}\n'.format('{{ summaryCSVHeader }}'))

{% if controlSettings_operationMode == 'DeviceServer' and controlSettings_readOnly == '1' %}
# monitor only
import time
while True:
    read_device_server()
    time.sleep(2)
{% else %}
  {% if optimizerSettings_method == 'nmead' %}
    {% if controlSettings_operationMode == 'DeviceServer' %}
# check connectivity to DeviceServer first with a read
if read_device_server()[1] == _FAIL_COST:
    raise AssertionError('Initial DeviceServer read failed')
    {% endif %}
res = _optimize_nelder_mead({{ initialCorrectors }})
  {% elif optimizerSettings_method == 'polyfit' %}
res = _optimize_polyfit({{ correctorCount }})
  {% elif optimizerSettings_method == 'runOnce' %}
res = {
    'message': '',
    'success': True,
    {% if controlSettings_operationMode == 'DeviceServer' and controlSettings_readOnly == '1' %}
    'result': read_device_server()[0],
    {% else %}
    'result': update_and_read_results(np.array({{ initialCorrectors }}))[0],
    {% endif %}
}
  {% else %}
raise AssertionError('invalid optimizerSettings method: {}'.format('{{ optimizerSettings_method }}'))
  {% endif %}
  {% if controlSettings_operationMode != 'DeviceServer' and optimizerSettings_method != 'runOnce' %}
if not finished_sims:
    raise AssertionError(f'Optimization failed all minimization attempts')
  {% endif %}
{% endif %}
