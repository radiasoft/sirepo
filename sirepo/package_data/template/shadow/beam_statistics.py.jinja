# -*- python -*-
from Shadow.ShadowPreprocessorsXraylib import prerefl, pre_mlayer, bragg
from pykern import pkjson
from pykern.pkcollections import PKDict
from sirepo.template import transfer_mat_bl
from srxraylib.sources import srfunc
import Shadow
import math
import numpy
import re

{% if zonePlateMethods %}
{{zonePlateMethods}}
{% endif %}

{% if simulation_sourceType == 'geometricSource' %}
sigmax = {{ geometricSource_sigmax }}
sigdix = {{ geometricSource_sigdix }}
sigmaz = {{ geometricSource_sigmaz }}
sigdiz = {{ geometricSource_sigdiz }}
{% elif simulation_sourceType == 'undulator' %}
{{undulatorSettings}}
{% elif simulation_sourceType == 'bendingMagnet' %}
source = Shadow.Source()
beam = Shadow.Beam()
source.NPOINT = {{simulation_npoint}}
source.ISTAR1 = {{simulation_istar1}}
{{bendingMagnetSettings}}
beam.genSource(source)
rays = beam.rays
{% endif %}

{% if simulation_sourceType in ('bendingMagnet', 'undulator') %}
def rays_sigma(rays, idx):
    return numpy.sqrt(numpy.mean(rays[:, idx] ** 2))

sigmax = rays_sigma(rays, 0)
sigdix = rays_sigma(rays, 3)
sigmaz = rays_sigma(rays, 2)
sigdiz = rays_sigma(rays, 5)
{% endif %}

beam_stats = []
epsilon = {{beamStatisticsReport_epsilon}}
beam = transfer_mat_bl.create_mat_rays(epsilon, {{ photonEnergy }})

sigma_mat = numpy.matrix([
    [sigmax ** 2, 0, 0, 0],
    [0, sigdix ** 2, 0, 0],
    [0, 0, sigmaz ** 2, 0],
    [0, 0, 0, sigdiz ** 2],
])
alpha = 0

def apply_aperture(oe):
    # sigma matrix adjustment for aperture goes here
    # sigma_mat = transfer_mat_bl.gauss_apert_4x4(
    #     sigma_mat,
    #     lambda_radiation,
    #     oe.RX_SLIT[0] * 1e2,
    #     oe.RZ_SLIT[0] * 1e2,
    # )
    pass

def calculate_stats(pos, oe):
    global alpha
    Tmat, x_prop_cen, xp_prop_cen, z_prop_cen, zp_prop_cen = transfer_mat_bl.tmat_calc(beam.duplicate(), epsilon)
    res = Tmat * sigma_mat * numpy.transpose(Tmat)
    pos += (oe.T_SOURCE if oe else 0)
    if oe:
        # oe.ALPHA is in radians after traceOE()
        alpha = int(alpha + 180 / math.pi * oe.ALPHA) % 360
    beam_stats.append(PKDict(
        isRotated=True if alpha == 90 or alpha == 270 else False,
        s=pos * 1e-2,
        x=x_prop_cen,
        xp=xp_prop_cen,
        z=z_prop_cen,
        zp=zp_prop_cen,
        matrix=Tmat.tolist(),
        sigma_mx=res.tolist(),
        sigmax=math.sqrt(res[0, 0]) * 1e-2,
        sigdix=math.sqrt(res[1, 1]),
        sigmaz=math.sqrt(res[2, 2]) * 1e-2,
        sigdiz=math.sqrt(res[3, 3]),
    ))
    if oe and oe.I_STOP[0] == 0 and oe.RX_SLIT[0] != 0 and oe.RZ_SLIT[0] != 0:
        apply_aperture(oe)
    return pos

def divide_drift(pos, count, distance, divisions={{ beamStatisticsReport_driftDivisions }}):
    if distance < 1e-3:
        return
    for i in range(divisions - 1):
        oe = Shadow.OE()
        oe.DUMMY = 1.0
        oe.set_empty(ALPHA=0)
        oe.FWRITE = 3
        oe.T_IMAGE = 0.0
        oe.T_SOURCE = distance / divisions
        beam.traceOE(oe, count)
        count += 1
        pos = calculate_stats(pos, oe)
    return pos

def process_stats():
    def compute_angx(x, z, xz, scale=1):
        x = numpy.array(x)
        z = numpy.array(z)
        xz = numpy.array(xz)
        return ((1/2) * numpy.arctan(2 * scale * xz / (x ** 2 - z ** 2))).tolist()

    def rotated_values(stats, field):
        if field == 'sigmaxz':
            return [-v.sigma_mx[0][2] if v.isRotated else v.sigma_mx[0][2] for v in stats]
        if field == 'sigmaxpzp':
            return [-v.sigma_mx[1][3] if v.isRotated else v.sigma_mx[1][3] for v in stats]
        if re.search('z', field):
            f = re.sub('z', 'x', field)
        else:
            f = re.sub('x', 'z', field)
        return [v[f] if v.isRotated else v[field] for v in stats]

    res = PKDict(
        s=[v.s for v in beam_stats],
    )
    for f in ('sigmax', 'sigdix', 'sigmaz', 'sigdiz', 'sigmaxz', 'sigmaxpzp', 'x', 'xp', 'z', 'zp'):
        res[f] = rotated_values(beam_stats, f)
    res.angxz = compute_angx(res.sigmax, res.sigmaz, res.sigmaxz, scale=1e-4)
    res.angxpzp = compute_angx(res.sigdix, res.sigdiz, res.sigmaxpzp)
    return res

pos = calculate_stats(0, None)
{{- beamlineOptics}}

pkjson.dump_pretty(process_stats(), filename='{{beamStatsFile}}')
