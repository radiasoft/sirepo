
from impactx import ImpactX, distribution, elements
import amrex.space3d
import h5py
import impactx
import re

sim = ImpactX()

#TODO(pjm): add beam model with additional field values
sim.particle_shape = 2  # B-spline order
sim.space_charge = False
sim.init_grids()

kin_energy_MeV = 2.0e3  # reference energy
bunch_charge_C = 100.0e-12  # used with space charge
npart = {{ distribution_particleCount }}  # number of macro particles
ref = sim.particle_container().ref_particle()
ref.set_charge_qe(1.0).set_mass_MeV(0.510998950).set_kin_energy_MeV(kin_energy_MeV)

{% if distribution_distributionType == 'File' %}

def _vector(value, name):
    res = amrex.space3d.PODVector_real_std()
    for v in value[name]:
        res.push_back(v)
    return res

#TODO(pjm): set energy, charge, npart from file info
with h5py.File("{{ distributionFile }}", "r") as f:
    bp = re.sub(r"\%T/.*", "", f.attrs["basePath"].decode("utf8"))
    last = None
    for n in f[bp]:
        p = f"{bp}{n}"
        if f.attrs["particlesPath"] in f[p]:
            last = p + "/" + f.attrs["particlesPath"].decode("utf8")
    qm_eev = -1.0 / 0.510998950 / 1e6
    sim.particle_container().add_n_particles(
        _vector(f[last], 'beam/position/x'),
        _vector(f[last], 'beam/position/y'),
        _vector(f[last], 'beam/position/t'),
        _vector(f[last], 'beam/momentum/x'),
        _vector(f[last], 'beam/momentum/y'),
        _vector(f[last], 'beam/momentum/t'),
        qm_eev,
        bunch_charge_C,
    )
{% else %}
{% if distribution_distributionType == 'Thermal' %}
distr = distribution.Thermal(
    k={{ distribution_k }},
    kT={{ distribution_kT }},
    kT_halo={{ distribution_kT_halo }},
    normalize={{ distribution_normalize }},
    normalize_halo={{ distribution_normalize_halo }},
    halo={{ distribution_halo }},
)
{% else %}
distr = distribution.{{ distribution_distributionType }}(
    lambdaX={{ distribution_lambdax }},
    lambdaY={{ distribution_lambday }},
    lambdaT={{ distribution_lambdat }},
    lambdaPx={{ distribution_lambdapx }},
    lambdaPy={{ distribution_lambdapy }},
    lambdaPt={{ distribution_lambdapt }},
    muxpx={{ distribution_muxpx }},
    muypy={{ distribution_muypy }},
    mutpt={{ distribution_mutpt }},
)
{% endif %}
sim.add_particles(bunch_charge_C, distr, npart)
{% endif %}

sim.lattice.extend(
    [
        elements.Drift(ds=0, nslice=1),
        elements.BeamMonitor("monitor", backend="h5"),
    ]
)

sim.evolve()

sim.finalize()
