import numpy as np
import keras.losses
from keras.callbacks import CSVLogger
{% if image_data %}

model.compile(
    optimizer='adam',
    loss={{ neuralNet_losses }},
    metrics=['accuracy'],
)
try:
    history = model.fit(
        split.train_gen,
        validation_data=split.val_gen,
        epochs={{ neuralNet_epochs }},
        callbacks=[CSVLogger('fit.csv')])
except Exception as e:
    raise AssertionError(f"Model training failed due to:{e.message}")
{% else %}

model.compile(
    loss={{ neuralNet_losses }},
    optimizer='{{ neuralNet_optimizer }}'
)
model.fit(
    x=train[:, in_idx],
    y=train[:, out_idx],
    validation_data=(validate[:, in_idx], validate[:, out_idx]),
    batch_size={{ neuralNet_batch_size }},
    shuffle={% if neuralNet_shuffle == '1' %}True{% else %}False{% endif %},
    epochs={{ neuralNet_epochs }},
    verbose=False,
    callbacks=[CSVLogger('{{ fitCSVFile }}')],
)
testy = test[:, out_idx]
testx = test[:, in_idx]

{% endif %}

{% if image_data %}
def _all_int(y_true):
    for y in y_true:
        if type(y) != int:
            return False
    return True

if split.test_gen.outScaler:
    p = split.test_gen.outScaler.inverse_transform(model.predict(testx))
    testy = split.test_gen.outScaler.inverse_transform(testy)
else:
    p = model.predict(x=testx)
if _all_int(testy):
    print(p.shape)
    if p.shape[-1] == len(set(testy)):
        p = np.argmax(p, axis=1)
{% else %}
p = model.predict(x=testx)
{% endif %}

{#

TODO (gurhar1133): if ground truth for y is integers
and range of y matches dimension of prediction, then np.argmax
predictions before saving to predict file.

Also, need to handle cases where there is no outScaler
so that an inverse_transform is not accidentally called on
y or predicted y

#}

print("predictions=", p)
model.save('{{ weightedFile }}')
np.save('{{ testFile }}', testy)
np.save('{{ predictFile }}', p)
